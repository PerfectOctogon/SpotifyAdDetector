<html>
<head>
<title>_urllib2_fork.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_urllib2_fork.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Fork of urllib2. 
 
When reading this, don't assume that all code in here is reachable.  Code in 
the rest of mechanize may be used instead. 
 
Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Python 
Software Foundation; All Rights Reserved 
 
Copyright 2002-2009 John J Lee &lt;jjl@pobox.com&gt; 
 
This code is free software; you can redistribute it and/or modify it 
under the terms of the BSD or ZPL 2.1 licenses (see the file 
LICENSE included with the distribution). 
 
&quot;&quot;&quot;</span>

<span class="s2"># XXX issues:</span>
<span class="s2"># If an authentication error handler that tries to perform</span>
<span class="s2"># authentication for some reason but fails, how should the error be</span>
<span class="s2"># signalled?  The client needs to know the HTTP error code.  But if</span>
<span class="s2"># the handler knows that the problem was, e.g., that it didn't know</span>
<span class="s2"># that hash algo that requested in the challenge, it would be good to</span>
<span class="s2"># pass that information along to the client, too.</span>
<span class="s2"># ftp errors aren't handled cleanly</span>
<span class="s2"># check digest against correct (i.e. non-apache) implementation</span>

<span class="s2"># Possible extensions:</span>
<span class="s2"># complex proxies  XXX not sure what exactly was meant by this</span>
<span class="s2"># abstract factory for opener</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">absolute_import</span>

<span class="s3">import </span><span class="s1">base64</span>
<span class="s3">import </span><span class="s1">bisect</span>
<span class="s3">import </span><span class="s1">copy</span>
<span class="s3">import </span><span class="s1">hashlib</span>
<span class="s3">import </span><span class="s1">logging</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">platform</span>
<span class="s3">import </span><span class="s1">posixpath</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">import </span><span class="s1">socket</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">time</span>
<span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">OrderedDict</span>
<span class="s3">from </span><span class="s1">functools </span><span class="s3">import </span><span class="s1">partial</span>
<span class="s3">from </span><span class="s1">io </span><span class="s3">import </span><span class="s1">BufferedReader</span><span class="s3">, </span><span class="s1">BytesIO</span>

<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">_rfc3986</span>
<span class="s3">from </span><span class="s1">._clientcookie </span><span class="s3">import </span><span class="s1">CookieJar</span>
<span class="s3">from </span><span class="s1">._headersutil </span><span class="s3">import </span><span class="s1">normalize_header_name</span>
<span class="s3">from </span><span class="s1">._response </span><span class="s3">import </span><span class="s1">closeable_response</span>
<span class="s3">from </span><span class="s1">.polyglot </span><span class="s3">import </span><span class="s1">(HTTPConnection</span><span class="s3">, </span><span class="s1">HTTPError</span><span class="s3">, </span><span class="s1">HTTPSConnection</span><span class="s3">, </span><span class="s1">URLError</span><span class="s3">,</span>
                       <span class="s1">as_unicode</span><span class="s3">, </span><span class="s1">create_response_info</span><span class="s3">, </span><span class="s1">ftpwrapper</span><span class="s3">,</span>
                       <span class="s1">getproxies</span><span class="s3">, </span><span class="s1">is_class</span><span class="s3">, </span><span class="s1">is_mapping</span><span class="s3">, </span><span class="s1">is_py2</span><span class="s3">, </span><span class="s1">is_string</span><span class="s3">,</span>
                       <span class="s1">iteritems</span><span class="s3">, </span><span class="s1">map</span><span class="s3">, </span><span class="s1">raise_with_traceback</span><span class="s3">, </span><span class="s1">splitattr</span><span class="s3">,</span>
                       <span class="s1">splitpasswd</span><span class="s3">, </span><span class="s1">splitport</span><span class="s3">, </span><span class="s1">splittype</span><span class="s3">, </span><span class="s1">splituser</span><span class="s3">,</span>
                       <span class="s1">splitvalue</span><span class="s3">, </span><span class="s1">unquote</span><span class="s3">, </span><span class="s1">unwrap</span><span class="s3">, </span><span class="s1">url2pathname</span><span class="s3">,</span>
                       <span class="s1">urllib_proxy_bypass</span><span class="s3">, </span><span class="s1">urllib_splithost</span><span class="s3">, </span><span class="s1">urlparse</span><span class="s3">,</span>
                       <span class="s1">urlsplit</span><span class="s3">, </span><span class="s1">urlunparse)</span>


<span class="s3">def </span><span class="s1">sha1_digest(data):</span>
    <span class="s3">if not </span><span class="s1">isinstance(data</span><span class="s3">, </span><span class="s1">bytes):</span>
        <span class="s1">data = data.encode(</span><span class="s4">'utf-8'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">hashlib.sha1(data).hexdigest()</span>


<span class="s3">def </span><span class="s1">md5_digest(data):</span>
    <span class="s3">if not </span><span class="s1">isinstance(data</span><span class="s3">, </span><span class="s1">bytes):</span>
        <span class="s1">data = data.encode(</span><span class="s4">'utf-8'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">hashlib.md5(data).hexdigest()</span>


<span class="s3">if </span><span class="s1">platform.python_implementation() == </span><span class="s4">'PyPy'</span><span class="s1">:</span>
    <span class="s3">def </span><span class="s1">create_readline_wrapper(fh):</span>
        <span class="s1">fh.recv = fh.read</span>
        <span class="s3">if not </span><span class="s1">hasattr(fh</span><span class="s3">, </span><span class="s4">'_drop'</span><span class="s1">):</span>
            <span class="s1">fh._drop = </span><span class="s3">lambda</span><span class="s1">: </span><span class="s3">None</span>
            <span class="s1">fh._reuse = </span><span class="s3">lambda</span><span class="s1">: </span><span class="s3">None</span>
        <span class="s3">return </span><span class="s1">socket._fileobject(fh</span><span class="s3">, </span><span class="s1">close=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">else</span><span class="s1">:</span>
    <span class="s3">def </span><span class="s1">create_readline_wrapper(fh):</span>
        <span class="s1">fh.recv = fh.read</span>
        <span class="s3">if </span><span class="s1">is_py2:</span>
            <span class="s1">ans = socket._fileobject(fh</span><span class="s3">, </span><span class="s1">close=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">fh.recv_into = fh.readinto</span>
            <span class="s1">fh._decref_socketios = </span><span class="s3">lambda</span><span class="s1">: </span><span class="s3">None</span>
            <span class="s1">ans = BufferedReader(socket.SocketIO(fh</span><span class="s3">, </span><span class="s4">'r'</span><span class="s1">))</span>
        <span class="s3">return </span><span class="s1">ans</span>


<span class="s1">splithost = urllib_splithost</span>


<span class="s2"># used in User-Agent header sent</span>
<span class="s1">__version__ = sys.version[:</span><span class="s5">3</span><span class="s1">]</span>

<span class="s1">_opener = </span><span class="s3">None</span>


<span class="s3">def </span><span class="s1">urlopen(url</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s3">global </span><span class="s1">_opener</span>
    <span class="s3">if </span><span class="s1">_opener </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">_opener = build_opener()</span>
    <span class="s3">return </span><span class="s1">_opener._open(url</span><span class="s3">, </span><span class="s1">data)</span>


<span class="s3">def </span><span class="s1">install_opener(opener):</span>
    <span class="s3">global </span><span class="s1">_opener</span>
    <span class="s1">_opener = opener</span>


<span class="s2"># copied from cookielib.py</span>
<span class="s1">_cut_port_re = re.compile(</span><span class="s4">r&quot;:\d+$&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">request_host(request):</span>
    <span class="s0">&quot;&quot;&quot;Return request-host, as defined by RFC 2965. 
 
    Variation from RFC: returned value is lowercased, for convenient 
    comparison. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">url = request.get_full_url()</span>
    <span class="s1">host = urlparse(url)[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s1">host == </span><span class="s4">&quot;&quot;</span><span class="s1">:</span>
        <span class="s1">host = request.get_header(</span><span class="s4">&quot;Host&quot;</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>

    <span class="s2"># remove port, if present</span>
    <span class="s1">host = _cut_port_re.sub(</span><span class="s4">&quot;&quot;</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">host.lower()</span>


<span class="s1">PERCENT_RE = re.compile(</span><span class="s6">b&quot;%[a-fA-F0-9]{2}&quot;</span><span class="s1">)</span>
<span class="s1">ZONE_ID_CHARS = set(bytearray(</span>
    <span class="s6">b&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; b&quot;abcdefghijklmnopqrstuvwxyz&quot; b&quot;0123456789._!-&quot;</span>
<span class="s1">))</span>
<span class="s1">USERINFO_CHARS = ZONE_ID_CHARS | set(bytearray(</span><span class="s6">b&quot;$&amp;'()*+,;=:&quot;</span><span class="s1">))</span>
<span class="s1">PATH_CHARS = USERINFO_CHARS | set(bytearray(</span><span class="s6">b'@/'</span><span class="s1">))</span>
<span class="s1">QUERY_CHARS = FRAGMENT_CHARS = PATH_CHARS | {ord(</span><span class="s6">b&quot;?&quot;</span><span class="s1">)}</span>


<span class="s3">def </span><span class="s1">fix_invalid_bytes_in_url_component(component</span><span class="s3">, </span><span class="s1">allowed_chars=PATH_CHARS):</span>
    <span class="s3">if not </span><span class="s1">component:</span>
        <span class="s3">return </span><span class="s1">component</span>
    <span class="s1">is_bytes = isinstance(component</span><span class="s3">, </span><span class="s1">bytes)</span>
    <span class="s3">if not </span><span class="s1">is_bytes:</span>
        <span class="s1">component = component.encode(</span><span class="s4">'utf-8'</span><span class="s3">, </span><span class="s4">'surrogatepass'</span><span class="s1">)</span>
    <span class="s1">percent_encodings = PERCENT_RE.findall(component)</span>
    <span class="s3">for </span><span class="s1">enc </span><span class="s3">in </span><span class="s1">percent_encodings:</span>
        <span class="s3">if not </span><span class="s1">enc.isupper():</span>
            <span class="s1">component = component.replace(enc</span><span class="s3">, </span><span class="s1">enc.upper())</span>
    <span class="s1">is_percent_encoded = len(percent_encodings) == component.count(</span><span class="s6">b&quot;%&quot;</span><span class="s1">)</span>
    <span class="s1">encoded_component = bytearray()</span>
    <span class="s1">percent = ord(</span><span class="s4">'%'</span><span class="s1">)</span>
    <span class="s3">for </span><span class="s1">byte_ord </span><span class="s3">in </span><span class="s1">bytearray(component):</span>
        <span class="s3">if </span><span class="s1">(is_percent_encoded </span><span class="s3">and </span><span class="s1">byte_ord == percent) </span><span class="s3">or </span><span class="s1">(byte_ord &lt; </span><span class="s5">128 </span><span class="s3">and </span><span class="s1">byte_ord </span><span class="s3">in </span><span class="s1">allowed_chars):</span>
            <span class="s1">encoded_component.append(byte_ord)</span>
            <span class="s3">continue</span>
        <span class="s1">encoded_component.extend(</span><span class="s6">b&quot;%&quot; </span><span class="s1">+ (hex(byte_ord)[</span><span class="s5">2</span><span class="s1">:].encode().zfill(</span><span class="s5">2</span><span class="s1">).upper()))</span>
    <span class="s1">encoded_component = bytes(encoded_component)</span>
    <span class="s3">if not </span><span class="s1">is_bytes:</span>
        <span class="s1">encoded_component = encoded_component.decode(</span><span class="s4">'utf-8'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">encoded_component</span>


<span class="s3">def </span><span class="s1">normalize_url(url):</span>
    <span class="s1">parsed = urlparse(url)</span>
    <span class="s1">netloc = parsed.netloc</span>
    <span class="s3">if not </span><span class="s1">isinstance(netloc</span><span class="s3">, </span><span class="s1">bytes) </span><span class="s3">and </span><span class="s1">netloc:</span>
        <span class="s3">def </span><span class="s1">safe_encode(label):</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">label.encode(</span><span class="s4">'idna'</span><span class="s1">).decode(</span><span class="s4">'ascii'</span><span class="s1">)</span>
            <span class="s3">except </span><span class="s1">ValueError:</span>
                <span class="s3">return </span><span class="s1">label.encode(</span><span class="s4">'ascii'</span><span class="s3">, </span><span class="s4">'replace'</span><span class="s1">).decode(</span><span class="s4">'ascii'</span><span class="s1">)</span>
        <span class="s1">netloc = </span><span class="s4">u'.'</span><span class="s1">.join(map(safe_encode</span><span class="s3">, </span><span class="s1">netloc.split(</span><span class="s4">u'.'</span><span class="s1">)))</span>

    <span class="s3">return </span><span class="s1">urlunparse(parsed._replace(</span>
        <span class="s1">path=fix_invalid_bytes_in_url_component(parsed.path)</span><span class="s3">, </span><span class="s1">netloc=netloc</span><span class="s3">,</span>
        <span class="s1">query=fix_invalid_bytes_in_url_component(parsed.query</span><span class="s3">, </span><span class="s1">QUERY_CHARS)</span><span class="s3">,</span>
        <span class="s1">fragment=fix_invalid_bytes_in_url_component(parsed.fragment</span><span class="s3">, </span><span class="s1">FRAGMENT_CHARS)</span><span class="s3">,</span>
    <span class="s1">))</span>


<span class="s3">class </span><span class="s1">Request:</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None, </span><span class="s1">headers={}</span><span class="s3">,</span>
                 <span class="s1">origin_req_host=</span><span class="s3">None, </span><span class="s1">unverifiable=</span><span class="s3">False, </span><span class="s1">method=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2"># unwrap('&lt;URL:type://host/path&gt;') --&gt; 'type://host/path'</span>
        <span class="s1">self.__original = normalize_url(unwrap(url))</span>
        <span class="s1">self.type = </span><span class="s3">None</span>
        <span class="s1">self._method = method </span><span class="s3">and </span><span class="s1">str(method)</span>
        <span class="s2"># self.__r_type is what's left after doing the splittype</span>
        <span class="s1">self.host = </span><span class="s3">None</span>
        <span class="s1">self.port = </span><span class="s3">None</span>
        <span class="s1">self._tunnel_host = </span><span class="s3">None</span>
        <span class="s1">self.data = data</span>
        <span class="s1">self.headers = OrderedDict()</span>
        <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">iteritems(headers):</span>
            <span class="s1">self.add_header(key</span><span class="s3">, </span><span class="s1">value)</span>
        <span class="s1">self.unredirected_hdrs = OrderedDict()</span>
        <span class="s3">if </span><span class="s1">origin_req_host </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">origin_req_host = request_host(self)</span>
        <span class="s1">self.origin_req_host = origin_req_host</span>
        <span class="s1">self.unverifiable = unverifiable</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self.get_host()  </span><span class="s2"># in py3 cookiejar expect self.host to be not None</span>
        <span class="s3">except </span><span class="s1">Exception:</span>
            <span class="s1">self.host = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">__getattr__(self</span><span class="s3">, </span><span class="s1">attr):</span>
        <span class="s2"># XXX this is a fallback mechanism to guard against these</span>
        <span class="s2"># methods getting called in a non-standard order.  this may be</span>
        <span class="s2"># too complicated and/or unnecessary.</span>
        <span class="s2"># XXX should the __r_XXX attributes be public?</span>
        <span class="s3">if </span><span class="s1">attr[:</span><span class="s5">12</span><span class="s1">] == </span><span class="s4">'_Request__r_'</span><span class="s1">:</span>
            <span class="s1">name = attr[</span><span class="s5">12</span><span class="s1">:]</span>
            <span class="s3">if </span><span class="s1">hasattr(Request</span><span class="s3">, </span><span class="s4">'get_' </span><span class="s1">+ name):</span>
                <span class="s1">getattr(self</span><span class="s3">, </span><span class="s4">'get_' </span><span class="s1">+ name)()</span>
                <span class="s3">return </span><span class="s1">getattr(self</span><span class="s3">, </span><span class="s1">attr)</span>
        <span class="s3">raise </span><span class="s1">AttributeError(attr)</span>

    <span class="s3">def </span><span class="s1">get_method(self):</span>
        <span class="s0">' The method used for HTTP requests '</span>
        <span class="s3">if </span><span class="s1">self._method </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;POST&quot; </span><span class="s3">if </span><span class="s1">self.has_data() </span><span class="s3">else </span><span class="s4">'GET'</span>
        <span class="s3">return </span><span class="s1">self._method</span>

    <span class="s2"># XXX these helper methods are lame</span>

    <span class="s3">def </span><span class="s1">set_data(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s0">' Set the data (a bytestring) to be sent with this request '</span>
        <span class="s1">self.data = data</span>
    <span class="s1">add_data = set_data</span>

    <span class="s3">def </span><span class="s1">has_data(self):</span>
        <span class="s0">' True iff there is some data to be sent with this request '</span>
        <span class="s3">return </span><span class="s1">self.data </span><span class="s3">is not None</span>

    <span class="s3">def </span><span class="s1">get_data(self):</span>
        <span class="s0">' The data to be sent with this request '</span>
        <span class="s3">return </span><span class="s1">self.data</span>

    <span class="s3">def </span><span class="s1">get_full_url(self):</span>
        <span class="s3">return </span><span class="s1">self.__original</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">full_url(self):</span>
        <span class="s2"># In python 3 this is a deleteable and settable property, which when</span>
        <span class="s2"># deleted gets set to None. But this interface does not seem to be used</span>
        <span class="s2"># by any stdlib code, so this should be sufficient.</span>
        <span class="s3">return </span><span class="s1">self.__original</span>

    <span class="s3">def </span><span class="s1">get_type(self):</span>
        <span class="s3">if </span><span class="s1">self.type </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.type</span><span class="s3">, </span><span class="s1">self.__r_type = splittype(self.__original)</span>
            <span class="s3">if </span><span class="s1">self.type </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;unknown url type: %s&quot; </span><span class="s1">% self.__original)</span>
        <span class="s3">return </span><span class="s1">self.type</span>

    <span class="s3">def </span><span class="s1">get_host(self):</span>
        <span class="s3">if </span><span class="s1">self.host </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.host</span><span class="s3">, </span><span class="s1">self.__r_host = splithost(self.__r_type)</span>
            <span class="s3">if </span><span class="s1">self.host:</span>
                <span class="s1">self.host = unquote(self.host)</span>
        <span class="s3">return </span><span class="s1">self.host</span>

    <span class="s3">def </span><span class="s1">get_selector(self):</span>
        <span class="s1">scheme</span><span class="s3">, </span><span class="s1">authority</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">query</span><span class="s3">, </span><span class="s1">fragment = _rfc3986.urlsplit(</span>
            <span class="s1">self.__r_host)</span>
        <span class="s3">if </span><span class="s1">path == </span><span class="s4">&quot;&quot;</span><span class="s1">:</span>
            <span class="s1">path = </span><span class="s4">&quot;/&quot;  </span><span class="s2"># RFC 2616, section 3.2.2</span>
        <span class="s1">fragment = </span><span class="s3">None  </span><span class="s2"># RFC 3986, section 3.5</span>
        <span class="s3">return </span><span class="s1">_rfc3986.urlunsplit([scheme</span><span class="s3">, </span><span class="s1">authority</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">query</span><span class="s3">, </span><span class="s1">fragment])</span>

    <span class="s3">def </span><span class="s1">set_proxy(self</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">type):</span>
        <span class="s1">orig_host = self.get_host()</span>
        <span class="s3">if </span><span class="s1">self.get_type() == </span><span class="s4">'https' </span><span class="s3">and not </span><span class="s1">self._tunnel_host:</span>
            <span class="s1">self._tunnel_host = orig_host</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.type = type</span>
            <span class="s1">self.__r_host = self.__original</span>

        <span class="s1">self.host = host</span>

    <span class="s3">def </span><span class="s1">has_proxy(self):</span>
        <span class="s0">&quot;&quot;&quot;Private method.&quot;&quot;&quot;</span>
        <span class="s2"># has non-HTTPS proxy</span>
        <span class="s3">return </span><span class="s1">self.__r_host == self.__original</span>

    <span class="s3">def </span><span class="s1">get_origin_req_host(self):</span>
        <span class="s3">return </span><span class="s1">self.origin_req_host</span>

    <span class="s3">def </span><span class="s1">is_unverifiable(self):</span>
        <span class="s3">return </span><span class="s1">self.unverifiable</span>

    <span class="s3">def </span><span class="s1">add_header(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">val=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">''' Add the specified header, replacing existing one, if needed. If val 
        is None, remove the header. '''</span>
        <span class="s2"># useful for something like authentication</span>
        <span class="s1">key = normalize_header_name(key)</span>
        <span class="s3">if </span><span class="s1">val </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.headers.pop(key</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.headers[key] = val</span>

    <span class="s3">def </span><span class="s1">add_unredirected_header(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">val):</span>
        <span class="s0">''' Same as :meth:`add_header()` except that this header will not 
        be sent for redirected requests. '''</span>
        <span class="s1">key = normalize_header_name(key)</span>
        <span class="s3">if </span><span class="s1">val </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.unredirected_hdrs.pop(key</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.unredirected_hdrs[key] = val</span>

    <span class="s3">def </span><span class="s1">has_header(self</span><span class="s3">, </span><span class="s1">header_name):</span>
        <span class="s0">''' Check if the specified header is present '''</span>
        <span class="s1">header_name = normalize_header_name(header_name)</span>
        <span class="s3">return </span><span class="s1">(header_name </span><span class="s3">in </span><span class="s1">self.headers </span><span class="s3">or</span>
                <span class="s1">header_name </span><span class="s3">in </span><span class="s1">self.unredirected_hdrs)</span>

    <span class="s3">def </span><span class="s1">get_header(self</span><span class="s3">, </span><span class="s1">header_name</span><span class="s3">, </span><span class="s1">default=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">''' Get the value of the specified header. If absent, return `default` 
        '''</span>
        <span class="s1">header_name = normalize_header_name(header_name)</span>
        <span class="s3">return </span><span class="s1">self.headers.get(</span>
            <span class="s1">header_name</span><span class="s3">,</span>
            <span class="s1">self.unredirected_hdrs.get(header_name</span><span class="s3">, </span><span class="s1">default))</span>

    <span class="s3">def </span><span class="s1">header_items(self):</span>
        <span class="s0">''' Get a copy of all headers for this request as a list of 2-tuples 
        '''</span>
        <span class="s1">hdrs = self.unredirected_hdrs.copy()</span>
        <span class="s1">hdrs.update(self.headers)</span>
        <span class="s3">return </span><span class="s1">list(iteritems(hdrs))</span>


<span class="s3">class </span><span class="s1">OpenerDirector(object):</span>

    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">client_version = </span><span class="s4">&quot;Python-urllib/%s&quot; </span><span class="s1">% __version__</span>
        <span class="s1">self.addheaders = [(</span><span class="s4">'User-agent'</span><span class="s3">, </span><span class="s1">client_version)]</span>
        <span class="s1">self.finalize_request_headers = </span><span class="s3">None</span>
        <span class="s2"># manage the individual handlers</span>
        <span class="s1">self.handlers = []</span>
        <span class="s1">self.handle_open = {}</span>
        <span class="s1">self.handle_error = {}</span>
        <span class="s1">self.process_response = {}</span>
        <span class="s1">self.process_request = {}</span>

    <span class="s3">def </span><span class="s1">add_handler(self</span><span class="s3">, </span><span class="s1">handler):</span>
        <span class="s3">if not </span><span class="s1">hasattr(handler</span><span class="s3">, </span><span class="s4">&quot;add_parent&quot;</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;expected BaseHandler instance, got %r&quot; </span><span class="s1">%</span>
                            <span class="s1">type(handler))</span>

        <span class="s1">added = </span><span class="s3">False</span>
        <span class="s3">for </span><span class="s1">meth </span><span class="s3">in </span><span class="s1">dir(handler):</span>
            <span class="s3">if </span><span class="s1">meth </span><span class="s3">in </span><span class="s1">[</span><span class="s4">&quot;redirect_request&quot;</span><span class="s3">, </span><span class="s4">&quot;do_open&quot;</span><span class="s3">, </span><span class="s4">&quot;proxy_open&quot;</span><span class="s1">]:</span>
                <span class="s2"># oops, coincidental match</span>
                <span class="s3">continue</span>

            <span class="s1">i = meth.find(</span><span class="s4">&quot;_&quot;</span><span class="s1">)</span>
            <span class="s1">protocol = meth[:i]</span>
            <span class="s1">condition = meth[i + </span><span class="s5">1</span><span class="s1">:]</span>

            <span class="s3">if </span><span class="s1">condition.startswith(</span><span class="s4">&quot;error&quot;</span><span class="s1">):</span>
                <span class="s1">j = condition.find(</span><span class="s4">&quot;_&quot;</span><span class="s1">) + i + </span><span class="s5">1</span>
                <span class="s1">kind = meth[j + </span><span class="s5">1</span><span class="s1">:]</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">kind = int(kind)</span>
                <span class="s3">except </span><span class="s1">ValueError:</span>
                    <span class="s3">pass</span>
                <span class="s1">lookup = self.handle_error.get(protocol</span><span class="s3">, </span><span class="s1">{})</span>
                <span class="s1">self.handle_error[protocol] = lookup</span>
            <span class="s3">elif </span><span class="s1">condition == </span><span class="s4">&quot;open&quot;</span><span class="s1">:</span>
                <span class="s1">kind = protocol</span>
                <span class="s1">lookup = self.handle_open</span>
            <span class="s3">elif </span><span class="s1">condition == </span><span class="s4">&quot;response&quot;</span><span class="s1">:</span>
                <span class="s1">kind = protocol</span>
                <span class="s1">lookup = self.process_response</span>
            <span class="s3">elif </span><span class="s1">condition == </span><span class="s4">&quot;request&quot;</span><span class="s1">:</span>
                <span class="s1">kind = protocol</span>
                <span class="s1">lookup = self.process_request</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">continue</span>

            <span class="s1">handlers = lookup.setdefault(kind</span><span class="s3">, </span><span class="s1">[])</span>
            <span class="s3">if </span><span class="s1">handlers:</span>
                <span class="s1">bisect.insort(handlers</span><span class="s3">, </span><span class="s1">handler)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">handlers.append(handler)</span>
            <span class="s1">added = </span><span class="s3">True</span>

        <span class="s3">if </span><span class="s1">added:</span>
            <span class="s2"># the handlers must work in an specific order, the order</span>
            <span class="s2"># is specified in a Handler attribute</span>
            <span class="s1">bisect.insort(self.handlers</span><span class="s3">, </span><span class="s1">handler)</span>
            <span class="s1">handler.add_parent(self)</span>

    <span class="s3">def </span><span class="s1">close(self):</span>
        <span class="s2"># Only exists for backwards compatibility.</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">_call_chain(self</span><span class="s3">, </span><span class="s1">chain</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">, </span><span class="s1">meth_name</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s2"># Handlers raise an exception if no one else should try to handle</span>
        <span class="s2"># the request, or return None if they can't but another handler</span>
        <span class="s2"># could.  Otherwise, they return the response.</span>
        <span class="s1">handlers = chain.get(kind</span><span class="s3">, </span><span class="s1">())</span>
        <span class="s3">for </span><span class="s1">handler </span><span class="s3">in </span><span class="s1">handlers:</span>
            <span class="s1">func = getattr(handler</span><span class="s3">, </span><span class="s1">meth_name)</span>

            <span class="s1">result = func(*args)</span>
            <span class="s3">if </span><span class="s1">result </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">def </span><span class="s1">_open(self</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">result = self._call_chain(self.handle_open</span><span class="s3">, </span><span class="s4">'default'</span><span class="s3">,</span>
                                  <span class="s4">'default_open'</span><span class="s3">, </span><span class="s1">req)</span>
        <span class="s3">if </span><span class="s1">result:</span>
            <span class="s3">return </span><span class="s1">result</span>

        <span class="s1">protocol = req.get_type()</span>
        <span class="s1">result = self._call_chain(self.handle_open</span><span class="s3">, </span><span class="s1">protocol</span><span class="s3">, </span><span class="s1">protocol +</span>
                                  <span class="s4">'_open'</span><span class="s3">, </span><span class="s1">req)</span>
        <span class="s3">if </span><span class="s1">result:</span>
            <span class="s3">return </span><span class="s1">result</span>

        <span class="s3">return </span><span class="s1">self._call_chain(self.handle_open</span><span class="s3">, </span><span class="s4">'unknown'</span><span class="s3">,</span>
                                <span class="s4">'unknown_open'</span><span class="s3">, </span><span class="s1">req)</span>

    <span class="s3">def </span><span class="s1">error(self</span><span class="s3">, </span><span class="s1">proto</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s3">if </span><span class="s1">proto </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'http'</span><span class="s3">, </span><span class="s4">'https'</span><span class="s1">):</span>
            <span class="s2"># XXX http[s] protocols are special-cased</span>
            <span class="s2"># https is not different than http</span>
            <span class="s1">dict = self.handle_error[</span><span class="s4">'http'</span><span class="s1">]</span>
            <span class="s1">proto = args[</span><span class="s5">2</span><span class="s1">]  </span><span class="s2"># YUCK!</span>
            <span class="s1">meth_name = </span><span class="s4">'http_error_%s' </span><span class="s1">% proto</span>
            <span class="s1">http_err = </span><span class="s5">1</span>
            <span class="s1">orig_args = args</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">dict = self.handle_error</span>
            <span class="s1">meth_name = proto + </span><span class="s4">'_error'</span>
            <span class="s1">http_err = </span><span class="s5">0</span>
        <span class="s1">args = (dict</span><span class="s3">, </span><span class="s1">proto</span><span class="s3">, </span><span class="s1">meth_name) + args</span>
        <span class="s1">result = self._call_chain(*args)</span>
        <span class="s3">if </span><span class="s1">result:</span>
            <span class="s3">return </span><span class="s1">result</span>

        <span class="s3">if </span><span class="s1">http_err:</span>
            <span class="s1">args = (dict</span><span class="s3">, </span><span class="s4">'default'</span><span class="s3">, </span><span class="s4">'http_error_default'</span><span class="s1">) + orig_args</span>
            <span class="s3">return </span><span class="s1">self._call_chain(*args)</span>

<span class="s2"># XXX probably also want an abstract factory that knows when it makes</span>
<span class="s2"># sense to skip a superclass in favor of a subclass and when it might</span>
<span class="s2"># make sense to include both</span>


<span class="s3">def </span><span class="s1">build_opener(*handlers):</span>
    <span class="s0">&quot;&quot;&quot;Create an opener object from a list of handlers. 
 
    The opener will use several default handlers, including support 
    for HTTP, FTP and when applicable, HTTPS. 
 
    If any of the handlers passed as arguments are subclasses of the 
    default handlers, the default handlers will not be used. 
    &quot;&quot;&quot;</span>
    <span class="s1">opener = OpenerDirector()</span>
    <span class="s1">default_classes = [ProxyHandler</span><span class="s3">, </span><span class="s1">UnknownHandler</span><span class="s3">, </span><span class="s1">HTTPHandler</span><span class="s3">,</span>
                       <span class="s1">HTTPDefaultErrorHandler</span><span class="s3">, </span><span class="s1">HTTPRedirectHandler</span><span class="s3">,</span>
                       <span class="s1">FTPHandler</span><span class="s3">, </span><span class="s1">FileHandler</span><span class="s3">, </span><span class="s1">HTTPErrorProcessor]</span>
    <span class="s1">default_classes.append(HTTPSHandler)</span>
    <span class="s1">skip = set()</span>
    <span class="s3">for </span><span class="s1">klass </span><span class="s3">in </span><span class="s1">default_classes:</span>
        <span class="s3">for </span><span class="s1">check </span><span class="s3">in </span><span class="s1">handlers:</span>
            <span class="s3">if </span><span class="s1">is_class(check):</span>
                <span class="s3">if </span><span class="s1">issubclass(check</span><span class="s3">, </span><span class="s1">klass):</span>
                    <span class="s1">skip.add(klass)</span>
            <span class="s3">elif </span><span class="s1">isinstance(check</span><span class="s3">, </span><span class="s1">klass):</span>
                <span class="s1">skip.add(klass)</span>
    <span class="s3">for </span><span class="s1">klass </span><span class="s3">in </span><span class="s1">skip:</span>
        <span class="s1">default_classes.remove(klass)</span>

    <span class="s3">for </span><span class="s1">klass </span><span class="s3">in </span><span class="s1">default_classes:</span>
        <span class="s1">opener.add_handler(klass())</span>

    <span class="s3">for </span><span class="s1">h </span><span class="s3">in </span><span class="s1">handlers:</span>
        <span class="s3">if </span><span class="s1">is_class(h):</span>
            <span class="s1">h = h()</span>
        <span class="s1">opener.add_handler(h)</span>
    <span class="s3">return </span><span class="s1">opener</span>


<span class="s3">class </span><span class="s1">BaseHandler:</span>
    <span class="s1">handler_order = </span><span class="s5">500</span>

    <span class="s3">def </span><span class="s1">add_parent(self</span><span class="s3">, </span><span class="s1">parent):</span>
        <span class="s1">self.parent = parent</span>

    <span class="s3">def </span><span class="s1">close(self):</span>
        <span class="s2"># Only exists for backwards compatibility</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">__lt__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">return </span><span class="s1">self.handler_order &lt; getattr(</span>
                <span class="s1">other</span><span class="s3">, </span><span class="s4">'handler_order'</span><span class="s3">, </span><span class="s1">sys.maxsize)</span>

    <span class="s3">def </span><span class="s1">__copy__(self):</span>
        <span class="s3">return </span><span class="s1">self.__class__()</span>


<span class="s3">class </span><span class="s1">HTTPErrorProcessor(BaseHandler):</span>
    <span class="s0">&quot;&quot;&quot;Process HTTP error responses. 
 
    The purpose of this handler is to to allow other response processors a 
    look-in by removing the call to parent.error() from 
    AbstractHTTPHandler. 
 
    For non-2xx error codes, this just passes the job on to the 
    Handler.&lt;proto&gt;_error_&lt;code&gt; methods, via the OpenerDirector.error method. 
    Eventually, HTTPDefaultErrorHandler will raise an HTTPError if no other 
    handler handles the error. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">handler_order = </span><span class="s5">1000  </span><span class="s2"># after all other processors</span>

    <span class="s3">def </span><span class="s1">http_response(self</span><span class="s3">, </span><span class="s1">request</span><span class="s3">, </span><span class="s1">response):</span>
        <span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">hdrs = response.code</span><span class="s3">, </span><span class="s1">response.msg</span><span class="s3">, </span><span class="s1">response.info()</span>

        <span class="s2"># According to RFC 2616, &quot;2xx&quot; code indicates that the client's</span>
        <span class="s2"># request was successfully received, understood, and accepted.</span>
        <span class="s3">if not </span><span class="s1">(</span><span class="s5">200 </span><span class="s1">&lt;= code &lt; </span><span class="s5">300</span><span class="s1">):</span>
            <span class="s2"># hardcoded http is NOT a bug</span>
            <span class="s1">response = self.parent.error(</span>
                <span class="s4">'http'</span><span class="s3">, </span><span class="s1">request</span><span class="s3">, </span><span class="s1">response</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">hdrs)</span>

        <span class="s3">return </span><span class="s1">response</span>

    <span class="s1">https_response = http_response</span>


<span class="s3">class </span><span class="s1">HTTPDefaultErrorHandler(BaseHandler):</span>

    <span class="s3">def </span><span class="s1">http_error_default(self</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">hdrs):</span>
        <span class="s2"># why these error methods took the code, msg, headers args in the first</span>
        <span class="s2"># place rather than a response object, I don't know, but to avoid</span>
        <span class="s2"># multiple wrapping, we're discarding them</span>

        <span class="s3">if </span><span class="s1">isinstance(fp</span><span class="s3">, </span><span class="s1">HTTPError):</span>
            <span class="s1">response = fp</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">response = HTTPError(</span>
                <span class="s1">req.get_full_url()</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">hdrs</span><span class="s3">, </span><span class="s1">fp)</span>
        <span class="s3">assert </span><span class="s1">code == response.code</span>
        <span class="s3">assert </span><span class="s1">msg == response.msg</span>
        <span class="s3">assert </span><span class="s1">hdrs == response.hdrs</span>
        <span class="s3">raise </span><span class="s1">response</span>


<span class="s3">class </span><span class="s1">HTTPRedirectHandler(BaseHandler):</span>
    <span class="s2"># maximum number of redirections to any single URL</span>
    <span class="s2"># this is needed because of the state that cookies introduce</span>
    <span class="s1">max_repeats = </span><span class="s5">4</span>
    <span class="s2"># maximum total number of redirections (regardless of URL) before</span>
    <span class="s2"># assuming we're in a loop</span>
    <span class="s1">max_redirections = </span><span class="s5">10</span>

    <span class="s2"># Implementation notes:</span>

    <span class="s2"># To avoid the server sending us into an infinite loop, the request</span>
    <span class="s2"># object needs to track what URLs we have already seen.  Do this by</span>
    <span class="s2"># adding a handler-specific attribute to the Request object.  The value</span>
    <span class="s2"># of the dict is used to count the number of times the same URL has</span>
    <span class="s2"># been visited.  This is needed because visiting the same URL twice</span>
    <span class="s2"># does not necessarily imply a loop, thanks to state introduced by</span>
    <span class="s2"># cookies.</span>

    <span class="s2"># Always unhandled redirection codes:</span>
    <span class="s2"># 300 Multiple Choices: should not handle this here.</span>
    <span class="s2"># 304 Not Modified: no need to handle here: only of interest to caches</span>
    <span class="s2">#     that do conditional GETs</span>
    <span class="s2"># 305 Use Proxy: probably not worth dealing with here</span>
    <span class="s2"># 306 Unused: what was this for in the previous versions of protocol??</span>

    <span class="s3">def </span><span class="s1">redirect_request(self</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">newurl):</span>
        <span class="s0">&quot;&quot;&quot;Return a Request or None in response to a redirect. 
 
        This is called by the http_error_30x methods when a 
        redirection response is received.  If a redirection should 
        take place, return a new Request to allow http_error_30x to 
        perform the redirect.  Otherwise, raise HTTPError if no-one 
        else should try to handle this url.  Return None if you can't 
        but another Handler might. 
        &quot;&quot;&quot;</span>
        <span class="s3">from </span><span class="s1">._request </span><span class="s3">import </span><span class="s1">Request</span>
        <span class="s1">m = req.get_method()</span>
        <span class="s3">if </span><span class="s1">(code </span><span class="s3">in </span><span class="s1">(</span><span class="s5">301</span><span class="s3">, </span><span class="s5">302</span><span class="s3">, </span><span class="s5">303</span><span class="s3">, </span><span class="s5">307</span><span class="s3">, </span><span class="s4">&quot;refresh&quot;</span><span class="s1">) </span><span class="s3">and </span><span class="s1">m </span><span class="s3">in </span><span class="s1">(</span><span class="s4">&quot;GET&quot;</span><span class="s3">, </span><span class="s4">&quot;HEAD&quot;</span><span class="s1">)</span>
                <span class="s3">or </span><span class="s1">code </span><span class="s3">in </span><span class="s1">(</span><span class="s5">301</span><span class="s3">, </span><span class="s5">302</span><span class="s3">, </span><span class="s5">303</span><span class="s3">, </span><span class="s4">&quot;refresh&quot;</span><span class="s1">) </span><span class="s3">and </span><span class="s1">m == </span><span class="s4">&quot;POST&quot;</span><span class="s1">):</span>
            <span class="s2"># Strictly (according to RFC 2616), 301 or 302 in response</span>
            <span class="s2"># to a POST MUST NOT cause a redirection without confirmation</span>
            <span class="s2"># from the user (of urllib2, in this case).  In practice,</span>
            <span class="s2"># essentially all clients do redirect in this case, so we do</span>
            <span class="s2"># the same.</span>
            <span class="s2"># TODO: really refresh redirections should be visiting; tricky to</span>
            <span class="s2"># fix</span>
            <span class="s1">new = Request(</span>
                <span class="s1">newurl</span><span class="s3">,</span>
                <span class="s1">headers=req.headers</span><span class="s3">,</span>
                <span class="s1">origin_req_host=req.get_origin_req_host()</span><span class="s3">,</span>
                <span class="s1">unverifiable=</span><span class="s3">True,</span>
                <span class="s1">visit=</span><span class="s3">False,</span>
                <span class="s1">timeout=req.timeout)</span>
            <span class="s1">new._origin_req = getattr(req</span><span class="s3">, </span><span class="s4">&quot;_origin_req&quot;</span><span class="s3">, </span><span class="s1">req)</span>
            <span class="s3">return </span><span class="s1">new</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">HTTPError(req.get_full_url()</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">fp)</span>

    <span class="s3">def </span><span class="s1">http_error_302(self</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">headers):</span>
        <span class="s2"># Some servers (incorrectly) return multiple Location headers</span>
        <span class="s2"># (so probably same goes for URI).  Use first header.</span>
        <span class="s3">if </span><span class="s4">'location' </span><span class="s3">in </span><span class="s1">headers:</span>
            <span class="s1">newurl = headers.getheaders(</span><span class="s4">'location'</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">elif </span><span class="s4">'uri' </span><span class="s3">in </span><span class="s1">headers:</span>
            <span class="s1">newurl = headers.getheaders(</span><span class="s4">'uri'</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return</span>
        <span class="s1">newurl = _rfc3986.clean_url(newurl)</span>
        <span class="s1">newurl = _rfc3986.urljoin(req.get_full_url()</span><span class="s3">, </span><span class="s1">newurl)</span>

        <span class="s2"># XXX Probably want to forget about the state of the current</span>
        <span class="s2"># request, although that might interact poorly with other</span>
        <span class="s2"># handlers that also use handler-specific request attributes</span>
        <span class="s1">new = self.redirect_request(req</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">newurl)</span>
        <span class="s3">if </span><span class="s1">new </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return</span>

        <span class="s2"># loop detection</span>
        <span class="s2"># .redirect_dict has a key url if url was previously visited.</span>
        <span class="s3">if </span><span class="s1">hasattr(req</span><span class="s3">, </span><span class="s4">'redirect_dict'</span><span class="s1">):</span>
            <span class="s1">visited = new.redirect_dict = req.redirect_dict</span>
            <span class="s3">if </span><span class="s1">(visited.get(newurl</span><span class="s3">, </span><span class="s5">0</span><span class="s1">) &gt;= self.max_repeats </span><span class="s3">or</span>
                    <span class="s1">len(visited) &gt;= self.max_redirections):</span>
                <span class="s3">raise </span><span class="s1">HTTPError(req.get_full_url()</span><span class="s3">, </span><span class="s1">code</span><span class="s3">,</span>
                                <span class="s1">self.inf_msg + msg</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">fp)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">visited = new.redirect_dict = req.redirect_dict = {}</span>
        <span class="s1">visited[newurl] = visited.get(newurl</span><span class="s3">, </span><span class="s5">0</span><span class="s1">) + </span><span class="s5">1</span>

        <span class="s2"># Don't close the fp until we are sure that we won't use it</span>
        <span class="s2"># with HTTPError.</span>
        <span class="s1">fp.read()</span>
        <span class="s1">fp.close()</span>

        <span class="s3">return </span><span class="s1">self.parent.open(new)</span>

    <span class="s1">http_error_301 = http_error_303 = http_error_307 = http_error_302</span>
    <span class="s1">http_error_refresh = http_error_302</span>

    <span class="s1">inf_msg = </span><span class="s4">&quot;The HTTP server returned a redirect error that would &quot; </span><span class="s1">\</span>
              <span class="s4">&quot;lead to an infinite loop.</span><span class="s3">\n</span><span class="s4">&quot; </span><span class="s1">\</span>
              <span class="s4">&quot;The last 30x error message was:</span><span class="s3">\n</span><span class="s4">&quot;</span>


<span class="s3">def </span><span class="s1">_parse_proxy(proxy):</span>
    <span class="s0">&quot;&quot;&quot;Return (scheme, user, password, host/port) given a URL or an authority. 
 
    If a URL is supplied, it must have an authority (host:port) component. 
    According to RFC 3986, having an authority component means the URL must 
    have two slashes after the scheme: 
 
    &gt;&gt;&gt; _parse_proxy('file:/ftp.example.com/') 
    Traceback (most recent call last): 
    ValueError: proxy URL with no authority: 'file:/ftp.example.com/' 
 
    The first three items of the returned tuple may be None. 
 
    Examples of authority parsing: 
 
    &gt;&gt;&gt; _parse_proxy('proxy.example.com') 
    (None, None, None, 'proxy.example.com') 
    &gt;&gt;&gt; _parse_proxy('proxy.example.com:3128') 
    (None, None, None, 'proxy.example.com:3128') 
 
    The authority component may optionally include userinfo (assumed to be 
    username:password): 
 
    &gt;&gt;&gt; _parse_proxy('joe:password@proxy.example.com') 
    (None, 'joe', 'password', 'proxy.example.com') 
    &gt;&gt;&gt; _parse_proxy('joe:password@proxy.example.com:3128') 
    (None, 'joe', 'password', 'proxy.example.com:3128') 
 
    Same examples, but with URLs instead: 
 
    &gt;&gt;&gt; _parse_proxy('http://proxy.example.com/') 
    ('http', None, None, 'proxy.example.com') 
    &gt;&gt;&gt; _parse_proxy('http://proxy.example.com:3128/') 
    ('http', None, None, 'proxy.example.com:3128') 
    &gt;&gt;&gt; _parse_proxy('http://joe:password@proxy.example.com/') 
    ('http', 'joe', 'password', 'proxy.example.com') 
    &gt;&gt;&gt; _parse_proxy('http://joe:password@proxy.example.com:3128') 
    ('http', 'joe', 'password', 'proxy.example.com:3128') 
 
    Everything after the authority is ignored: 
 
    &gt;&gt;&gt; _parse_proxy('ftp://joe:password@proxy.example.com/rubbish:3128') 
    ('ftp', 'joe', 'password', 'proxy.example.com') 
 
    Test for no trailing '/' case: 
 
    &gt;&gt;&gt; _parse_proxy('http://joe:password@proxy.example.com') 
    ('http', 'joe', 'password', 'proxy.example.com') 
 
    &quot;&quot;&quot;</span>
    <span class="s1">scheme</span><span class="s3">, </span><span class="s1">r_scheme = splittype(proxy)</span>
    <span class="s3">if not </span><span class="s1">r_scheme.startswith(</span><span class="s4">&quot;/&quot;</span><span class="s1">):</span>
        <span class="s2"># authority</span>
        <span class="s1">scheme = </span><span class="s3">None</span>
        <span class="s1">authority = proxy</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s2"># URL</span>
        <span class="s3">if not </span><span class="s1">r_scheme.startswith(</span><span class="s4">&quot;//&quot;</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;proxy URL with no authority: %r&quot; </span><span class="s1">% proxy)</span>
        <span class="s2"># We have an authority, so for RFC 3986-compliant URLs (by ss 3.</span>
        <span class="s2"># and 3.3.), path is empty or starts with '/'</span>
        <span class="s1">end = r_scheme.find(</span><span class="s4">&quot;/&quot;</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">end == -</span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">end = </span><span class="s3">None</span>
        <span class="s1">authority = r_scheme[</span><span class="s5">2</span><span class="s1">:end]</span>
    <span class="s1">userinfo</span><span class="s3">, </span><span class="s1">hostport = splituser(authority)</span>
    <span class="s3">if </span><span class="s1">userinfo </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">user</span><span class="s3">, </span><span class="s1">password = splitpasswd(userinfo)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">user = password = </span><span class="s3">None</span>
    <span class="s3">return </span><span class="s1">scheme</span><span class="s3">, </span><span class="s1">user</span><span class="s3">, </span><span class="s1">password</span><span class="s3">, </span><span class="s1">hostport</span>


<span class="s3">class </span><span class="s1">ProxyHandler(BaseHandler):</span>
    <span class="s2"># Proxies must be in front</span>
    <span class="s1">handler_order = </span><span class="s5">100</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">proxies=</span><span class="s3">None, </span><span class="s1">proxy_bypass=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">proxies </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">proxies = getproxies()</span>

        <span class="s3">assert </span><span class="s1">is_mapping(proxies)</span><span class="s3">, </span><span class="s4">&quot;proxies must be a mapping&quot;</span>
        <span class="s1">self.proxies = proxies</span>
        <span class="s3">for </span><span class="s1">type</span><span class="s3">, </span><span class="s1">url </span><span class="s3">in </span><span class="s1">iteritems(proxies):</span>
            <span class="s1">setattr(self</span><span class="s3">, </span><span class="s4">'%s_open' </span><span class="s1">% type</span><span class="s3">,</span>
                    <span class="s3">lambda </span><span class="s1">r</span><span class="s3">, </span><span class="s1">proxy=url</span><span class="s3">, </span><span class="s1">type=type</span><span class="s3">, </span><span class="s1">meth=self.proxy_open:</span>
                    <span class="s1">meth(r</span><span class="s3">, </span><span class="s1">proxy</span><span class="s3">, </span><span class="s1">type))</span>
        <span class="s3">if </span><span class="s1">proxy_bypass </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">proxy_bypass = urllib_proxy_bypass</span>
        <span class="s1">self._proxy_bypass = proxy_bypass</span>

    <span class="s3">def </span><span class="s1">proxy_open(self</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">proxy</span><span class="s3">, </span><span class="s1">type):</span>
        <span class="s1">orig_type = req.get_type()</span>
        <span class="s1">proxy_type</span><span class="s3">, </span><span class="s1">user</span><span class="s3">, </span><span class="s1">password</span><span class="s3">, </span><span class="s1">hostport = _parse_proxy(proxy)</span>

        <span class="s3">if </span><span class="s1">proxy_type </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">proxy_type = orig_type</span>

        <span class="s3">if </span><span class="s1">req.get_host() </span><span class="s3">and </span><span class="s1">self._proxy_bypass(req.get_host()):</span>
            <span class="s3">return None</span>

        <span class="s3">if </span><span class="s1">user </span><span class="s3">and </span><span class="s1">password:</span>
            <span class="s1">user_pass = </span><span class="s4">'%s:%s' </span><span class="s1">% (unquote(user)</span><span class="s3">, </span><span class="s1">unquote(password))</span>
            <span class="s3">if not </span><span class="s1">isinstance(user_pass</span><span class="s3">, </span><span class="s1">bytes):</span>
                <span class="s1">user_pass = user_pass.encode(</span><span class="s4">'utf-8'</span><span class="s1">)</span>
            <span class="s1">creds = base64.b64encode(user_pass).strip()</span>
            <span class="s3">if </span><span class="s1">isinstance(creds</span><span class="s3">, </span><span class="s1">bytes):</span>
                <span class="s1">creds = creds.decode(</span><span class="s4">'ascii'</span><span class="s1">)</span>
            <span class="s1">req.add_header(</span><span class="s4">'Proxy-authorization'</span><span class="s3">, </span><span class="s4">'Basic ' </span><span class="s1">+ creds)</span>
        <span class="s1">hostport = unquote(hostport)</span>
        <span class="s1">req.set_proxy(hostport</span><span class="s3">, </span><span class="s1">proxy_type)</span>
        <span class="s3">if </span><span class="s1">orig_type == proxy_type </span><span class="s3">or </span><span class="s1">orig_type == </span><span class="s4">'https'</span><span class="s1">:</span>
            <span class="s2"># let other handlers take care of it</span>
            <span class="s3">return None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># need to start over, because the other handlers don't</span>
            <span class="s2"># grok the proxy's URL type</span>
            <span class="s2"># e.g. if we have a constructor arg proxies like so:</span>
            <span class="s2"># {'http': 'ftp://proxy.example.com'}, we may end up turning</span>
            <span class="s2"># a request for http://acme.example.com/a into one for</span>
            <span class="s2"># ftp://proxy.example.com/a</span>
            <span class="s3">return </span><span class="s1">self.parent.open(req)</span>

    <span class="s3">def </span><span class="s1">__copy__(self):</span>
        <span class="s3">return </span><span class="s1">ProxyHandler(self.proxies.copy()</span><span class="s3">, </span><span class="s1">self._proxy_bypass)</span>


<span class="s3">class </span><span class="s1">HTTPPasswordMgr:</span>

    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.passwd = {}</span>

    <span class="s3">def </span><span class="s1">add_password(self</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">, </span><span class="s1">uri</span><span class="s3">, </span><span class="s1">user</span><span class="s3">, </span><span class="s1">passwd):</span>
        <span class="s2"># uri could be a single URI or a sequence</span>
        <span class="s3">if </span><span class="s1">is_string(uri):</span>
            <span class="s1">uri = [uri]</span>
        <span class="s3">if </span><span class="s1">realm </span><span class="s3">not in </span><span class="s1">self.passwd:</span>
            <span class="s1">self.passwd[realm] = {}</span>
        <span class="s3">for </span><span class="s1">default_port </span><span class="s3">in True, False</span><span class="s1">:</span>
            <span class="s1">reduced_uri = tuple(</span>
                <span class="s1">[self.reduce_uri(u</span><span class="s3">, </span><span class="s1">default_port) </span><span class="s3">for </span><span class="s1">u </span><span class="s3">in </span><span class="s1">uri])</span>
            <span class="s1">self.passwd[realm][reduced_uri] = (user</span><span class="s3">, </span><span class="s1">passwd)</span>

    <span class="s3">def </span><span class="s1">find_user_password(self</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">, </span><span class="s1">authuri):</span>
        <span class="s1">domains = self.passwd.get(realm</span><span class="s3">, </span><span class="s1">{})</span>
        <span class="s3">for </span><span class="s1">default_port </span><span class="s3">in True, False</span><span class="s1">:</span>
            <span class="s1">reduced_authuri = self.reduce_uri(authuri</span><span class="s3">, </span><span class="s1">default_port)</span>
            <span class="s3">for </span><span class="s1">uris</span><span class="s3">, </span><span class="s1">authinfo </span><span class="s3">in </span><span class="s1">iteritems(domains):</span>
                <span class="s3">for </span><span class="s1">uri </span><span class="s3">in </span><span class="s1">uris:</span>
                    <span class="s3">if </span><span class="s1">self.is_suburi(uri</span><span class="s3">, </span><span class="s1">reduced_authuri):</span>
                        <span class="s3">return </span><span class="s1">authinfo</span>
        <span class="s3">return None, None</span>

    <span class="s3">def </span><span class="s1">reduce_uri(self</span><span class="s3">, </span><span class="s1">uri</span><span class="s3">, </span><span class="s1">default_port=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Accept authority or URI and extract only the authority and path.&quot;&quot;&quot;</span>
        <span class="s2"># note HTTP URLs do not have a userinfo component</span>
        <span class="s1">parts = urlsplit(uri)</span>
        <span class="s3">if </span><span class="s1">parts[</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s2"># URI</span>
            <span class="s1">scheme = parts[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">authority = parts[</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">path = parts[</span><span class="s5">2</span><span class="s1">] </span><span class="s3">or </span><span class="s4">'/'</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># host or host:port</span>
            <span class="s1">scheme = </span><span class="s3">None</span>
            <span class="s1">authority = uri</span>
            <span class="s1">path = </span><span class="s4">'/'</span>
        <span class="s1">host</span><span class="s3">, </span><span class="s1">port = splitport(authority)</span>
        <span class="s3">if </span><span class="s1">default_port </span><span class="s3">and </span><span class="s1">port </span><span class="s3">is None and </span><span class="s1">scheme </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">dport = {</span><span class="s4">&quot;http&quot;</span><span class="s1">: </span><span class="s5">80</span><span class="s3">,</span>
                     <span class="s4">&quot;https&quot;</span><span class="s1">: </span><span class="s5">443</span><span class="s3">,</span>
                     <span class="s1">}.get(scheme)</span>
            <span class="s3">if </span><span class="s1">dport </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">authority = </span><span class="s4">&quot;%s:%d&quot; </span><span class="s1">% (host</span><span class="s3">, </span><span class="s1">dport)</span>
        <span class="s3">return </span><span class="s1">authority</span><span class="s3">, </span><span class="s1">path</span>

    <span class="s3">def </span><span class="s1">is_suburi(self</span><span class="s3">, </span><span class="s1">base</span><span class="s3">, </span><span class="s1">test):</span>
        <span class="s0">&quot;&quot;&quot;Check if test is below base in a URI tree 
 
        Both args must be URIs in reduced form. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">base == test:</span>
            <span class="s3">return True</span>
        <span class="s3">if </span><span class="s1">base[</span><span class="s5">0</span><span class="s1">] != test[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s3">return False</span>
        <span class="s1">common = posixpath.commonprefix((base[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">test[</span><span class="s5">1</span><span class="s1">]))</span>
        <span class="s3">if </span><span class="s1">len(common) == len(base[</span><span class="s5">1</span><span class="s1">]):</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">__copy__(self):</span>
        <span class="s1">ans = self.__class__()</span>
        <span class="s1">ans.passwd = copy.deepcopy(self.passwd)</span>
        <span class="s3">return </span><span class="s1">ans</span>


<span class="s3">class </span><span class="s1">HTTPPasswordMgrWithDefaultRealm(HTTPPasswordMgr):</span>

    <span class="s3">def </span><span class="s1">find_user_password(self</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">, </span><span class="s1">authuri):</span>
        <span class="s1">user</span><span class="s3">, </span><span class="s1">password = HTTPPasswordMgr.find_user_password(self</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">,</span>
                                                            <span class="s1">authuri)</span>
        <span class="s3">if </span><span class="s1">user </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">user</span><span class="s3">, </span><span class="s1">password</span>
        <span class="s3">return </span><span class="s1">HTTPPasswordMgr.find_user_password(self</span><span class="s3">, None, </span><span class="s1">authuri)</span>


<span class="s3">class </span><span class="s1">AbstractBasicAuthHandler:</span>

    <span class="s2"># XXX this allows for multiple auth-schemes, but will stupidly pick</span>
    <span class="s2"># the last one with a realm specified.</span>

    <span class="s2"># allow for double- and single-quoted realm values</span>
    <span class="s2"># (single quotes are a violation of the RFC, but appear in the wild)</span>
    <span class="s1">rx = re.compile(</span><span class="s4">'(?:.*,)*[ </span><span class="s3">\t</span><span class="s4">]*([^ </span><span class="s3">\t</span><span class="s4">]+)[ </span><span class="s3">\t</span><span class="s4">]+'</span>
                    <span class="s4">'realm=([&quot;</span><span class="s3">\'</span><span class="s4">])(.*?)</span><span class="s3">\\</span><span class="s4">2'</span><span class="s3">, </span><span class="s1">re.I)</span>

    <span class="s2"># XXX could pre-emptively send auth info already accepted (RFC 2617,</span>
    <span class="s2"># end of section 2, and section 1.2 immediately after &quot;credentials&quot;</span>
    <span class="s2"># production).</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">password_mgr=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">password_mgr </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">password_mgr = HTTPPasswordMgr()</span>
        <span class="s1">self.passwd = password_mgr</span>
        <span class="s1">self.add_password = self.passwd.add_password</span>

    <span class="s3">def </span><span class="s1">http_error_auth_reqed(self</span><span class="s3">, </span><span class="s1">authreq</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">headers):</span>
        <span class="s2"># host may be an authority (without userinfo) or a URL with an</span>
        <span class="s2"># authority</span>
        <span class="s2"># XXX could be multiple headers</span>
        <span class="s1">authreq = headers.get(authreq</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">authreq:</span>
            <span class="s1">mo = AbstractBasicAuthHandler.rx.search(authreq)</span>
            <span class="s3">if </span><span class="s1">mo:</span>
                <span class="s1">scheme</span><span class="s3">, </span><span class="s1">quote</span><span class="s3">, </span><span class="s1">realm = mo.groups()</span>
                <span class="s3">if </span><span class="s1">scheme.lower() == </span><span class="s4">'basic'</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">self.retry_http_basic_auth(host</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">realm)</span>

    <span class="s3">def </span><span class="s1">retry_http_basic_auth(self</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">realm):</span>
        <span class="s1">user</span><span class="s3">, </span><span class="s1">pw = self.passwd.find_user_password(realm</span><span class="s3">, </span><span class="s1">host)</span>
        <span class="s3">if </span><span class="s1">pw </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">raw = </span><span class="s4">&quot;%s:%s&quot; </span><span class="s1">% (user</span><span class="s3">, </span><span class="s1">pw)</span>
            <span class="s1">auth = str(</span><span class="s4">'Basic %s' </span><span class="s1">% base64.b64encode(</span>
                    <span class="s1">raw.encode(</span><span class="s4">'utf-8'</span><span class="s1">)).strip().decode(</span><span class="s4">'ascii'</span><span class="s1">))</span>
            <span class="s3">if </span><span class="s1">req.get_header(self.auth_header</span><span class="s3">, None</span><span class="s1">) == auth:</span>
                <span class="s3">return None</span>
            <span class="s1">newreq = copy.copy(req)</span>
            <span class="s1">newreq.add_header(self.auth_header</span><span class="s3">, </span><span class="s1">auth)</span>
            <span class="s1">newreq.visit = </span><span class="s3">False</span>
            <span class="s3">return </span><span class="s1">self.parent.open(newreq)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">__copy__(self):</span>
        <span class="s3">return </span><span class="s1">self.__class__(self.passwd.__copy__())</span>


<span class="s3">class </span><span class="s1">HTTPBasicAuthHandler(AbstractBasicAuthHandler</span><span class="s3">, </span><span class="s1">BaseHandler):</span>

    <span class="s1">auth_header = </span><span class="s4">'Authorization'</span>

    <span class="s3">def </span><span class="s1">http_error_401(self</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">headers):</span>
        <span class="s1">url = req.get_full_url()</span>
        <span class="s3">return </span><span class="s1">self.http_error_auth_reqed(</span><span class="s4">'www-authenticate'</span><span class="s3">,</span>
                                          <span class="s1">url</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">headers)</span>

    <span class="s3">def </span><span class="s1">__copy__(self):</span>
        <span class="s3">return </span><span class="s1">AbstractBasicAuthHandler.__copy__(self)</span>


<span class="s3">class </span><span class="s1">ProxyBasicAuthHandler(AbstractBasicAuthHandler</span><span class="s3">, </span><span class="s1">BaseHandler):</span>

    <span class="s1">auth_header = </span><span class="s4">'Proxy-authorization'</span>

    <span class="s3">def </span><span class="s1">http_error_407(self</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">headers):</span>
        <span class="s2"># http_error_auth_reqed requires that there is no userinfo component in</span>
        <span class="s2"># authority.  Assume there isn't one, since urllib2 does not (and</span>
        <span class="s2"># should not, RFC 3986 s. 3.2.1) support requests for URLs containing</span>
        <span class="s2"># userinfo.</span>
        <span class="s1">authority = req.get_host()</span>
        <span class="s3">return </span><span class="s1">self.http_error_auth_reqed(</span><span class="s4">'proxy-authenticate'</span><span class="s3">,</span>
                                          <span class="s1">authority</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">headers)</span>

    <span class="s3">def </span><span class="s1">__copy__(self):</span>
        <span class="s3">return </span><span class="s1">AbstractBasicAuthHandler.__copy__(self)</span>


<span class="s1">randombytes = os.urandom</span>


<span class="s3">class </span><span class="s1">AbstractDigestAuthHandler:</span>
    <span class="s2"># Digest authentication is specified in RFC 2617.</span>

    <span class="s2"># XXX The client does not inspect the Authentication-Info header</span>
    <span class="s2"># in a successful response.</span>

    <span class="s2"># XXX It should be possible to test this implementation against</span>
    <span class="s2"># a mock server that just generates a static set of challenges.</span>

    <span class="s2"># XXX qop=&quot;auth-int&quot; supports is shaky</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">passwd=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">passwd </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">passwd = HTTPPasswordMgr()</span>
        <span class="s1">self.passwd = passwd</span>
        <span class="s1">self.add_password = self.passwd.add_password</span>
        <span class="s1">self.retried = </span><span class="s5">0</span>
        <span class="s1">self.nonce_count = </span><span class="s5">0</span>
        <span class="s1">self.last_nonce = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">reset_retry_count(self):</span>
        <span class="s1">self.retried = </span><span class="s5">0</span>

    <span class="s3">def </span><span class="s1">http_error_auth_reqed(self</span><span class="s3">, </span><span class="s1">auth_header</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">headers):</span>
        <span class="s1">authreq = headers.get(auth_header</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">self.retried &gt; </span><span class="s5">5</span><span class="s1">:</span>
            <span class="s2"># Don't fail endlessly - if we failed once, we'll probably</span>
            <span class="s2"># fail a second time. Hm. Unless the Password Manager is</span>
            <span class="s2"># prompting for the information. Crap. This isn't great</span>
            <span class="s2"># but it's better than the current 'repeat until recursion</span>
            <span class="s2"># depth exceeded' approach &lt;wink&gt;</span>
            <span class="s3">raise </span><span class="s1">HTTPError(req.get_full_url()</span><span class="s3">, </span><span class="s5">401</span><span class="s3">, </span><span class="s4">&quot;digest auth failed&quot;</span><span class="s3">,</span>
                            <span class="s1">headers</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.retried += </span><span class="s5">1</span>
        <span class="s3">if </span><span class="s1">authreq:</span>
            <span class="s1">scheme = authreq.split()[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">scheme.lower() == </span><span class="s4">'digest'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self.retry_http_digest_auth(req</span><span class="s3">, </span><span class="s1">authreq)</span>

    <span class="s3">def </span><span class="s1">retry_http_digest_auth(self</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">auth):</span>
        <span class="s1">token</span><span class="s3">, </span><span class="s1">challenge = auth.split(</span><span class="s4">' '</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">chal = parse_keqv_list(parse_http_list(challenge))</span>
        <span class="s1">auth = self.get_authorization(req</span><span class="s3">, </span><span class="s1">chal)</span>
        <span class="s3">if </span><span class="s1">auth:</span>
            <span class="s1">auth_val = </span><span class="s4">'Digest %s' </span><span class="s1">% auth</span>
            <span class="s3">if </span><span class="s1">req.get_header(self.auth_header</span><span class="s3">, None</span><span class="s1">) == auth_val:</span>
                <span class="s3">return None</span>
            <span class="s1">newreq = copy.copy(req)</span>
            <span class="s1">newreq.add_unredirected_header(self.auth_header</span><span class="s3">, </span><span class="s1">auth_val)</span>
            <span class="s1">newreq.visit = </span><span class="s3">False</span>
            <span class="s3">return </span><span class="s1">self.parent.open(newreq)</span>

    <span class="s3">def </span><span class="s1">get_cnonce(self</span><span class="s3">, </span><span class="s1">nonce):</span>
        <span class="s2"># The cnonce-value is an opaque</span>
        <span class="s2"># quoted string value provided by the client and used by both client</span>
        <span class="s2"># and server to avoid chosen plaintext attacks, to provide mutual</span>
        <span class="s2"># authentication, and to provide some message integrity protection.</span>
        <span class="s2"># This isn't a fabulous effort, but it's probably Good Enough.</span>
        <span class="s1">dig = sha1_digest(</span><span class="s4">&quot;%s:%s:%s:%s&quot; </span><span class="s1">% (self.nonce_count</span><span class="s3">, </span><span class="s1">nonce</span><span class="s3">,</span>
                                           <span class="s1">time.ctime()</span><span class="s3">, </span><span class="s1">randombytes(</span><span class="s5">8</span><span class="s1">)))</span>
        <span class="s3">return </span><span class="s1">dig[:</span><span class="s5">16</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">get_authorization(self</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">chal):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">realm = chal[</span><span class="s4">'realm'</span><span class="s1">]</span>
            <span class="s1">nonce = chal[</span><span class="s4">'nonce'</span><span class="s1">]</span>
            <span class="s1">qop = chal.get(</span><span class="s4">'qop'</span><span class="s1">)</span>
            <span class="s1">algorithm = chal.get(</span><span class="s4">'algorithm'</span><span class="s3">, </span><span class="s4">'MD5'</span><span class="s1">)</span>
            <span class="s2"># mod_digest doesn't send an opaque, even though it isn't</span>
            <span class="s2"># supposed to be optional</span>
            <span class="s1">opaque = chal.get(</span><span class="s4">'opaque'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s3">return None</span>

        <span class="s1">H</span><span class="s3">, </span><span class="s1">KD = self.get_algorithm_impls(algorithm)</span>
        <span class="s3">if </span><span class="s1">H </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return None</span>

        <span class="s1">user</span><span class="s3">, </span><span class="s1">pw = self.passwd.find_user_password(realm</span><span class="s3">, </span><span class="s1">req.get_full_url())</span>
        <span class="s3">if </span><span class="s1">user </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return None</span>

        <span class="s2"># XXX not implemented yet</span>
        <span class="s3">if </span><span class="s1">req.has_data():</span>
            <span class="s1">entdig = self.get_entity_digest(req.get_data()</span><span class="s3">, </span><span class="s1">chal)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">entdig = </span><span class="s3">None</span>

        <span class="s1">A1 = </span><span class="s4">&quot;%s:%s:%s&quot; </span><span class="s1">% (user</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">, </span><span class="s1">pw)</span>
        <span class="s1">A2 = </span><span class="s4">&quot;%s:%s&quot; </span><span class="s1">% (req.get_method()</span><span class="s3">,</span>
                        <span class="s2"># XXX selector: what about proxies and full urls</span>
                        <span class="s1">req.get_selector())</span>
        <span class="s3">if </span><span class="s1">qop == </span><span class="s4">'auth'</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">nonce == self.last_nonce:</span>
                <span class="s1">self.nonce_count += </span><span class="s5">1</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.nonce_count = </span><span class="s5">1</span>
                <span class="s1">self.last_nonce = nonce</span>

            <span class="s1">ncvalue = </span><span class="s4">'%08x' </span><span class="s1">% self.nonce_count</span>
            <span class="s1">cnonce = self.get_cnonce(nonce)</span>
            <span class="s1">noncebit = </span><span class="s4">&quot;%s:%s:%s:%s:%s&quot; </span><span class="s1">% (nonce</span><span class="s3">, </span><span class="s1">ncvalue</span><span class="s3">, </span><span class="s1">cnonce</span><span class="s3">, </span><span class="s1">qop</span><span class="s3">, </span><span class="s1">H(A2))</span>
            <span class="s1">respdig = KD(H(A1)</span><span class="s3">, </span><span class="s1">noncebit)</span>
        <span class="s3">elif </span><span class="s1">qop </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">respdig = KD(H(A1)</span><span class="s3">, </span><span class="s4">&quot;%s:%s&quot; </span><span class="s1">% (nonce</span><span class="s3">, </span><span class="s1">H(A2)))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># XXX handle auth-int.</span>
            <span class="s1">logger = logging.getLogger(</span><span class="s4">&quot;mechanize.auth&quot;</span><span class="s1">)</span>
            <span class="s1">logger.info(</span><span class="s4">&quot;digest auth auth-int qop is not supported, not &quot;</span>
                        <span class="s4">&quot;handling digest authentication&quot;</span><span class="s1">)</span>
            <span class="s3">return None</span>

        <span class="s2"># XXX should the partial digests be encoded too?</span>

        <span class="s1">base = </span><span class="s4">'username=&quot;%s&quot;, realm=&quot;%s&quot;, nonce=&quot;%s&quot;, uri=&quot;%s&quot;, ' </span><span class="s1">\</span>
               <span class="s4">'response=&quot;%s&quot;' </span><span class="s1">% (user</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">, </span><span class="s1">nonce</span><span class="s3">, </span><span class="s1">req.get_selector()</span><span class="s3">,</span>
                                  <span class="s1">respdig)</span>
        <span class="s3">if </span><span class="s1">opaque:</span>
            <span class="s1">base += </span><span class="s4">', opaque=&quot;%s&quot;' </span><span class="s1">% opaque</span>
        <span class="s3">if </span><span class="s1">entdig:</span>
            <span class="s1">base += </span><span class="s4">', digest=&quot;%s&quot;' </span><span class="s1">% entdig</span>
        <span class="s1">base += </span><span class="s4">', algorithm=&quot;%s&quot;' </span><span class="s1">% algorithm</span>
        <span class="s3">if </span><span class="s1">qop:</span>
            <span class="s1">base += </span><span class="s4">', qop=auth, nc=%s, cnonce=&quot;%s&quot;' </span><span class="s1">% (ncvalue</span><span class="s3">, </span><span class="s1">cnonce)</span>
        <span class="s3">return </span><span class="s1">base</span>

    <span class="s3">def </span><span class="s1">get_algorithm_impls(self</span><span class="s3">, </span><span class="s1">algorithm):</span>
        <span class="s2"># algorithm should be case-insensitive according to RFC2617</span>
        <span class="s1">algorithm = algorithm.upper()</span>
        <span class="s3">if </span><span class="s1">algorithm == </span><span class="s4">'MD5'</span><span class="s1">:</span>
            <span class="s1">H = md5_digest</span>
        <span class="s3">elif </span><span class="s1">algorithm == </span><span class="s4">'SHA'</span><span class="s1">:</span>
            <span class="s1">H = sha1_digest</span>
        <span class="s2"># XXX MD5-sess</span>
        <span class="s1">KD = </span><span class="s3">lambda </span><span class="s1">s</span><span class="s3">, </span><span class="s1">d: H(</span><span class="s4">&quot;%s:%s&quot; </span><span class="s1">% (s</span><span class="s3">, </span><span class="s1">d))  </span><span class="s2"># noqa</span>
        <span class="s3">return </span><span class="s1">H</span><span class="s3">, </span><span class="s1">KD</span>

    <span class="s3">def </span><span class="s1">get_entity_digest(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">chal):</span>
        <span class="s2"># XXX not implemented yet</span>
        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">__copy__(self):</span>
        <span class="s3">return </span><span class="s1">self.__class__(self.passwd.__copy__())</span>


<span class="s3">class </span><span class="s1">HTTPDigestAuthHandler(BaseHandler</span><span class="s3">, </span><span class="s1">AbstractDigestAuthHandler):</span>
    <span class="s0">&quot;&quot;&quot;An authentication protocol defined by RFC 2069 
 
    Digest authentication improves on basic authentication because it 
    does not transmit passwords in the clear. 
    &quot;&quot;&quot;</span>

    <span class="s1">auth_header = </span><span class="s4">'Authorization'</span>
    <span class="s1">handler_order = </span><span class="s5">490  </span><span class="s2"># before Basic auth</span>

    <span class="s3">def </span><span class="s1">http_error_401(self</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">headers):</span>
        <span class="s1">host = urlparse(req.get_full_url())[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">retry = self.http_error_auth_reqed(</span><span class="s4">'www-authenticate'</span><span class="s3">,</span>
                                           <span class="s1">host</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">headers)</span>
        <span class="s1">self.reset_retry_count()</span>
        <span class="s3">return </span><span class="s1">retry</span>

    <span class="s3">def </span><span class="s1">__copy__(self):</span>
        <span class="s3">return </span><span class="s1">AbstractDigestAuthHandler.__copy__(self)</span>


<span class="s3">class </span><span class="s1">ProxyDigestAuthHandler(BaseHandler</span><span class="s3">, </span><span class="s1">AbstractDigestAuthHandler):</span>

    <span class="s1">auth_header = </span><span class="s4">'Proxy-Authorization'</span>
    <span class="s1">handler_order = </span><span class="s5">490  </span><span class="s2"># before Basic auth</span>

    <span class="s3">def </span><span class="s1">http_error_407(self</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">headers):</span>
        <span class="s1">host = req.get_host()</span>
        <span class="s1">retry = self.http_error_auth_reqed(</span><span class="s4">'proxy-authenticate'</span><span class="s3">,</span>
                                           <span class="s1">host</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">headers)</span>
        <span class="s1">self.reset_retry_count()</span>
        <span class="s3">return </span><span class="s1">retry</span>

    <span class="s3">def </span><span class="s1">__copy__(self):</span>
        <span class="s3">return </span><span class="s1">AbstractDigestAuthHandler.__copy__(self)</span>


<span class="s3">class </span><span class="s1">AbstractHTTPHandler(BaseHandler):</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">debuglevel=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">self._debuglevel = debuglevel</span>

    <span class="s3">def </span><span class="s1">set_http_debuglevel(self</span><span class="s3">, </span><span class="s1">level):</span>
        <span class="s1">self._debuglevel = level</span>

    <span class="s3">def </span><span class="s1">do_request_(self</span><span class="s3">, </span><span class="s1">request):</span>
        <span class="s1">host = request.get_host()</span>
        <span class="s3">if not </span><span class="s1">host:</span>
            <span class="s3">raise </span><span class="s1">URLError(</span><span class="s4">'no host given'</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">request.has_data():  </span><span class="s2"># POST</span>
            <span class="s1">data = request.get_data()</span>
            <span class="s3">if not </span><span class="s1">request.has_header(</span><span class="s4">'Content-type'</span><span class="s1">):</span>
                <span class="s1">request.add_unredirected_header(</span>
                    <span class="s4">'Content-type'</span><span class="s3">,</span>
                    <span class="s4">'application/x-www-form-urlencoded'</span><span class="s1">)</span>
            <span class="s3">if not </span><span class="s1">request.has_header(</span><span class="s4">'Content-length'</span><span class="s1">):</span>
                <span class="s1">request.add_unredirected_header(</span>
                    <span class="s4">'Content-length'</span><span class="s3">, </span><span class="s4">'%d' </span><span class="s1">% len(data))</span>

        <span class="s1">sel_host = host</span>
        <span class="s3">if </span><span class="s1">request.has_proxy():</span>
            <span class="s1">scheme</span><span class="s3">, </span><span class="s1">sel = splittype(request.get_selector())</span>
            <span class="s1">sel_host</span><span class="s3">, </span><span class="s1">sel_path = splithost(sel)</span>

        <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">self.parent.addheaders:</span>
            <span class="s1">name = name.capitalize()</span>
            <span class="s3">if not </span><span class="s1">request.has_header(name):</span>
                <span class="s1">request.add_unredirected_header(name</span><span class="s3">, </span><span class="s1">value)</span>
        <span class="s3">if not </span><span class="s1">request.has_header(</span><span class="s4">'Host'</span><span class="s1">):</span>
            <span class="s1">request.add_unredirected_header(</span><span class="s4">'Host'</span><span class="s3">, </span><span class="s1">sel_host)</span>

        <span class="s3">return </span><span class="s1">request</span>

    <span class="s3">def </span><span class="s1">do_open(self</span><span class="s3">, </span><span class="s1">http_class</span><span class="s3">, </span><span class="s1">req):</span>
        <span class="s0">&quot;&quot;&quot;Return an addinfourl object for the request, using http_class. 
 
        http_class must implement the HTTPConnection API from httplib. 
        The addinfourl return value is a file-like object.  It also 
        has methods and attributes including: 
            - info(): return a HTTPMessage object for the headers 
            - geturl(): return the original request URL 
            - code: HTTP status code 
        &quot;&quot;&quot;</span>
        <span class="s1">host_port = req.get_host()</span>
        <span class="s3">if not </span><span class="s1">host_port:</span>
            <span class="s3">raise </span><span class="s1">URLError(</span><span class="s4">'no host given'</span><span class="s1">)</span>

        <span class="s1">h = http_class(host_port</span><span class="s3">, </span><span class="s1">timeout=req.timeout)</span>
        <span class="s1">h.set_debuglevel(self._debuglevel)</span>

        <span class="s1">headers = OrderedDict(req.headers)</span>
        <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">val </span><span class="s3">in </span><span class="s1">iteritems(req.unredirected_hdrs):</span>
            <span class="s1">headers[key] = val</span>
        <span class="s2"># We want to make an HTTP/1.1 request, but the addinfourl</span>
        <span class="s2"># class isn't prepared to deal with a persistent connection.</span>
        <span class="s2"># It will try to read all remaining data from the socket,</span>
        <span class="s2"># which will block while the server waits for the next request.</span>
        <span class="s2"># So make sure the connection gets closed after the (only)</span>
        <span class="s2"># request.</span>
        <span class="s1">headers[</span><span class="s4">&quot;Connection&quot;</span><span class="s1">] = </span><span class="s4">&quot;close&quot;</span>
        <span class="s2"># httplib in python 2 needs str() not unicode() for all request</span>
        <span class="s2"># parameters</span>
        <span class="s3">if </span><span class="s1">is_py2:</span>
            <span class="s1">headers = OrderedDict(</span>
                    <span class="s1">(str(name.title())</span><span class="s3">, </span><span class="s1">str(val))</span>
                    <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">val </span><span class="s3">in </span><span class="s1">iteritems(headers))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">headers = OrderedDict(</span>
                    <span class="s1">(as_unicode(name</span><span class="s3">, </span><span class="s4">'iso-8859-1'</span><span class="s1">).title()</span><span class="s3">,</span>
                     <span class="s1">as_unicode(val</span><span class="s3">, </span><span class="s4">'iso-8859-1'</span><span class="s1">))</span>
                    <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">val </span><span class="s3">in </span><span class="s1">iteritems(headers))</span>

        <span class="s3">if </span><span class="s1">req._tunnel_host:</span>
            <span class="s1">set_tunnel = h.set_tunnel </span><span class="s3">if </span><span class="s1">hasattr(</span>
                <span class="s1">h</span><span class="s3">, </span><span class="s4">&quot;set_tunnel&quot;</span><span class="s1">) </span><span class="s3">else </span><span class="s1">h._set_tunnel</span>
            <span class="s1">tunnel_headers = {}</span>
            <span class="s1">proxy_auth_hdr = </span><span class="s4">&quot;Proxy-Authorization&quot;</span>
            <span class="s3">if </span><span class="s1">proxy_auth_hdr </span><span class="s3">in </span><span class="s1">headers:</span>
                <span class="s1">tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]</span>
                <span class="s2"># Proxy-Authorization should not be sent to origin server.</span>
                <span class="s3">del </span><span class="s1">headers[proxy_auth_hdr]</span>
            <span class="s1">set_tunnel(req._tunnel_host</span><span class="s3">, </span><span class="s1">headers=tunnel_headers)</span>

        <span class="s3">if </span><span class="s1">self.parent.finalize_request_headers </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.parent.finalize_request_headers(req</span><span class="s3">, </span><span class="s1">headers)</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">h.request(str(req.get_method())</span><span class="s3">, </span><span class="s1">str(req.get_selector())</span><span class="s3">, </span><span class="s1">req.data</span><span class="s3">,</span>
                      <span class="s1">headers)</span>
            <span class="s1">r = h.getresponse()</span>
        <span class="s3">except </span><span class="s1">socket.error </span><span class="s3">as </span><span class="s1">err:  </span><span class="s2"># XXX what error?</span>
            <span class="s3">raise </span><span class="s1">URLError(err)</span>

        <span class="s2"># Pick apart the HTTPResponse object to get the addinfourl</span>
        <span class="s2"># object initialized properly.</span>
        <span class="s1">fp = create_readline_wrapper(r)</span>

        <span class="s1">resp = closeable_response(</span>
            <span class="s1">fp</span><span class="s3">, </span><span class="s1">r.msg</span><span class="s3">, </span><span class="s1">req.get_full_url()</span><span class="s3">, </span><span class="s1">r.status</span><span class="s3">, </span><span class="s1">r.reason</span><span class="s3">,</span>
            <span class="s1">getattr(r</span><span class="s3">, </span><span class="s4">'version'</span><span class="s3">, None</span><span class="s1">))</span>
        <span class="s3">return </span><span class="s1">resp</span>

    <span class="s3">def </span><span class="s1">__copy__(self):</span>
        <span class="s3">return </span><span class="s1">self.__class__(self._debuglevel)</span>


<span class="s3">class </span><span class="s1">HTTPHandler(AbstractHTTPHandler):</span>

    <span class="s3">def </span><span class="s1">http_open(self</span><span class="s3">, </span><span class="s1">req):</span>
        <span class="s3">return </span><span class="s1">self.do_open(HTTPConnection</span><span class="s3">, </span><span class="s1">req)</span>

    <span class="s1">http_request = AbstractHTTPHandler.do_request_</span>


<span class="s3">class </span><span class="s1">HTTPSHandler(AbstractHTTPHandler):</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">client_cert_manager=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">AbstractHTTPHandler.__init__(self)</span>
        <span class="s1">self.client_cert_manager = client_cert_manager</span>
        <span class="s1">self.ssl_context = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">https_open(self</span><span class="s3">, </span><span class="s1">req):</span>
        <span class="s1">key_file = cert_file = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">self.client_cert_manager </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">key_file</span><span class="s3">, </span><span class="s1">cert_file = self.client_cert_manager.find_key_cert(</span>
                <span class="s1">req.get_full_url())</span>
        <span class="s3">if </span><span class="s1">self.ssl_context </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">conn_factory = partial(</span>
                <span class="s1">HTTPSConnection</span><span class="s3">, </span><span class="s1">key_file=key_file</span><span class="s3">,</span>
                <span class="s1">cert_file=cert_file)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">conn_factory = partial(</span>
                <span class="s1">HTTPSConnection</span><span class="s3">, </span><span class="s1">key_file=key_file</span><span class="s3">,</span>
                <span class="s1">cert_file=cert_file</span><span class="s3">, </span><span class="s1">context=self.ssl_context)</span>
        <span class="s3">return </span><span class="s1">self.do_open(conn_factory</span><span class="s3">, </span><span class="s1">req)</span>

    <span class="s1">https_request = AbstractHTTPHandler.do_request_</span>

    <span class="s3">def </span><span class="s1">__copy__(self):</span>
        <span class="s1">ans = self.__class__(self.client_cert_manager)</span>
        <span class="s1">ans._debuglevel = self._debuglevel</span>
        <span class="s1">ans.ssl_context = self.ssl_context</span>
        <span class="s3">return </span><span class="s1">ans</span>


<span class="s3">class </span><span class="s1">HTTPCookieProcessor(BaseHandler):</span>
    <span class="s0">&quot;&quot;&quot;Handle HTTP cookies. 
 
    Public attributes: 
 
    cookiejar: CookieJar instance 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">cookiejar=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">cookiejar </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">cookiejar = CookieJar()</span>
        <span class="s1">self.cookiejar = cookiejar</span>

    <span class="s3">def </span><span class="s1">http_request(self</span><span class="s3">, </span><span class="s1">request):</span>
        <span class="s1">self.cookiejar.add_cookie_header(request)</span>
        <span class="s3">return </span><span class="s1">request</span>

    <span class="s3">def </span><span class="s1">http_response(self</span><span class="s3">, </span><span class="s1">request</span><span class="s3">, </span><span class="s1">response):</span>
        <span class="s1">self.cookiejar.extract_cookies(response</span><span class="s3">, </span><span class="s1">request)</span>
        <span class="s3">return </span><span class="s1">response</span>

    <span class="s3">def </span><span class="s1">__copy__(self):</span>
        <span class="s3">return </span><span class="s1">self.__class__(self.cookiejar)</span>

    <span class="s1">https_request = http_request</span>
    <span class="s1">https_response = http_response</span>


<span class="s3">class </span><span class="s1">UnknownHandler(BaseHandler):</span>

    <span class="s3">def </span><span class="s1">unknown_open(self</span><span class="s3">, </span><span class="s1">req):</span>
        <span class="s1">type = req.get_type()</span>
        <span class="s3">raise </span><span class="s1">URLError(</span><span class="s4">'unknown url type: %s' </span><span class="s1">% type)</span>


<span class="s3">def </span><span class="s1">parse_keqv_list(ln):</span>
    <span class="s0">&quot;&quot;&quot;Parse list of key=value strings where keys are not duplicated.&quot;&quot;&quot;</span>
    <span class="s1">parsed = {}</span>
    <span class="s3">for </span><span class="s1">elt </span><span class="s3">in </span><span class="s1">ln:</span>
        <span class="s1">k</span><span class="s3">, </span><span class="s1">v = elt.split(</span><span class="s4">'='</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">v[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">1</span><span class="s1">] == </span><span class="s4">'&quot;' </span><span class="s3">and </span><span class="s1">v[-</span><span class="s5">1</span><span class="s1">:] == </span><span class="s4">'&quot;'</span><span class="s1">:</span>
            <span class="s1">v = v[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">parsed[k] = v</span>
    <span class="s3">return </span><span class="s1">parsed</span>


<span class="s3">def </span><span class="s1">parse_http_list(s):</span>
    <span class="s0">&quot;&quot;&quot;Parse lists as described by RFC 2068 Section 2. 
 
    In particular, parse comma-separated lists where the elements of 
    the list may include quoted-strings.  A quoted-string could 
    contain a comma.  A non-quoted string could have quotes in the 
    middle.  Neither commas nor quotes count if they are escaped. 
    Only double-quotes count, not single-quotes. 
    &quot;&quot;&quot;</span>
    <span class="s1">res = []</span>
    <span class="s1">part = </span><span class="s4">''</span>

    <span class="s1">escape = quote = </span><span class="s3">False</span>
    <span class="s3">for </span><span class="s1">cur </span><span class="s3">in </span><span class="s1">s:</span>
        <span class="s3">if </span><span class="s1">escape:</span>
            <span class="s1">part += cur</span>
            <span class="s1">escape = </span><span class="s3">False</span>
            <span class="s3">continue</span>
        <span class="s3">if </span><span class="s1">quote:</span>
            <span class="s3">if </span><span class="s1">cur == </span><span class="s4">'</span><span class="s3">\\</span><span class="s4">'</span><span class="s1">:</span>
                <span class="s1">escape = </span><span class="s3">True</span>
                <span class="s3">continue</span>
            <span class="s3">elif </span><span class="s1">cur == </span><span class="s4">'&quot;'</span><span class="s1">:</span>
                <span class="s1">quote = </span><span class="s3">False</span>
            <span class="s1">part += cur</span>
            <span class="s3">continue</span>

        <span class="s3">if </span><span class="s1">cur == </span><span class="s4">','</span><span class="s1">:</span>
            <span class="s1">res.append(part)</span>
            <span class="s1">part = </span><span class="s4">''</span>
            <span class="s3">continue</span>

        <span class="s3">if </span><span class="s1">cur == </span><span class="s4">'&quot;'</span><span class="s1">:</span>
            <span class="s1">quote = </span><span class="s3">True</span>

        <span class="s1">part += cur</span>

    <span class="s2"># append last part</span>
    <span class="s3">if </span><span class="s1">part:</span>
        <span class="s1">res.append(part)</span>

    <span class="s3">return </span><span class="s1">list(filter(</span><span class="s3">None, </span><span class="s1">(part_.strip() </span><span class="s3">for </span><span class="s1">part_ </span><span class="s3">in </span><span class="s1">res)))</span>


<span class="s3">class </span><span class="s1">FileHandler(BaseHandler):</span>
    <span class="s2"># Use local file or FTP depending on form of URL</span>

    <span class="s3">def </span><span class="s1">file_open(self</span><span class="s3">, </span><span class="s1">req):</span>
        <span class="s1">url = req.get_selector()</span>
        <span class="s3">if </span><span class="s1">url[:</span><span class="s5">2</span><span class="s1">] == </span><span class="s4">'//' </span><span class="s3">and </span><span class="s1">url[</span><span class="s5">2</span><span class="s1">:</span><span class="s5">3</span><span class="s1">] != </span><span class="s4">'/'</span><span class="s1">:</span>
            <span class="s1">req.type = </span><span class="s4">'ftp'</span>
            <span class="s3">return </span><span class="s1">self.parent.open(req)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.open_local_file(req)</span>

    <span class="s2"># names for the localhost</span>
    <span class="s1">names = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">get_names(self):</span>
        <span class="s3">if </span><span class="s1">FileHandler.names </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">FileHandler.names = (socket.gethostbyname(</span><span class="s4">'localhost'</span><span class="s1">)</span><span class="s3">,</span>
                                     <span class="s1">socket.gethostbyname(socket.gethostname())</span>
                                     <span class="s1">)</span>
            <span class="s3">except </span><span class="s1">socket.gaierror:</span>
                <span class="s1">FileHandler.names = (socket.gethostbyname(</span><span class="s4">'localhost'</span><span class="s1">)</span><span class="s3">,</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">FileHandler.names</span>

    <span class="s2"># not entirely sure what the rules are here</span>
    <span class="s3">def </span><span class="s1">open_local_file(self</span><span class="s3">, </span><span class="s1">req):</span>
        <span class="s3">import </span><span class="s1">email.utils </span><span class="s3">as </span><span class="s1">emailutils</span>
        <span class="s3">import </span><span class="s1">mimetypes</span>
        <span class="s1">host = req.get_host()</span>
        <span class="s1">file = req.get_selector()</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">localfile = url2pathname(file)</span>
        <span class="s3">except </span><span class="s1">IOError </span><span class="s3">as </span><span class="s1">err:</span>
            <span class="s2"># url2pathname raises this on windows for bad urls</span>
            <span class="s3">raise </span><span class="s1">URLError(err)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">stats = os.stat(localfile)</span>
            <span class="s1">size = stats.st_size</span>
            <span class="s1">modified = emailutils.formatdate(stats.st_mtime</span><span class="s3">, </span><span class="s1">usegmt=</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s1">mtype = mimetypes.guess_type(file)[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">headers = create_response_info(BytesIO(</span>
                <span class="s1">(</span><span class="s4">'Content-type: %s</span><span class="s3">\n</span><span class="s4">Content-length: %d</span><span class="s3">\n</span><span class="s4">Last-modified: %s</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">%</span>
                    <span class="s1">(mtype </span><span class="s3">or </span><span class="s4">'text/plain'</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">modified)).encode(</span>
                        <span class="s4">'iso-8859-1'</span><span class="s1">)))</span>
            <span class="s3">if </span><span class="s1">host:</span>
                <span class="s1">host</span><span class="s3">, </span><span class="s1">port = splitport(host)</span>
            <span class="s3">if not </span><span class="s1">host </span><span class="s3">or </span><span class="s1">(</span>
                    <span class="s3">not </span><span class="s1">port </span><span class="s3">and </span><span class="s1">socket.gethostbyname(host) </span><span class="s3">in </span><span class="s1">self.get_names()</span>
            <span class="s1">):</span>
                <span class="s1">fp = open(localfile</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s1">)</span>
                <span class="s3">return </span><span class="s1">closeable_response(fp</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s4">'file:' </span><span class="s1">+ file)</span>
        <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">msg:</span>
            <span class="s2"># urllib2 users shouldn't expect OSErrors coming from urlopen()</span>
            <span class="s3">raise </span><span class="s1">URLError(msg)</span>
        <span class="s3">raise </span><span class="s1">URLError(</span><span class="s4">'file not on local host'</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">FTPHandler(BaseHandler):</span>

    <span class="s3">def </span><span class="s1">ftp_open(self</span><span class="s3">, </span><span class="s1">req):</span>
        <span class="s3">import </span><span class="s1">ftplib</span>
        <span class="s3">import </span><span class="s1">mimetypes</span>
        <span class="s1">host = req.get_host()</span>
        <span class="s3">if not </span><span class="s1">host:</span>
            <span class="s3">raise </span><span class="s1">URLError(</span><span class="s4">'ftp error: no host given'</span><span class="s1">)</span>
        <span class="s1">host</span><span class="s3">, </span><span class="s1">port = splitport(host)</span>
        <span class="s3">if </span><span class="s1">port </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">port = ftplib.FTP_PORT</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">port = int(port)</span>

        <span class="s2"># username/password handling</span>
        <span class="s1">user</span><span class="s3">, </span><span class="s1">host = splituser(host)</span>
        <span class="s3">if </span><span class="s1">user:</span>
            <span class="s1">user</span><span class="s3">, </span><span class="s1">passwd = splitpasswd(user)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">passwd = </span><span class="s3">None</span>
        <span class="s1">host = unquote(host)</span>
        <span class="s1">user = unquote(user </span><span class="s3">or </span><span class="s4">''</span><span class="s1">)</span>
        <span class="s1">passwd = unquote(passwd </span><span class="s3">or </span><span class="s4">''</span><span class="s1">)</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">host = socket.gethostbyname(host)</span>
        <span class="s3">except </span><span class="s1">socket.error </span><span class="s3">as </span><span class="s1">msg:</span>
            <span class="s3">raise </span><span class="s1">URLError(msg)</span>
        <span class="s1">path</span><span class="s3">, </span><span class="s1">attrs = splitattr(req.get_selector())</span>
        <span class="s1">dirs = path.split(</span><span class="s4">'/'</span><span class="s1">)</span>
        <span class="s1">dirs = list(map(unquote</span><span class="s3">, </span><span class="s1">dirs))</span>
        <span class="s1">dirs</span><span class="s3">, </span><span class="s1">file = dirs[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dirs[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">dirs </span><span class="s3">and not </span><span class="s1">dirs[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s1">dirs = dirs[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">fw = self.connect_ftp(user</span><span class="s3">, </span><span class="s1">passwd</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">port</span><span class="s3">, </span><span class="s1">dirs</span><span class="s3">, </span><span class="s1">req.timeout)</span>
            <span class="s1">type = file </span><span class="s3">and </span><span class="s4">'I' </span><span class="s3">or </span><span class="s4">'D'</span>
            <span class="s3">for </span><span class="s1">attr </span><span class="s3">in </span><span class="s1">attrs:</span>
                <span class="s1">attr</span><span class="s3">, </span><span class="s1">value = splitvalue(attr)</span>
                <span class="s3">if </span><span class="s1">attr.lower() == </span><span class="s4">'type' </span><span class="s3">and </span><span class="s1">\</span>
                   <span class="s1">value </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'a'</span><span class="s3">, </span><span class="s4">'A'</span><span class="s3">, </span><span class="s4">'i'</span><span class="s3">, </span><span class="s4">'I'</span><span class="s3">, </span><span class="s4">'d'</span><span class="s3">, </span><span class="s4">'D'</span><span class="s1">):</span>
                    <span class="s1">type = value.upper()</span>
            <span class="s1">fp</span><span class="s3">, </span><span class="s1">retrlen = fw.retrfile(file</span><span class="s3">, </span><span class="s1">type)</span>
            <span class="s1">headers = </span><span class="s4">&quot;&quot;</span>
            <span class="s1">mtype = mimetypes.guess_type(req.get_full_url())[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">mtype:</span>
                <span class="s1">headers += </span><span class="s4">&quot;Content-type: %s</span><span class="s3">\n</span><span class="s4">&quot; </span><span class="s1">% mtype</span>
            <span class="s3">if </span><span class="s1">retrlen </span><span class="s3">is not None and </span><span class="s1">retrlen &gt;= </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">headers += </span><span class="s4">&quot;Content-length: %d</span><span class="s3">\n</span><span class="s4">&quot; </span><span class="s1">% retrlen</span>
            <span class="s1">sf = BytesIO(headers.encode(</span><span class="s4">'iso-8859-1'</span><span class="s1">))</span>
            <span class="s1">headers = create_response_info(sf)</span>
            <span class="s3">return </span><span class="s1">closeable_response(fp</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">req.get_full_url())</span>
        <span class="s3">except </span><span class="s1">ftplib.all_errors </span><span class="s3">as </span><span class="s1">msg:</span>
            <span class="s1">raise_with_traceback(URLError(</span><span class="s4">'ftp error: %s' </span><span class="s1">% msg))</span>

    <span class="s3">def </span><span class="s1">connect_ftp(self</span><span class="s3">, </span><span class="s1">user</span><span class="s3">, </span><span class="s1">passwd</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">port</span><span class="s3">, </span><span class="s1">dirs</span><span class="s3">, </span><span class="s1">timeout):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">fw = ftpwrapper(user</span><span class="s3">, </span><span class="s1">passwd</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">port</span><span class="s3">, </span><span class="s1">dirs</span><span class="s3">, </span><span class="s1">timeout)</span>
        <span class="s3">except </span><span class="s1">TypeError:</span>
            <span class="s2"># Python &lt; 2.6, no per-connection timeout support</span>
            <span class="s1">fw = ftpwrapper(user</span><span class="s3">, </span><span class="s1">passwd</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">port</span><span class="s3">, </span><span class="s1">dirs)</span>
<span class="s2"># fw.ftp.set_debuglevel(1)</span>
        <span class="s3">return </span><span class="s1">fw</span>


<span class="s3">class </span><span class="s1">CacheFTPHandler(FTPHandler):</span>
    <span class="s2"># XXX would be nice to have pluggable cache strategies</span>
    <span class="s2"># XXX this stuff is definitely not thread safe</span>

    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.cache = {}</span>
        <span class="s1">self.timeout = {}</span>
        <span class="s1">self.soonest = </span><span class="s5">0</span>
        <span class="s1">self.delay = </span><span class="s5">60</span>
        <span class="s1">self.max_conns = </span><span class="s5">16</span>

    <span class="s3">def </span><span class="s1">setTimeout(self</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s1">self.delay = t</span>

    <span class="s3">def </span><span class="s1">setMaxConns(self</span><span class="s3">, </span><span class="s1">m):</span>
        <span class="s1">self.max_conns = m</span>

    <span class="s3">def </span><span class="s1">connect_ftp(self</span><span class="s3">, </span><span class="s1">user</span><span class="s3">, </span><span class="s1">passwd</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">port</span><span class="s3">, </span><span class="s1">dirs</span><span class="s3">, </span><span class="s1">timeout):</span>
        <span class="s1">key = user</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">port</span><span class="s3">, </span><span class="s4">'/'</span><span class="s1">.join(dirs)</span><span class="s3">, </span><span class="s1">timeout</span>
        <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self.cache:</span>
            <span class="s1">self.timeout[key] = time.time() + self.delay</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.cache[key] = ftpwrapper(</span>
                <span class="s1">user</span><span class="s3">, </span><span class="s1">passwd</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">port</span><span class="s3">, </span><span class="s1">dirs</span><span class="s3">, </span><span class="s1">timeout)</span>
            <span class="s1">self.timeout[key] = time.time() + self.delay</span>
        <span class="s1">self.check_cache()</span>
        <span class="s3">return </span><span class="s1">self.cache[key]</span>

    <span class="s3">def </span><span class="s1">check_cache(self):</span>
        <span class="s2"># first check for old ones</span>
        <span class="s1">t = time.time()</span>
        <span class="s3">if </span><span class="s1">self.soonest &lt;= t:</span>
            <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">iteritems(self.timeout):</span>
                <span class="s3">if </span><span class="s1">v &lt; t:</span>
                    <span class="s1">self.cache[k].close()</span>
                    <span class="s3">del </span><span class="s1">self.cache[k]</span>
                    <span class="s3">del </span><span class="s1">self.timeout[k]</span>
        <span class="s1">self.soonest = min(self.timeout.values())</span>

        <span class="s2"># then check the size</span>
        <span class="s3">if </span><span class="s1">len(self.cache) == self.max_conns:</span>
            <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">iteritems(self.timeout):</span>
                <span class="s3">if </span><span class="s1">v == self.soonest:</span>
                    <span class="s3">del </span><span class="s1">self.cache[k]</span>
                    <span class="s3">del </span><span class="s1">self.timeout[k]</span>
                    <span class="s3">break</span>
            <span class="s1">self.soonest = min(self.timeout.values())</span>
</pre>
</body>
</html>