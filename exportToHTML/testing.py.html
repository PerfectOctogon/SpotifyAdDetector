<html>
<head>
<title>testing.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
testing.py</font>
</center></td></tr></table>
<pre><span class="s0"># encoding: utf-8</span>
<span class="s2">&quot;&quot;&quot;Helper classes for tests.&quot;&quot;&quot;</span>

<span class="s0"># Use of this source code is governed by the MIT license.</span>
<span class="s1">__license__ = </span><span class="s3">&quot;MIT&quot;</span>

<span class="s4">import </span><span class="s1">pickle</span>
<span class="s4">import </span><span class="s1">copy</span>
<span class="s4">import </span><span class="s1">functools</span>
<span class="s4">import </span><span class="s1">unittest</span>
<span class="s4">from </span><span class="s1">unittest </span><span class="s4">import </span><span class="s1">TestCase</span>
<span class="s4">from </span><span class="s1">bs4 </span><span class="s4">import </span><span class="s1">BeautifulSoup</span>
<span class="s4">from </span><span class="s1">bs4.element </span><span class="s4">import </span><span class="s1">(</span>
    <span class="s1">CharsetMetaAttributeValue</span><span class="s4">,</span>
    <span class="s1">Comment</span><span class="s4">,</span>
    <span class="s1">ContentMetaAttributeValue</span><span class="s4">,</span>
    <span class="s1">Doctype</span><span class="s4">,</span>
    <span class="s1">PYTHON_SPECIFIC_ENCODINGS</span><span class="s4">,</span>
    <span class="s1">SoupStrainer</span><span class="s4">,</span>
    <span class="s1">Script</span><span class="s4">,</span>
    <span class="s1">Stylesheet</span><span class="s4">,</span>
    <span class="s1">Tag</span>
<span class="s1">)</span>

<span class="s4">from </span><span class="s1">bs4.builder </span><span class="s4">import </span><span class="s1">HTMLParserTreeBuilder</span>
<span class="s1">default_builder = HTMLParserTreeBuilder</span>

<span class="s1">BAD_DOCUMENT = </span><span class="s3">&quot;&quot;&quot;A bare string 
&lt;!DOCTYPE xsl:stylesheet SYSTEM &quot;htmlent.dtd&quot;&gt; 
&lt;!DOCTYPE xsl:stylesheet PUBLIC &quot;htmlent.dtd&quot;&gt; 
&lt;div&gt;&lt;![CDATA[A CDATA section where it doesn't belong]]&gt;&lt;/div&gt; 
&lt;div&gt;&lt;svg&gt;&lt;![CDATA[HTML5 does allow CDATA sections in SVG]]&gt;&lt;/svg&gt;&lt;/div&gt; 
&lt;div&gt;A &lt;meta&gt; tag&lt;/div&gt; 
&lt;div&gt;A &lt;br&gt; tag that supposedly has contents.&lt;/br&gt;&lt;/div&gt; 
&lt;div&gt;AT&amp;T&lt;/div&gt; 
&lt;div&gt;&lt;textarea&gt;Within a textarea, markup like &lt;b&gt; tags and &lt;&amp;&lt;&amp;amp; should be treated as literal&lt;/textarea&gt;&lt;/div&gt; 
&lt;div&gt;&lt;script&gt;if (i &lt; 2) { alert(&quot;&lt;b&gt;Markup within script tags should be treated as literal.&lt;/b&gt;&quot;); }&lt;/script&gt;&lt;/div&gt; 
&lt;div&gt;This numeric entity is missing the final semicolon: &lt;x t=&quot;pi&amp;#241ata&quot;&gt;&lt;/div&gt; 
&lt;div&gt;&lt;a href=&quot;http://example.com/&lt;/a&gt; that attribute value never got closed&lt;/div&gt; 
&lt;div&gt;&lt;a href=&quot;foo&lt;/a&gt;, &lt;/a&gt;&lt;a href=&quot;bar&quot;&gt;that attribute value was closed by the subsequent tag&lt;/a&gt;&lt;/div&gt; 
&lt;! This document starts with a bogus declaration &gt;&lt;div&gt;a&lt;/div&gt; 
&lt;div&gt;This document contains &lt;!an incomplete declaration &lt;div&gt;(do you see it?)&lt;/div&gt; 
&lt;div&gt;This document ends with &lt;!an incomplete declaration 
&lt;div&gt;&lt;a style={height:21px;}&gt;That attribute value was bogus&lt;/a&gt;&lt;/div&gt; 
&lt;! DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;&gt;The doctype is invalid because it contains extra whitespace 
&lt;div&gt;&lt;table&gt;&lt;td nowrap&gt;That boolean attribute had no value&lt;/td&gt;&lt;/table&gt;&lt;/div&gt; 
&lt;div&gt;Here's a nonexistent entity: &amp;#foo; (do you see it?)&lt;/div&gt; 
&lt;div&gt;This document ends before the entity finishes: &amp;gt 
&lt;div&gt;&lt;p&gt;Paragraphs shouldn't contain block display elements, but this one does: &lt;dl&gt;&lt;dt&gt;you see?&lt;/dt&gt;&lt;/p&gt; 
&lt;b b=&quot;20&quot; a=&quot;1&quot; b=&quot;10&quot; a=&quot;2&quot; a=&quot;3&quot; a=&quot;4&quot;&gt;Multiple values for the same attribute.&lt;/b&gt; 
&lt;div&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Here's a table&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt; 
&lt;div&gt;&lt;table id=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;Here's a nested table:&lt;table id=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;foo&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;/div&gt; 
&lt;div&gt;This tag contains nothing but whitespace: &lt;b&gt;    &lt;/b&gt;&lt;/div&gt; 
&lt;div&gt;&lt;blockquote&gt;&lt;p&gt;&lt;b&gt;This p tag is cut off by&lt;/blockquote&gt;&lt;/p&gt;the end of the blockquote tag&lt;/div&gt; 
&lt;div&gt;&lt;table&gt;&lt;div&gt;This table contains bare markup&lt;/div&gt;&lt;/table&gt;&lt;/div&gt; 
&lt;div&gt;&lt;div id=&quot;1&quot;&gt;</span><span class="s4">\n </span><span class="s3">&lt;a href=&quot;link1&quot;&gt;This link is never closed.</span><span class="s4">\n</span><span class="s3">&lt;/div&gt;</span><span class="s4">\n</span><span class="s3">&lt;div id=&quot;2&quot;&gt;</span><span class="s4">\n </span><span class="s3">&lt;div id=&quot;3&quot;&gt;</span><span class="s4">\n   </span><span class="s3">&lt;a href=&quot;link2&quot;&gt;This link is closed.&lt;/a&gt;</span><span class="s4">\n  </span><span class="s3">&lt;/div&gt;</span><span class="s4">\n</span><span class="s3">&lt;/div&gt;&lt;/div&gt; 
&lt;div&gt;This document contains a &lt;!DOCTYPE surprise&gt;surprise doctype&lt;/div&gt; 
&lt;div&gt;&lt;a&gt;&lt;B&gt;&lt;Cd&gt;&lt;EFG&gt;Mixed case tags are folded to lowercase&lt;/efg&gt;&lt;/CD&gt;&lt;/b&gt;&lt;/A&gt;&lt;/div&gt; 
&lt;div&gt;&lt;our</span><span class="s4">\u2603</span><span class="s3">&gt;Tag name contains Unicode characters&lt;/our</span><span class="s4">\u2603</span><span class="s3">&gt;&lt;/div&gt; 
&lt;div&gt;&lt;a </span><span class="s4">\u2603</span><span class="s3">=&quot;snowman&quot;&gt;Attribute name contains Unicode characters&lt;/a&gt;&lt;/div&gt; 
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; 
&quot;&quot;&quot;</span>


<span class="s4">class </span><span class="s1">SoupTest(unittest.TestCase):</span>

    <span class="s1">@property</span>
    <span class="s4">def </span><span class="s1">default_builder(self):</span>
        <span class="s4">return </span><span class="s1">default_builder</span>

    <span class="s4">def </span><span class="s1">soup(self</span><span class="s4">, </span><span class="s1">markup</span><span class="s4">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot;Build a Beautiful Soup object from markup.&quot;&quot;&quot;</span>
        <span class="s1">builder = kwargs.pop(</span><span class="s3">'builder'</span><span class="s4">, </span><span class="s1">self.default_builder)</span>
        <span class="s4">return </span><span class="s1">BeautifulSoup(markup</span><span class="s4">, </span><span class="s1">builder=builder</span><span class="s4">, </span><span class="s1">**kwargs)</span>

    <span class="s4">def </span><span class="s1">document_for(self</span><span class="s4">, </span><span class="s1">markup</span><span class="s4">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot;Turn an HTML fragment into a document. 
 
        The details depend on the builder. 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self.default_builder(**kwargs).test_fragment_to_document(markup)</span>

    <span class="s4">def </span><span class="s1">assertSoupEquals(self</span><span class="s4">, </span><span class="s1">to_parse</span><span class="s4">, </span><span class="s1">compare_parsed_to=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s1">builder = self.default_builder</span>
        <span class="s1">obj = BeautifulSoup(to_parse</span><span class="s4">, </span><span class="s1">builder=builder)</span>
        <span class="s4">if </span><span class="s1">compare_parsed_to </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">compare_parsed_to = to_parse</span>

        <span class="s0"># Verify that the documents come out the same.</span>
        <span class="s1">self.assertEqual(obj.decode()</span><span class="s4">, </span><span class="s1">self.document_for(compare_parsed_to))</span>

        <span class="s0"># Also run some checks on the BeautifulSoup object itself:</span>

        <span class="s0"># Verify that every tag that was opened was eventually closed.</span>

        <span class="s0"># There are no tags in the open tag counter.</span>
        <span class="s4">assert </span><span class="s1">all(v==</span><span class="s5">0 </span><span class="s4">for </span><span class="s1">v </span><span class="s4">in </span><span class="s1">list(obj.open_tag_counter.values()))</span>

        <span class="s0"># The only tag in the tag stack is the one for the root</span>
        <span class="s0"># document.</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">[obj.ROOT_TAG_NAME]</span><span class="s4">, </span><span class="s1">[x.name </span><span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">obj.tagStack]</span>
        <span class="s1">)</span>
        
    <span class="s4">def </span><span class="s1">assertConnectedness(self</span><span class="s4">, </span><span class="s1">element):</span>
        <span class="s2">&quot;&quot;&quot;Ensure that next_element and previous_element are properly 
        set for all descendants of the given element. 
        &quot;&quot;&quot;</span>
        <span class="s1">earlier = </span><span class="s4">None</span>
        <span class="s4">for </span><span class="s1">e </span><span class="s4">in </span><span class="s1">element.descendants:</span>
            <span class="s4">if </span><span class="s1">earlier:</span>
                <span class="s1">self.assertEqual(e</span><span class="s4">, </span><span class="s1">earlier.next_element)</span>
                <span class="s1">self.assertEqual(earlier</span><span class="s4">, </span><span class="s1">e.previous_element)</span>
            <span class="s1">earlier = e</span>

    <span class="s4">def </span><span class="s1">linkage_validator(self</span><span class="s4">, </span><span class="s1">el</span><span class="s4">, </span><span class="s1">_recursive_call=</span><span class="s4">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Ensure proper linkage throughout the document.&quot;&quot;&quot;</span>
        <span class="s1">descendant = </span><span class="s4">None</span>
        <span class="s0"># Document element should have no previous element or previous sibling.</span>
        <span class="s0"># It also shouldn't have a next sibling.</span>
        <span class="s4">if </span><span class="s1">el.parent </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s4">assert </span><span class="s1">el.previous_element </span><span class="s4">is None,</span><span class="s1">\</span>
                <span class="s3">&quot;Bad previous_element</span><span class="s4">\n</span><span class="s3">NODE: {}</span><span class="s4">\n</span><span class="s3">PREV: {}</span><span class="s4">\n</span><span class="s3">EXPECTED: {}&quot;</span><span class="s1">.format(</span>
                    <span class="s1">el</span><span class="s4">, </span><span class="s1">el.previous_element</span><span class="s4">, None</span>
                <span class="s1">)</span>
            <span class="s4">assert </span><span class="s1">el.previous_sibling </span><span class="s4">is None,</span><span class="s1">\</span>
                <span class="s3">&quot;Bad previous_sibling</span><span class="s4">\n</span><span class="s3">NODE: {}</span><span class="s4">\n</span><span class="s3">PREV: {}</span><span class="s4">\n</span><span class="s3">EXPECTED: {}&quot;</span><span class="s1">.format(</span>
                    <span class="s1">el</span><span class="s4">, </span><span class="s1">el.previous_sibling</span><span class="s4">, None</span>
                <span class="s1">)</span>
            <span class="s4">assert </span><span class="s1">el.next_sibling </span><span class="s4">is None,</span><span class="s1">\</span>
                <span class="s3">&quot;Bad next_sibling</span><span class="s4">\n</span><span class="s3">NODE: {}</span><span class="s4">\n</span><span class="s3">NEXT: {}</span><span class="s4">\n</span><span class="s3">EXPECTED: {}&quot;</span><span class="s1">.format(</span>
                    <span class="s1">el</span><span class="s4">, </span><span class="s1">el.next_sibling</span><span class="s4">, None</span>
                <span class="s1">)</span>

        <span class="s1">idx = </span><span class="s5">0</span>
        <span class="s1">child = </span><span class="s4">None</span>
        <span class="s1">last_child = </span><span class="s4">None</span>
        <span class="s1">last_idx = len(el.contents) - </span><span class="s5">1</span>
        <span class="s4">for </span><span class="s1">child </span><span class="s4">in </span><span class="s1">el.contents:</span>
            <span class="s1">descendant = </span><span class="s4">None</span>

            <span class="s0"># Parent should link next element to their first child</span>
            <span class="s0"># That child should have no previous sibling</span>
            <span class="s4">if </span><span class="s1">idx == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4">if </span><span class="s1">el.parent </span><span class="s4">is not None</span><span class="s1">:</span>
                    <span class="s4">assert </span><span class="s1">el.next_element </span><span class="s4">is </span><span class="s1">child</span><span class="s4">,</span><span class="s1">\</span>
                       <span class="s3">&quot;Bad next_element</span><span class="s4">\n</span><span class="s3">NODE: {}</span><span class="s4">\n</span><span class="s3">NEXT: {}</span><span class="s4">\n</span><span class="s3">EXPECTED: {}&quot;</span><span class="s1">.format(</span>
                            <span class="s1">el</span><span class="s4">, </span><span class="s1">el.next_element</span><span class="s4">, </span><span class="s1">child</span>
                        <span class="s1">)</span>
                    <span class="s4">assert </span><span class="s1">child.previous_element </span><span class="s4">is </span><span class="s1">el</span><span class="s4">,</span><span class="s1">\</span>
                       <span class="s3">&quot;Bad previous_element</span><span class="s4">\n</span><span class="s3">NODE: {}</span><span class="s4">\n</span><span class="s3">PREV: {}</span><span class="s4">\n</span><span class="s3">EXPECTED: {}&quot;</span><span class="s1">.format(</span>
                            <span class="s1">child</span><span class="s4">, </span><span class="s1">child.previous_element</span><span class="s4">, </span><span class="s1">el</span>
                        <span class="s1">)</span>
                    <span class="s4">assert </span><span class="s1">child.previous_sibling </span><span class="s4">is None,</span><span class="s1">\</span>
                       <span class="s3">&quot;Bad previous_sibling</span><span class="s4">\n</span><span class="s3">NODE: {}</span><span class="s4">\n</span><span class="s3">PREV {}</span><span class="s4">\n</span><span class="s3">EXPECTED: {}&quot;</span><span class="s1">.format(</span>
                            <span class="s1">child</span><span class="s4">, </span><span class="s1">child.previous_sibling</span><span class="s4">, None</span>
                        <span class="s1">)</span>

            <span class="s0"># If not the first child, previous index should link as sibling to this index</span>
            <span class="s0"># Previous element should match the last index or the last bubbled up descendant</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s4">assert </span><span class="s1">child.previous_sibling </span><span class="s4">is </span><span class="s1">el.contents[idx - </span><span class="s5">1</span><span class="s1">]</span><span class="s4">,</span><span class="s1">\</span>
                    <span class="s3">&quot;Bad previous_sibling</span><span class="s4">\n</span><span class="s3">NODE: {}</span><span class="s4">\n</span><span class="s3">PREV {}</span><span class="s4">\n</span><span class="s3">EXPECTED {}&quot;</span><span class="s1">.format(</span>
                        <span class="s1">child</span><span class="s4">, </span><span class="s1">child.previous_sibling</span><span class="s4">, </span><span class="s1">el.contents[idx - </span><span class="s5">1</span><span class="s1">]</span>
                    <span class="s1">)</span>
                <span class="s4">assert </span><span class="s1">el.contents[idx - </span><span class="s5">1</span><span class="s1">].next_sibling </span><span class="s4">is </span><span class="s1">child</span><span class="s4">,</span><span class="s1">\</span>
                    <span class="s3">&quot;Bad next_sibling</span><span class="s4">\n</span><span class="s3">NODE: {}</span><span class="s4">\n</span><span class="s3">NEXT {}</span><span class="s4">\n</span><span class="s3">EXPECTED {}&quot;</span><span class="s1">.format(</span>
                        <span class="s1">el.contents[idx - </span><span class="s5">1</span><span class="s1">]</span><span class="s4">, </span><span class="s1">el.contents[idx - </span><span class="s5">1</span><span class="s1">].next_sibling</span><span class="s4">, </span><span class="s1">child</span>
                    <span class="s1">)</span>

                <span class="s4">if </span><span class="s1">last_child </span><span class="s4">is not None</span><span class="s1">:</span>
                    <span class="s4">assert </span><span class="s1">child.previous_element </span><span class="s4">is </span><span class="s1">last_child</span><span class="s4">,</span><span class="s1">\</span>
                        <span class="s3">&quot;Bad previous_element</span><span class="s4">\n</span><span class="s3">NODE: {}</span><span class="s4">\n</span><span class="s3">PREV {}</span><span class="s4">\n</span><span class="s3">EXPECTED {}</span><span class="s4">\n</span><span class="s3">CONTENTS {}&quot;</span><span class="s1">.format(</span>
                            <span class="s1">child</span><span class="s4">, </span><span class="s1">child.previous_element</span><span class="s4">, </span><span class="s1">last_child</span><span class="s4">, </span><span class="s1">child.parent.contents</span>
                        <span class="s1">)</span>
                    <span class="s4">assert </span><span class="s1">last_child.next_element </span><span class="s4">is </span><span class="s1">child</span><span class="s4">,</span><span class="s1">\</span>
                        <span class="s3">&quot;Bad next_element</span><span class="s4">\n</span><span class="s3">NODE: {}</span><span class="s4">\n</span><span class="s3">NEXT {}</span><span class="s4">\n</span><span class="s3">EXPECTED {}&quot;</span><span class="s1">.format(</span>
                            <span class="s1">last_child</span><span class="s4">, </span><span class="s1">last_child.next_element</span><span class="s4">, </span><span class="s1">child</span>
                        <span class="s1">)</span>

            <span class="s4">if </span><span class="s1">isinstance(child</span><span class="s4">, </span><span class="s1">Tag) </span><span class="s4">and </span><span class="s1">child.contents:</span>
                <span class="s1">descendant = self.linkage_validator(child</span><span class="s4">, True</span><span class="s1">)</span>
                <span class="s0"># A bubbled up descendant should have no next siblings</span>
                <span class="s4">assert </span><span class="s1">descendant.next_sibling </span><span class="s4">is None,</span><span class="s1">\</span>
                    <span class="s3">&quot;Bad next_sibling</span><span class="s4">\n</span><span class="s3">NODE: {}</span><span class="s4">\n</span><span class="s3">NEXT {}</span><span class="s4">\n</span><span class="s3">EXPECTED {}&quot;</span><span class="s1">.format(</span>
                        <span class="s1">descendant</span><span class="s4">, </span><span class="s1">descendant.next_sibling</span><span class="s4">, None</span>
                    <span class="s1">)</span>

            <span class="s0"># Mark last child as either the bubbled up descendant or the current child</span>
            <span class="s4">if </span><span class="s1">descendant </span><span class="s4">is not None</span><span class="s1">:</span>
                <span class="s1">last_child = descendant</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">last_child = child</span>

            <span class="s0"># If last child, there are non next siblings</span>
            <span class="s4">if </span><span class="s1">idx == last_idx:</span>
                <span class="s4">assert </span><span class="s1">child.next_sibling </span><span class="s4">is None,</span><span class="s1">\</span>
                    <span class="s3">&quot;Bad next_sibling</span><span class="s4">\n</span><span class="s3">NODE: {}</span><span class="s4">\n</span><span class="s3">NEXT {}</span><span class="s4">\n</span><span class="s3">EXPECTED {}&quot;</span><span class="s1">.format(</span>
                        <span class="s1">child</span><span class="s4">, </span><span class="s1">child.next_sibling</span><span class="s4">, None</span>
                    <span class="s1">)</span>
            <span class="s1">idx += </span><span class="s5">1</span>

        <span class="s1">child = descendant </span><span class="s4">if </span><span class="s1">descendant </span><span class="s4">is not None else </span><span class="s1">child</span>
        <span class="s4">if </span><span class="s1">child </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">child = el</span>

        <span class="s4">if not </span><span class="s1">_recursive_call </span><span class="s4">and </span><span class="s1">child </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">target = el</span>
            <span class="s4">while True</span><span class="s1">:</span>
                <span class="s4">if </span><span class="s1">target </span><span class="s4">is None</span><span class="s1">:</span>
                    <span class="s4">assert </span><span class="s1">child.next_element </span><span class="s4">is None, </span><span class="s1">\</span>
                        <span class="s3">&quot;Bad next_element</span><span class="s4">\n</span><span class="s3">NODE: {}</span><span class="s4">\n</span><span class="s3">NEXT {}</span><span class="s4">\n</span><span class="s3">EXPECTED {}&quot;</span><span class="s1">.format(</span>
                            <span class="s1">child</span><span class="s4">, </span><span class="s1">child.next_element</span><span class="s4">, None</span>
                        <span class="s1">)</span>
                    <span class="s4">break</span>
                <span class="s4">elif </span><span class="s1">target.next_sibling </span><span class="s4">is not None</span><span class="s1">:</span>
                    <span class="s4">assert </span><span class="s1">child.next_element </span><span class="s4">is </span><span class="s1">target.next_sibling</span><span class="s4">, </span><span class="s1">\</span>
                        <span class="s3">&quot;Bad next_element</span><span class="s4">\n</span><span class="s3">NODE: {}</span><span class="s4">\n</span><span class="s3">NEXT {}</span><span class="s4">\n</span><span class="s3">EXPECTED {}&quot;</span><span class="s1">.format(</span>
                            <span class="s1">child</span><span class="s4">, </span><span class="s1">child.next_element</span><span class="s4">, </span><span class="s1">target.next_sibling</span>
                        <span class="s1">)</span>
                    <span class="s4">break</span>
                <span class="s1">target = target.parent</span>

            <span class="s0"># We are done, so nothing to return</span>
            <span class="s4">return None</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s0"># Return the child to the recursive caller</span>
            <span class="s4">return </span><span class="s1">child</span>


<span class="s4">class </span><span class="s1">HTMLTreeBuilderSmokeTest(object):</span>

    <span class="s2">&quot;&quot;&quot;A basic test of a treebuilder's competence. 
 
    Any HTML treebuilder, present or future, should be able to pass 
    these tests. With invalid markup, there's room for interpretation, 
    and different parsers can handle it differently. But with the 
    markup in these tests, there's not much room for interpretation. 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">test_empty_element_tags(self):</span>
        <span class="s2">&quot;&quot;&quot;Verify that all HTML4 and HTML5 empty element (aka void element) tags 
        are handled correctly. 
        &quot;&quot;&quot;</span>
        <span class="s4">for </span><span class="s1">name </span><span class="s4">in </span><span class="s1">[</span>
                <span class="s3">'area'</span><span class="s4">, </span><span class="s3">'base'</span><span class="s4">, </span><span class="s3">'br'</span><span class="s4">, </span><span class="s3">'col'</span><span class="s4">, </span><span class="s3">'embed'</span><span class="s4">, </span><span class="s3">'hr'</span><span class="s4">, </span><span class="s3">'img'</span><span class="s4">, </span><span class="s3">'input'</span><span class="s4">, </span><span class="s3">'keygen'</span><span class="s4">, </span><span class="s3">'link'</span><span class="s4">, </span><span class="s3">'menuitem'</span><span class="s4">, </span><span class="s3">'meta'</span><span class="s4">, </span><span class="s3">'param'</span><span class="s4">, </span><span class="s3">'source'</span><span class="s4">, </span><span class="s3">'track'</span><span class="s4">, </span><span class="s3">'wbr'</span><span class="s4">,</span>
                <span class="s3">'spacer'</span><span class="s4">, </span><span class="s3">'frame'</span>
        <span class="s1">]:</span>
            <span class="s1">soup = self.soup(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">new_tag = soup.new_tag(name)</span>
            <span class="s1">self.assertEqual(</span><span class="s4">True, </span><span class="s1">new_tag.is_empty_element)</span>

    <span class="s4">def </span><span class="s1">test_special_string_containers(self):</span>
        <span class="s1">soup = self.soup(</span>
            <span class="s3">&quot;&lt;style&gt;Some CSS&lt;/style&gt;&lt;script&gt;Some Javascript&lt;/script&gt;&quot;</span>
        <span class="s1">)</span>
        <span class="s4">assert </span><span class="s1">isinstance(soup.style.string</span><span class="s4">, </span><span class="s1">Stylesheet)</span>
        <span class="s4">assert </span><span class="s1">isinstance(soup.script.string</span><span class="s4">, </span><span class="s1">Script)</span>

        <span class="s1">soup = self.soup(</span>
            <span class="s3">&quot;&lt;style&gt;&lt;!--Some CSS--&gt;&lt;/style&gt;&quot;</span>
        <span class="s1">)</span>
        <span class="s4">assert </span><span class="s1">isinstance(soup.style.string</span><span class="s4">, </span><span class="s1">Stylesheet)</span>
        <span class="s0"># The contents of the style tag resemble an HTML comment, but</span>
        <span class="s0"># it's not treated as a comment.</span>
        <span class="s1">self.assertEqual(</span><span class="s3">&quot;&lt;!--Some CSS--&gt;&quot;</span><span class="s4">, </span><span class="s1">soup.style.string)</span>
        <span class="s4">assert </span><span class="s1">isinstance(soup.style.string</span><span class="s4">, </span><span class="s1">Stylesheet)</span>
        
    <span class="s4">def </span><span class="s1">test_pickle_and_unpickle_identity(self):</span>
        <span class="s0"># Pickling a tree, then unpickling it, yields a tree identical</span>
        <span class="s0"># to the original.</span>
        <span class="s1">tree = self.soup(</span><span class="s3">&quot;&lt;a&gt;&lt;b&gt;foo&lt;/a&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">dumped = pickle.dumps(tree</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">loaded = pickle.loads(dumped)</span>
        <span class="s1">self.assertEqual(loaded.__class__</span><span class="s4">, </span><span class="s1">BeautifulSoup)</span>
        <span class="s1">self.assertEqual(loaded.decode()</span><span class="s4">, </span><span class="s1">tree.decode())</span>

    <span class="s4">def </span><span class="s1">assertDoctypeHandled(self</span><span class="s4">, </span><span class="s1">doctype_fragment):</span>
        <span class="s2">&quot;&quot;&quot;Assert that a given doctype string is handled correctly.&quot;&quot;&quot;</span>
        <span class="s1">doctype_str</span><span class="s4">, </span><span class="s1">soup = self._document_with_doctype(doctype_fragment)</span>

        <span class="s0"># Make sure a Doctype object was created.</span>
        <span class="s1">doctype = soup.contents[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">self.assertEqual(doctype.__class__</span><span class="s4">, </span><span class="s1">Doctype)</span>
        <span class="s1">self.assertEqual(doctype</span><span class="s4">, </span><span class="s1">doctype_fragment)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.encode(</span><span class="s3">&quot;utf8&quot;</span><span class="s1">)[:len(doctype_str)]</span><span class="s4">,</span>
            <span class="s1">doctype_str</span>
        <span class="s1">)</span>

        <span class="s0"># Make sure that the doctype was correctly associated with the</span>
        <span class="s0"># parse tree and that the rest of the document parsed.</span>
        <span class="s1">self.assertEqual(soup.p.contents[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s3">'foo'</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">_document_with_doctype(self</span><span class="s4">, </span><span class="s1">doctype_fragment</span><span class="s4">, </span><span class="s1">doctype_string=</span><span class="s3">&quot;DOCTYPE&quot;</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Generate and parse a document with the given doctype.&quot;&quot;&quot;</span>
        <span class="s1">doctype = </span><span class="s3">'&lt;!%s %s&gt;' </span><span class="s1">% (doctype_string</span><span class="s4">, </span><span class="s1">doctype_fragment)</span>
        <span class="s1">markup = doctype + </span><span class="s3">'</span><span class="s4">\n</span><span class="s3">&lt;p&gt;foo&lt;/p&gt;'</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s4">return </span><span class="s1">doctype.encode(</span><span class="s3">&quot;utf8&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s1">soup</span>

    <span class="s4">def </span><span class="s1">test_normal_doctypes(self):</span>
        <span class="s2">&quot;&quot;&quot;Make sure normal, everyday HTML doctypes are handled correctly.&quot;&quot;&quot;</span>
        <span class="s1">self.assertDoctypeHandled(</span><span class="s3">&quot;html&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertDoctypeHandled(</span>
            <span class="s3">'html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;'</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_empty_doctype(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s3">&quot;&lt;!DOCTYPE&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">doctype = soup.contents[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">self.assertEqual(</span><span class="s3">&quot;&quot;</span><span class="s4">, </span><span class="s1">doctype.strip())</span>

    <span class="s4">def </span><span class="s1">test_mixed_case_doctype(self):</span>
        <span class="s0"># A lowercase or mixed-case doctype becomes a Doctype.</span>
        <span class="s4">for </span><span class="s1">doctype_fragment </span><span class="s4">in </span><span class="s1">(</span><span class="s3">&quot;doctype&quot;</span><span class="s4">, </span><span class="s3">&quot;DocType&quot;</span><span class="s1">):</span>
            <span class="s1">doctype_str</span><span class="s4">, </span><span class="s1">soup = self._document_with_doctype(</span>
                <span class="s3">&quot;html&quot;</span><span class="s4">, </span><span class="s1">doctype_fragment</span>
            <span class="s1">)</span>

            <span class="s0"># Make sure a Doctype object was created and that the DOCTYPE</span>
            <span class="s0"># is uppercase.</span>
            <span class="s1">doctype = soup.contents[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">self.assertEqual(doctype.__class__</span><span class="s4">, </span><span class="s1">Doctype)</span>
            <span class="s1">self.assertEqual(doctype</span><span class="s4">, </span><span class="s3">&quot;html&quot;</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(</span>
                <span class="s1">soup.encode(</span><span class="s3">&quot;utf8&quot;</span><span class="s1">)[:len(doctype_str)]</span><span class="s4">,</span>
                <span class="s6">b&quot;&lt;!DOCTYPE html&gt;&quot;</span>
            <span class="s1">)</span>

            <span class="s0"># Make sure that the doctype was correctly associated with the</span>
            <span class="s0"># parse tree and that the rest of the document parsed.</span>
            <span class="s1">self.assertEqual(soup.p.contents[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s3">'foo'</span><span class="s1">)</span>
        
    <span class="s4">def </span><span class="s1">test_public_doctype_with_url(self):</span>
        <span class="s1">doctype = </span><span class="s3">'html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;'</span>
        <span class="s1">self.assertDoctypeHandled(doctype)</span>

    <span class="s4">def </span><span class="s1">test_system_doctype(self):</span>
        <span class="s1">self.assertDoctypeHandled(</span><span class="s3">'foo SYSTEM &quot;http://www.example.com/&quot;'</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_namespaced_system_doctype(self):</span>
        <span class="s0"># We can handle a namespaced doctype with a system ID.</span>
        <span class="s1">self.assertDoctypeHandled(</span><span class="s3">'xsl:stylesheet SYSTEM &quot;htmlent.dtd&quot;'</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_namespaced_public_doctype(self):</span>
        <span class="s0"># Test a namespaced doctype with a public id.</span>
        <span class="s1">self.assertDoctypeHandled(</span><span class="s3">'xsl:stylesheet PUBLIC &quot;htmlent.dtd&quot;'</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_real_xhtml_document(self):</span>
        <span class="s2">&quot;&quot;&quot;A real XHTML document should come out more or less the same as it went in.&quot;&quot;&quot;</span>
        <span class="s1">markup = </span><span class="s6">b&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;&gt; 
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; 
&lt;head&gt;&lt;title&gt;Hello.&lt;/title&gt;&lt;/head&gt; 
&lt;body&gt;Goodbye.&lt;/body&gt; 
&lt;/html&gt;&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.encode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">).replace(</span><span class="s6">b&quot;</span><span class="s4">\n</span><span class="s6">&quot;</span><span class="s4">, </span><span class="s6">b&quot;&quot;</span><span class="s1">)</span><span class="s4">,</span>
            <span class="s1">markup.replace(</span><span class="s6">b&quot;</span><span class="s4">\n</span><span class="s6">&quot;</span><span class="s4">, </span><span class="s6">b&quot;&quot;</span><span class="s1">))</span>

    <span class="s4">def </span><span class="s1">test_namespaced_html(self):</span>
        <span class="s2">&quot;&quot;&quot;When a namespaced XML document is parsed as HTML it should 
        be treated as HTML with weird tag names. 
        &quot;&quot;&quot;</span>
        <span class="s1">markup = </span><span class="s6">b&quot;&quot;&quot;&lt;ns1:foo&gt;content&lt;/ns1:foo&gt;&lt;ns1:foo/&gt;&lt;ns2:foo/&gt;&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">self.assertEqual(</span><span class="s5">2</span><span class="s4">, </span><span class="s1">len(soup.find_all(</span><span class="s3">&quot;ns1:foo&quot;</span><span class="s1">)))</span>
        
    <span class="s4">def </span><span class="s1">test_processing_instruction(self):</span>
        <span class="s0"># We test both Unicode and bytestring to verify that</span>
        <span class="s0"># process_markup correctly sets processing_instruction_class</span>
        <span class="s0"># even when the markup is already Unicode and there is no</span>
        <span class="s0"># need to process anything.</span>
        <span class="s1">markup = </span><span class="s3">&quot;&quot;&quot;&lt;?PITarget PIContent?&gt;&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">self.assertEqual(markup</span><span class="s4">, </span><span class="s1">soup.decode())</span>

        <span class="s1">markup = </span><span class="s6">b&quot;&quot;&quot;&lt;?PITarget PIContent?&gt;&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">self.assertEqual(markup</span><span class="s4">, </span><span class="s1">soup.encode(</span><span class="s3">&quot;utf8&quot;</span><span class="s1">))</span>

    <span class="s4">def </span><span class="s1">test_deepcopy(self):</span>
        <span class="s2">&quot;&quot;&quot;Make sure you can copy the tree builder. 
 
        This is important because the builder is part of a 
        BeautifulSoup object, and we want to be able to copy that. 
        &quot;&quot;&quot;</span>
        <span class="s1">copy.deepcopy(self.default_builder)</span>

    <span class="s4">def </span><span class="s1">test_p_tag_is_never_empty_element(self):</span>
        <span class="s2">&quot;&quot;&quot;A &lt;p&gt; tag is never designated as an empty-element tag. 
 
        Even if the markup shows it as an empty-element tag, it 
        shouldn't be presented that way. 
        &quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(</span><span class="s3">&quot;&lt;p/&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(soup.p.is_empty_element)</span>
        <span class="s1">self.assertEqual(str(soup.p)</span><span class="s4">, </span><span class="s3">&quot;&lt;p&gt;&lt;/p&gt;&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_unclosed_tags_get_closed(self):</span>
        <span class="s2">&quot;&quot;&quot;A tag that's not closed by the end of the document should be closed. 
 
        This applies to all tags except empty-element tags. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.assertSoupEquals(</span><span class="s3">&quot;&lt;p&gt;&quot;</span><span class="s4">, </span><span class="s3">&quot;&lt;p&gt;&lt;/p&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertSoupEquals(</span><span class="s3">&quot;&lt;b&gt;&quot;</span><span class="s4">, </span><span class="s3">&quot;&lt;b&gt;&lt;/b&gt;&quot;</span><span class="s1">)</span>

        <span class="s1">self.assertSoupEquals(</span><span class="s3">&quot;&lt;br&gt;&quot;</span><span class="s4">, </span><span class="s3">&quot;&lt;br/&gt;&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_br_is_always_empty_element_tag(self):</span>
        <span class="s2">&quot;&quot;&quot;A &lt;br&gt; tag is designated as an empty-element tag. 
 
        Some parsers treat &lt;br&gt;&lt;/br&gt; as one &lt;br/&gt; tag, some parsers as 
        two tags, but it should always be an empty-element tag. 
        &quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(</span><span class="s3">&quot;&lt;br&gt;&lt;/br&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(soup.br.is_empty_element)</span>
        <span class="s1">self.assertEqual(str(soup.br)</span><span class="s4">, </span><span class="s3">&quot;&lt;br/&gt;&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_nested_formatting_elements(self):</span>
        <span class="s1">self.assertSoupEquals(</span><span class="s3">&quot;&lt;em&gt;&lt;em&gt;&lt;/em&gt;&lt;/em&gt;&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_double_head(self):</span>
        <span class="s1">html = </span><span class="s3">'''&lt;!DOCTYPE html&gt; 
&lt;html&gt; 
&lt;head&gt; 
&lt;title&gt;Ordinary HEAD element test&lt;/title&gt; 
&lt;/head&gt; 
&lt;script type=&quot;text/javascript&quot;&gt; 
alert(&quot;Help!&quot;); 
&lt;/script&gt; 
&lt;body&gt; 
Hello, world! 
&lt;/body&gt; 
&lt;/html&gt; 
'''</span>
        <span class="s1">soup = self.soup(html)</span>
        <span class="s1">self.assertEqual(</span><span class="s3">&quot;text/javascript&quot;</span><span class="s4">, </span><span class="s1">soup.find(</span><span class="s3">'script'</span><span class="s1">)[</span><span class="s3">'type'</span><span class="s1">])</span>

    <span class="s4">def </span><span class="s1">test_comment(self):</span>
        <span class="s0"># Comments are represented as Comment objects.</span>
        <span class="s1">markup = </span><span class="s3">&quot;&lt;p&gt;foo&lt;!--foobar--&gt;baz&lt;/p&gt;&quot;</span>
        <span class="s1">self.assertSoupEquals(markup)</span>

        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">comment = soup.find(text=</span><span class="s3">&quot;foobar&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(comment.__class__</span><span class="s4">, </span><span class="s1">Comment)</span>

        <span class="s0"># The comment is properly integrated into the tree.</span>
        <span class="s1">foo = soup.find(text=</span><span class="s3">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(comment</span><span class="s4">, </span><span class="s1">foo.next_element)</span>
        <span class="s1">baz = soup.find(text=</span><span class="s3">&quot;baz&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(comment</span><span class="s4">, </span><span class="s1">baz.previous_element)</span>

    <span class="s4">def </span><span class="s1">test_preserved_whitespace_in_pre_and_textarea(self):</span>
        <span class="s2">&quot;&quot;&quot;Whitespace must be preserved in &lt;pre&gt; and &lt;textarea&gt; tags, 
        even if that would mean not prettifying the markup. 
        &quot;&quot;&quot;</span>
        <span class="s1">pre_markup = </span><span class="s3">&quot;&lt;pre&gt;   &lt;/pre&gt;&quot;</span>
        <span class="s1">textarea_markup = </span><span class="s3">&quot;&lt;textarea&gt; woo</span><span class="s4">\n</span><span class="s3">woo  &lt;/textarea&gt;&quot;</span>
        <span class="s1">self.assertSoupEquals(pre_markup)</span>
        <span class="s1">self.assertSoupEquals(textarea_markup)</span>

        <span class="s1">soup = self.soup(pre_markup)</span>
        <span class="s1">self.assertEqual(soup.pre.prettify()</span><span class="s4">, </span><span class="s1">pre_markup)</span>

        <span class="s1">soup = self.soup(textarea_markup)</span>
        <span class="s1">self.assertEqual(soup.textarea.prettify()</span><span class="s4">, </span><span class="s1">textarea_markup)</span>

        <span class="s1">soup = self.soup(</span><span class="s3">&quot;&lt;textarea&gt;&lt;/textarea&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(soup.textarea.prettify()</span><span class="s4">, </span><span class="s3">&quot;&lt;textarea&gt;&lt;/textarea&gt;&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_nested_inline_elements(self):</span>
        <span class="s2">&quot;&quot;&quot;Inline elements can be nested indefinitely.&quot;&quot;&quot;</span>
        <span class="s1">b_tag = </span><span class="s3">&quot;&lt;b&gt;Inside a B tag&lt;/b&gt;&quot;</span>
        <span class="s1">self.assertSoupEquals(b_tag)</span>

        <span class="s1">nested_b_tag = </span><span class="s3">&quot;&lt;p&gt;A &lt;i&gt;nested &lt;b&gt;tag&lt;/b&gt;&lt;/i&gt;&lt;/p&gt;&quot;</span>
        <span class="s1">self.assertSoupEquals(nested_b_tag)</span>

        <span class="s1">double_nested_b_tag = </span><span class="s3">&quot;&lt;p&gt;A &lt;a&gt;doubly &lt;i&gt;nested &lt;b&gt;tag&lt;/b&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;&quot;</span>
        <span class="s1">self.assertSoupEquals(nested_b_tag)</span>

    <span class="s4">def </span><span class="s1">test_nested_block_level_elements(self):</span>
        <span class="s2">&quot;&quot;&quot;Block elements can be nested.&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(</span><span class="s3">'&lt;blockquote&gt;&lt;p&gt;&lt;b&gt;Foo&lt;/b&gt;&lt;/p&gt;&lt;/blockquote&gt;'</span><span class="s1">)</span>
        <span class="s1">blockquote = soup.blockquote</span>
        <span class="s1">self.assertEqual(blockquote.p.b.string</span><span class="s4">, </span><span class="s3">'Foo'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(blockquote.b.string</span><span class="s4">, </span><span class="s3">'Foo'</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_correctly_nested_tables(self):</span>
        <span class="s2">&quot;&quot;&quot;One table can go inside another one.&quot;&quot;&quot;</span>
        <span class="s1">markup = (</span><span class="s3">'&lt;table id=&quot;1&quot;&gt;'</span>
                  <span class="s3">'&lt;tr&gt;'</span>
                  <span class="s3">&quot;&lt;td&gt;Here's another table:&quot;</span>
                  <span class="s3">'&lt;table id=&quot;2&quot;&gt;'</span>
                  <span class="s3">'&lt;tr&gt;&lt;td&gt;foo&lt;/td&gt;&lt;/tr&gt;'</span>
                  <span class="s3">'&lt;/table&gt;&lt;/td&gt;'</span><span class="s1">)</span>

        <span class="s1">self.assertSoupEquals(</span>
            <span class="s1">markup</span><span class="s4">,</span>
            <span class="s3">'&lt;table id=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;Here</span><span class="s4">\'</span><span class="s3">s another table:'</span>
            <span class="s3">'&lt;table id=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;foo&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;'</span>
            <span class="s3">'&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;'</span><span class="s1">)</span>

        <span class="s1">self.assertSoupEquals(</span>
            <span class="s3">&quot;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;Foo&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;&quot;</span>
            <span class="s3">&quot;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Bar&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&quot;</span>
            <span class="s3">&quot;&lt;tfoot&gt;&lt;tr&gt;&lt;td&gt;Baz&lt;/td&gt;&lt;/tr&gt;&lt;/tfoot&gt;&lt;/table&gt;&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_multivalued_attribute_with_whitespace(self):</span>
        <span class="s0"># Whitespace separating the values of a multi-valued attribute</span>
        <span class="s0"># should be ignored.</span>

        <span class="s1">markup = </span><span class="s3">'&lt;div class=&quot; foo bar     &quot;&gt;&lt;/a&gt;'</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">self.assertEqual([</span><span class="s3">'foo'</span><span class="s4">, </span><span class="s3">'bar'</span><span class="s1">]</span><span class="s4">, </span><span class="s1">soup.div[</span><span class="s3">'class'</span><span class="s1">])</span>

        <span class="s0"># If you search by the literal name of the class it's like the whitespace</span>
        <span class="s0"># wasn't there.</span>
        <span class="s1">self.assertEqual(soup.div</span><span class="s4">, </span><span class="s1">soup.find(</span><span class="s3">'div'</span><span class="s4">, </span><span class="s1">class_=</span><span class="s3">&quot;foo bar&quot;</span><span class="s1">))</span>
        
    <span class="s4">def </span><span class="s1">test_deeply_nested_multivalued_attribute(self):</span>
        <span class="s0"># html5lib can set the attributes of the same tag many times</span>
        <span class="s0"># as it rearranges the tree. This has caused problems with</span>
        <span class="s0"># multivalued attributes.</span>
        <span class="s1">markup = </span><span class="s3">'&lt;table&gt;&lt;div&gt;&lt;div class=&quot;css&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/table&gt;'</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">self.assertEqual([</span><span class="s3">&quot;css&quot;</span><span class="s1">]</span><span class="s4">, </span><span class="s1">soup.div.div[</span><span class="s3">'class'</span><span class="s1">])</span>

    <span class="s4">def </span><span class="s1">test_multivalued_attribute_on_html(self):</span>
        <span class="s0"># html5lib uses a different API to set the attributes ot the</span>
        <span class="s0"># &lt;html&gt; tag. This has caused problems with multivalued</span>
        <span class="s0"># attributes.</span>
        <span class="s1">markup = </span><span class="s3">'&lt;html class=&quot;a b&quot;&gt;&lt;/html&gt;'</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">self.assertEqual([</span><span class="s3">&quot;a&quot;</span><span class="s4">, </span><span class="s3">&quot;b&quot;</span><span class="s1">]</span><span class="s4">, </span><span class="s1">soup.html[</span><span class="s3">'class'</span><span class="s1">])</span>

    <span class="s4">def </span><span class="s1">test_angle_brackets_in_attribute_values_are_escaped(self):</span>
        <span class="s1">self.assertSoupEquals(</span><span class="s3">'&lt;a b=&quot;&lt;a&gt;&quot;&gt;&lt;/a&gt;'</span><span class="s4">, </span><span class="s3">'&lt;a b=&quot;&amp;lt;a&amp;gt;&quot;&gt;&lt;/a&gt;'</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_strings_resembling_character_entity_references(self):</span>
        <span class="s0"># &quot;&amp;T&quot; and &quot;&amp;p&quot; look like incomplete character entities, but they are</span>
        <span class="s0"># not.</span>
        <span class="s1">self.assertSoupEquals(</span>
            <span class="s3">&quot;&lt;p&gt;&amp;bull; AT&amp;T is in the s&amp;p 500&lt;/p&gt;&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;&lt;p&gt;</span><span class="s4">\u2022 </span><span class="s3">AT&amp;amp;T is in the s&amp;amp;p 500&lt;/p&gt;&quot;</span>
        <span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_apos_entity(self):</span>
        <span class="s1">self.assertSoupEquals(</span>
            <span class="s3">&quot;&lt;p&gt;Bob&amp;apos;s Bar&lt;/p&gt;&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;&lt;p&gt;Bob's Bar&lt;/p&gt;&quot;</span><span class="s4">,</span>
        <span class="s1">)</span>
        
    <span class="s4">def </span><span class="s1">test_entities_in_foreign_document_encoding(self):</span>
        <span class="s0"># &amp;#147; and &amp;#148; are invalid numeric entities referencing</span>
        <span class="s0"># Windows-1252 characters. &amp;#45; references a character common</span>
        <span class="s0"># to Windows-1252 and Unicode, and &amp;#9731; references a</span>
        <span class="s0"># character only found in Unicode.</span>
        <span class="s0">#</span>
        <span class="s0"># All of these entities should be converted to Unicode</span>
        <span class="s0"># characters.</span>
        <span class="s1">markup = </span><span class="s3">&quot;&lt;p&gt;&amp;#147;Hello&amp;#148; &amp;#45;&amp;#9731;&lt;/p&gt;&quot;</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">self.assertEqual(</span><span class="s3">&quot;Hello -&quot;</span><span class="s4">, </span><span class="s1">soup.p.string)</span>
        
    <span class="s4">def </span><span class="s1">test_entities_in_attributes_converted_to_unicode(self):</span>
        <span class="s1">expect = </span><span class="s3">'&lt;p id=&quot;pi</span><span class="s4">\N{LATIN SMALL LETTER N WITH TILDE}</span><span class="s3">ata&quot;&gt;&lt;/p&gt;'</span>
        <span class="s1">self.assertSoupEquals(</span><span class="s3">'&lt;p id=&quot;pi&amp;#241;ata&quot;&gt;&lt;/p&gt;'</span><span class="s4">, </span><span class="s1">expect)</span>
        <span class="s1">self.assertSoupEquals(</span><span class="s3">'&lt;p id=&quot;pi&amp;#xf1;ata&quot;&gt;&lt;/p&gt;'</span><span class="s4">, </span><span class="s1">expect)</span>
        <span class="s1">self.assertSoupEquals(</span><span class="s3">'&lt;p id=&quot;pi&amp;#Xf1;ata&quot;&gt;&lt;/p&gt;'</span><span class="s4">, </span><span class="s1">expect)</span>
        <span class="s1">self.assertSoupEquals(</span><span class="s3">'&lt;p id=&quot;pi&amp;ntilde;ata&quot;&gt;&lt;/p&gt;'</span><span class="s4">, </span><span class="s1">expect)</span>

    <span class="s4">def </span><span class="s1">test_entities_in_text_converted_to_unicode(self):</span>
        <span class="s1">expect = </span><span class="s3">'&lt;p&gt;pi</span><span class="s4">\N{LATIN SMALL LETTER N WITH TILDE}</span><span class="s3">ata&lt;/p&gt;'</span>
        <span class="s1">self.assertSoupEquals(</span><span class="s3">&quot;&lt;p&gt;pi&amp;#241;ata&lt;/p&gt;&quot;</span><span class="s4">, </span><span class="s1">expect)</span>
        <span class="s1">self.assertSoupEquals(</span><span class="s3">&quot;&lt;p&gt;pi&amp;#xf1;ata&lt;/p&gt;&quot;</span><span class="s4">, </span><span class="s1">expect)</span>
        <span class="s1">self.assertSoupEquals(</span><span class="s3">&quot;&lt;p&gt;pi&amp;#Xf1;ata&lt;/p&gt;&quot;</span><span class="s4">, </span><span class="s1">expect)</span>
        <span class="s1">self.assertSoupEquals(</span><span class="s3">&quot;&lt;p&gt;pi&amp;ntilde;ata&lt;/p&gt;&quot;</span><span class="s4">, </span><span class="s1">expect)</span>

    <span class="s4">def </span><span class="s1">test_quot_entity_converted_to_quotation_mark(self):</span>
        <span class="s1">self.assertSoupEquals(</span><span class="s3">&quot;&lt;p&gt;I said &amp;quot;good day!&amp;quot;&lt;/p&gt;&quot;</span><span class="s4">,</span>
                              <span class="s3">'&lt;p&gt;I said &quot;good day!&quot;&lt;/p&gt;'</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_out_of_range_entity(self):</span>
        <span class="s1">expect = </span><span class="s3">&quot;</span><span class="s4">\N{REPLACEMENT CHARACTER}</span><span class="s3">&quot;</span>
        <span class="s1">self.assertSoupEquals(</span><span class="s3">&quot;&amp;#10000000000000;&quot;</span><span class="s4">, </span><span class="s1">expect)</span>
        <span class="s1">self.assertSoupEquals(</span><span class="s3">&quot;&amp;#x10000000000000;&quot;</span><span class="s4">, </span><span class="s1">expect)</span>
        <span class="s1">self.assertSoupEquals(</span><span class="s3">&quot;&amp;#1000000000;&quot;</span><span class="s4">, </span><span class="s1">expect)</span>
        
    <span class="s4">def </span><span class="s1">test_multipart_strings(self):</span>
        <span class="s2">&quot;Mostly to prevent a recurrence of a bug in the html5lib treebuilder.&quot;</span>
        <span class="s1">soup = self.soup(</span><span class="s3">&quot;&lt;html&gt;&lt;h2&gt;</span><span class="s4">\n</span><span class="s3">foo&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;/html&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span><span class="s3">&quot;p&quot;</span><span class="s4">, </span><span class="s1">soup.h2.string.next_element.name)</span>
        <span class="s1">self.assertEqual(</span><span class="s3">&quot;p&quot;</span><span class="s4">, </span><span class="s1">soup.p.name)</span>
        <span class="s1">self.assertConnectedness(soup)</span>

    <span class="s4">def </span><span class="s1">test_empty_element_tags(self):</span>
        <span class="s2">&quot;&quot;&quot;Verify consistent handling of empty-element tags, 
        no matter how they come in through the markup. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.assertSoupEquals(</span><span class="s3">'&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;'</span><span class="s4">, </span><span class="s3">&quot;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertSoupEquals(</span><span class="s3">'&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;'</span><span class="s4">, </span><span class="s3">&quot;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&quot;</span><span class="s1">)</span>
        
    <span class="s4">def </span><span class="s1">test_head_tag_between_head_and_body(self):</span>
        <span class="s2">&quot;Prevent recurrence of a bug in the html5lib treebuilder.&quot;</span>
        <span class="s1">content = </span><span class="s3">&quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;/head&gt; 
  &lt;link&gt;&lt;/link&gt; 
  &lt;body&gt;foo&lt;/body&gt; 
&lt;/html&gt; 
&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(content)</span>
        <span class="s1">self.assertNotEqual(</span><span class="s4">None, </span><span class="s1">soup.html.body)</span>
        <span class="s1">self.assertConnectedness(soup)</span>

    <span class="s4">def </span><span class="s1">test_multiple_copies_of_a_tag(self):</span>
        <span class="s2">&quot;Prevent recurrence of a bug in the html5lib treebuilder.&quot;</span>
        <span class="s1">content = </span><span class="s3">&quot;&quot;&quot;&lt;!DOCTYPE html&gt; 
&lt;html&gt; 
 &lt;body&gt; 
   &lt;article id=&quot;a&quot; &gt; 
   &lt;div&gt;&lt;a href=&quot;1&quot;&gt;&lt;/div&gt; 
   &lt;footer&gt; 
     &lt;a href=&quot;2&quot;&gt;&lt;/a&gt; 
   &lt;/footer&gt; 
  &lt;/article&gt; 
  &lt;/body&gt; 
&lt;/html&gt; 
&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(content)</span>
        <span class="s1">self.assertConnectedness(soup.article)</span>

    <span class="s4">def </span><span class="s1">test_basic_namespaces(self):</span>
        <span class="s2">&quot;&quot;&quot;Parsers don't need to *understand* namespaces, but at the 
        very least they should not choke on namespaces or lose 
        data.&quot;&quot;&quot;</span>

        <span class="s1">markup = </span><span class="s6">b'&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:mathml=&quot;http://www.w3.org/1998/Math/MathML&quot; xmlns:svg=&quot;http://www.w3.org/2000/svg&quot;&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;mathml:msqrt&gt;4&lt;/mathml:msqrt&gt;&lt;b svg:fill=&quot;red&quot;&gt;&lt;/b&gt;&lt;/body&gt;&lt;/html&gt;'</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">self.assertEqual(markup</span><span class="s4">, </span><span class="s1">soup.encode())</span>
        <span class="s1">html = soup.html</span>
        <span class="s1">self.assertEqual(</span><span class="s3">'http://www.w3.org/1999/xhtml'</span><span class="s4">, </span><span class="s1">soup.html[</span><span class="s3">'xmlns'</span><span class="s1">])</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s3">'http://www.w3.org/1998/Math/MathML'</span><span class="s4">, </span><span class="s1">soup.html[</span><span class="s3">'xmlns:mathml'</span><span class="s1">])</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s3">'http://www.w3.org/2000/svg'</span><span class="s4">, </span><span class="s1">soup.html[</span><span class="s3">'xmlns:svg'</span><span class="s1">])</span>

    <span class="s4">def </span><span class="s1">test_multivalued_attribute_value_becomes_list(self):</span>
        <span class="s1">markup = </span><span class="s6">b'&lt;a class=&quot;foo bar&quot;&gt;'</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">self.assertEqual([</span><span class="s3">'foo'</span><span class="s4">, </span><span class="s3">'bar'</span><span class="s1">]</span><span class="s4">, </span><span class="s1">soup.a[</span><span class="s3">'class'</span><span class="s1">])</span>

    <span class="s0">#</span>
    <span class="s0"># Generally speaking, tests below this point are more tests of</span>
    <span class="s0"># Beautiful Soup than tests of the tree builders. But parsers are</span>
    <span class="s0"># weird, so we run these tests separately for every tree builder</span>
    <span class="s0"># to detect any differences between them.</span>
    <span class="s0">#</span>

    <span class="s4">def </span><span class="s1">test_can_parse_unicode_document(self):</span>
        <span class="s0"># A seemingly innocuous document... but it's in Unicode! And</span>
        <span class="s0"># it contains characters that can't be represented in the</span>
        <span class="s0"># encoding found in the  declaration! The horror!</span>
        <span class="s1">markup = </span><span class="s3">'&lt;html&gt;&lt;head&gt;&lt;meta encoding=&quot;euc-jp&quot;&gt;&lt;/head&gt;&lt;body&gt;Sacr</span><span class="s4">\N{LATIN SMALL LETTER E WITH ACUTE} </span><span class="s3">bleu!&lt;/body&gt;'</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">self.assertEqual(</span><span class="s3">'Sacr</span><span class="s4">\xe9 </span><span class="s3">bleu!'</span><span class="s4">, </span><span class="s1">soup.body.string)</span>

    <span class="s4">def </span><span class="s1">test_soupstrainer(self):</span>
        <span class="s2">&quot;&quot;&quot;Parsers should be able to work with SoupStrainers.&quot;&quot;&quot;</span>
        <span class="s1">strainer = SoupStrainer(</span><span class="s3">&quot;b&quot;</span><span class="s1">)</span>
        <span class="s1">soup = self.soup(</span><span class="s3">&quot;A &lt;b&gt;bold&lt;/b&gt; &lt;meta/&gt; &lt;i&gt;statement&lt;/i&gt;&quot;</span><span class="s4">,</span>
                         <span class="s1">parse_only=strainer)</span>
        <span class="s1">self.assertEqual(soup.decode()</span><span class="s4">, </span><span class="s3">&quot;&lt;b&gt;bold&lt;/b&gt;&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_single_quote_attribute_values_become_double_quotes(self):</span>
        <span class="s1">self.assertSoupEquals(</span><span class="s3">&quot;&lt;foo attr='bar'&gt;&lt;/foo&gt;&quot;</span><span class="s4">,</span>
                              <span class="s3">'&lt;foo attr=&quot;bar&quot;&gt;&lt;/foo&gt;'</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_attribute_values_with_nested_quotes_are_left_alone(self):</span>
        <span class="s1">text = </span><span class="s3">&quot;&quot;&quot;&lt;foo attr='bar &quot;brawls&quot; happen'&gt;a&lt;/foo&gt;&quot;&quot;&quot;</span>
        <span class="s1">self.assertSoupEquals(text)</span>

    <span class="s4">def </span><span class="s1">test_attribute_values_with_double_nested_quotes_get_quoted(self):</span>
        <span class="s1">text = </span><span class="s3">&quot;&quot;&quot;&lt;foo attr='bar &quot;brawls&quot; happen'&gt;a&lt;/foo&gt;&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(text)</span>
        <span class="s1">soup.foo[</span><span class="s3">'attr'</span><span class="s1">] = </span><span class="s3">'Brawls happen at &quot;Bob</span><span class="s4">\'</span><span class="s3">s Bar&quot;'</span>
        <span class="s1">self.assertSoupEquals(</span>
            <span class="s1">soup.foo.decode()</span><span class="s4">,</span>
            <span class="s3">&quot;&quot;&quot;&lt;foo attr=&quot;Brawls happen at &amp;quot;Bob</span><span class="s4">\'</span><span class="s3">s Bar&amp;quot;&quot;&gt;a&lt;/foo&gt;&quot;&quot;&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_ampersand_in_attribute_value_gets_escaped(self):</span>
        <span class="s1">self.assertSoupEquals(</span><span class="s3">'&lt;this is=&quot;really messed up &amp; stuff&quot;&gt;&lt;/this&gt;'</span><span class="s4">,</span>
                              <span class="s3">'&lt;this is=&quot;really messed up &amp;amp; stuff&quot;&gt;&lt;/this&gt;'</span><span class="s1">)</span>

        <span class="s1">self.assertSoupEquals(</span>
            <span class="s3">'&lt;a href=&quot;http://example.org?a=1&amp;b=2;3&quot;&gt;foo&lt;/a&gt;'</span><span class="s4">,</span>
            <span class="s3">'&lt;a href=&quot;http://example.org?a=1&amp;amp;b=2;3&quot;&gt;foo&lt;/a&gt;'</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_escaped_ampersand_in_attribute_value_is_left_alone(self):</span>
        <span class="s1">self.assertSoupEquals(</span><span class="s3">'&lt;a href=&quot;http://example.org?a=1&amp;amp;b=2;3&quot;&gt;&lt;/a&gt;'</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_entities_in_strings_converted_during_parsing(self):</span>
        <span class="s0"># Both XML and HTML entities are converted to Unicode characters</span>
        <span class="s0"># during parsing.</span>
        <span class="s1">text = </span><span class="s3">&quot;&lt;p&gt;&amp;lt;&amp;lt;sacr&amp;eacute;&amp;#32;bleu!&amp;gt;&amp;gt;&lt;/p&gt;&quot;</span>
        <span class="s1">expected = </span><span class="s3">&quot;&lt;p&gt;&amp;lt;&amp;lt;sacr</span><span class="s4">\N{LATIN SMALL LETTER E WITH ACUTE} </span><span class="s3">bleu!&amp;gt;&amp;gt;&lt;/p&gt;&quot;</span>
        <span class="s1">self.assertSoupEquals(text</span><span class="s4">, </span><span class="s1">expected)</span>

    <span class="s4">def </span><span class="s1">test_smart_quotes_converted_on_the_way_in(self):</span>
        <span class="s0"># Microsoft smart quotes are converted to Unicode characters during</span>
        <span class="s0"># parsing.</span>
        <span class="s1">quote = </span><span class="s6">b&quot;&lt;p&gt;</span><span class="s4">\x91</span><span class="s6">Foo</span><span class="s4">\x92</span><span class="s6">&lt;/p&gt;&quot;</span>
        <span class="s1">soup = self.soup(quote)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.p.string</span><span class="s4">,</span>
            <span class="s3">&quot;</span><span class="s4">\N{LEFT SINGLE QUOTATION MARK}</span><span class="s3">Foo</span><span class="s4">\N{RIGHT SINGLE QUOTATION MARK}</span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_non_breaking_spaces_converted_on_the_way_in(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s3">&quot;&lt;a&gt;&amp;nbsp;&amp;nbsp;&lt;/a&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(soup.a.string</span><span class="s4">, </span><span class="s3">&quot;</span><span class="s4">\N{NO-BREAK SPACE}</span><span class="s3">&quot; </span><span class="s1">* </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_entities_converted_on_the_way_out(self):</span>
        <span class="s1">text = </span><span class="s3">&quot;&lt;p&gt;&amp;lt;&amp;lt;sacr&amp;eacute;&amp;#32;bleu!&amp;gt;&amp;gt;&lt;/p&gt;&quot;</span>
        <span class="s1">expected = </span><span class="s3">&quot;&lt;p&gt;&amp;lt;&amp;lt;sacr</span><span class="s4">\N{LATIN SMALL LETTER E WITH ACUTE} </span><span class="s3">bleu!&amp;gt;&amp;gt;&lt;/p&gt;&quot;</span><span class="s1">.encode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span>
        <span class="s1">soup = self.soup(text)</span>
        <span class="s1">self.assertEqual(soup.p.encode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s1">expected)</span>

    <span class="s4">def </span><span class="s1">test_real_iso_latin_document(self):</span>
        <span class="s0"># Smoke test of interrelated functionality, using an</span>
        <span class="s0"># easy-to-understand document.</span>

        <span class="s0"># Here it is in Unicode. Note that it claims to be in ISO-Latin-1.</span>
        <span class="s1">unicode_html = </span><span class="s3">'&lt;html&gt;&lt;head&gt;&lt;meta content=&quot;text/html; charset=ISO-Latin-1&quot; http-equiv=&quot;Content-type&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Sacr</span><span class="s4">\N{LATIN SMALL LETTER E WITH ACUTE} </span><span class="s3">bleu!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'</span>

        <span class="s0"># That's because we're going to encode it into ISO-Latin-1, and use</span>
        <span class="s0"># that to test.</span>
        <span class="s1">iso_latin_html = unicode_html.encode(</span><span class="s3">&quot;iso-8859-1&quot;</span><span class="s1">)</span>

        <span class="s0"># Parse the ISO-Latin-1 HTML.</span>
        <span class="s1">soup = self.soup(iso_latin_html)</span>
        <span class="s0"># Encode it to UTF-8.</span>
        <span class="s1">result = soup.encode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span>

        <span class="s0"># What do we expect the result to look like? Well, it would</span>
        <span class="s0"># look like unicode_html, except that the META tag would say</span>
        <span class="s0"># UTF-8 instead of ISO-Latin-1.</span>
        <span class="s1">expected = unicode_html.replace(</span><span class="s3">&quot;ISO-Latin-1&quot;</span><span class="s4">, </span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span>

        <span class="s0"># And, of course, it would be in UTF-8, not Unicode.</span>
        <span class="s1">expected = expected.encode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span>

        <span class="s0"># Ta-da!</span>
        <span class="s1">self.assertEqual(result</span><span class="s4">, </span><span class="s1">expected)</span>

    <span class="s4">def </span><span class="s1">test_real_shift_jis_document(self):</span>
        <span class="s0"># Smoke test to make sure the parser can handle a document in</span>
        <span class="s0"># Shift-JIS encoding, without choking.</span>
        <span class="s1">shift_jis_html = (</span>
            <span class="s6">b'&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;pre&gt;'</span>
            <span class="s6">b'</span><span class="s4">\x82\xb1\x82\xea\x82\xcd</span><span class="s6">Shift-JIS</span><span class="s4">\x82\xc5\x83</span><span class="s6">R</span><span class="s4">\x81</span><span class="s6">[</span><span class="s4">\x83</span><span class="s6">f'</span>
            <span class="s6">b'</span><span class="s4">\x83</span><span class="s6">B</span><span class="s4">\x83\x93\x83</span><span class="s6">O</span><span class="s4">\x82\xb3\x82\xea\x82\xbd\x93\xfa\x96</span><span class="s6">{</span><span class="s4">\x8c</span><span class="s6">'</span>
            <span class="s6">b'</span><span class="s4">\xea\x82\xcc\x83</span><span class="s6">t</span><span class="s4">\x83</span><span class="s6">@</span><span class="s4">\x83</span><span class="s6">C</span><span class="s4">\x83\x8b\x82\xc5\x82\xb7\x81</span><span class="s6">B'</span>
            <span class="s6">b'&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;'</span><span class="s1">)</span>
        <span class="s1">unicode_html = shift_jis_html.decode(</span><span class="s3">&quot;shift-jis&quot;</span><span class="s1">)</span>
        <span class="s1">soup = self.soup(unicode_html)</span>

        <span class="s0"># Make sure the parse tree is correctly encoded to various</span>
        <span class="s0"># encodings.</span>
        <span class="s1">self.assertEqual(soup.encode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s1">unicode_html.encode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(soup.encode(</span><span class="s3">&quot;euc_jp&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s1">unicode_html.encode(</span><span class="s3">&quot;euc_jp&quot;</span><span class="s1">))</span>

    <span class="s4">def </span><span class="s1">test_real_hebrew_document(self):</span>
        <span class="s0"># A real-world test to make sure we can convert ISO-8859-9 (a</span>
        <span class="s0"># Hebrew encoding) to UTF-8.</span>
        <span class="s1">hebrew_document = </span><span class="s6">b'&lt;html&gt;&lt;head&gt;&lt;title&gt;Hebrew (ISO 8859-8) in Visual Directionality&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hebrew (ISO 8859-8) in Visual Directionality&lt;/h1&gt;</span><span class="s4">\xed\xe5\xec\xf9</span><span class="s6">&lt;/body&gt;&lt;/html&gt;'</span>
        <span class="s1">soup = self.soup(</span>
            <span class="s1">hebrew_document</span><span class="s4">, </span><span class="s1">from_encoding=</span><span class="s3">&quot;iso8859-8&quot;</span><span class="s1">)</span>
        <span class="s0"># Some tree builders call it iso8859-8, others call it iso-8859-9.</span>
        <span class="s0"># That's not a difference we really care about.</span>
        <span class="s4">assert </span><span class="s1">soup.original_encoding </span><span class="s4">in </span><span class="s1">(</span><span class="s3">'iso8859-8'</span><span class="s4">, </span><span class="s3">'iso-8859-8'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.encode(</span><span class="s3">'utf-8'</span><span class="s1">)</span><span class="s4">,</span>
            <span class="s1">hebrew_document.decode(</span><span class="s3">&quot;iso8859-8&quot;</span><span class="s1">).encode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">))</span>

    <span class="s4">def </span><span class="s1">test_meta_tag_reflects_current_encoding(self):</span>
        <span class="s0"># Here's the &lt;meta&gt; tag saying that a document is</span>
        <span class="s0"># encoded in Shift-JIS.</span>
        <span class="s1">meta_tag = (</span><span class="s3">'&lt;meta content=&quot;text/html; charset=x-sjis&quot; '</span>
                    <span class="s3">'http-equiv=&quot;Content-type&quot;/&gt;'</span><span class="s1">)</span>

        <span class="s0"># Here's a document incorporating that meta tag.</span>
        <span class="s1">shift_jis_html = (</span>
            <span class="s3">'&lt;html&gt;&lt;head&gt;</span><span class="s4">\n</span><span class="s3">%s</span><span class="s4">\n</span><span class="s3">'</span>
            <span class="s3">'&lt;meta http-equiv=&quot;Content-language&quot; content=&quot;ja&quot;/&gt;'</span>
            <span class="s3">'&lt;/head&gt;&lt;body&gt;Shift-JIS markup goes here.'</span><span class="s1">) % meta_tag</span>
        <span class="s1">soup = self.soup(shift_jis_html)</span>

        <span class="s0"># Parse the document, and the charset is seemingly unaffected.</span>
        <span class="s1">parsed_meta = soup.find(</span><span class="s3">'meta'</span><span class="s4">, </span><span class="s1">{</span><span class="s3">'http-equiv'</span><span class="s1">: </span><span class="s3">'Content-type'</span><span class="s1">})</span>
        <span class="s1">content = parsed_meta[</span><span class="s3">'content'</span><span class="s1">]</span>
        <span class="s1">self.assertEqual(</span><span class="s3">'text/html; charset=x-sjis'</span><span class="s4">, </span><span class="s1">content)</span>

        <span class="s0"># But that value is actually a ContentMetaAttributeValue object.</span>
        <span class="s1">self.assertTrue(isinstance(content</span><span class="s4">, </span><span class="s1">ContentMetaAttributeValue))</span>

        <span class="s0"># And it will take on a value that reflects its current</span>
        <span class="s0"># encoding.</span>
        <span class="s1">self.assertEqual(</span><span class="s3">'text/html; charset=utf8'</span><span class="s4">, </span><span class="s1">content.encode(</span><span class="s3">&quot;utf8&quot;</span><span class="s1">))</span>

        <span class="s0"># For the rest of the story, see TestSubstitutions in</span>
        <span class="s0"># test_tree.py.</span>

    <span class="s4">def </span><span class="s1">test_html5_style_meta_tag_reflects_current_encoding(self):</span>
        <span class="s0"># Here's the &lt;meta&gt; tag saying that a document is</span>
        <span class="s0"># encoded in Shift-JIS.</span>
        <span class="s1">meta_tag = (</span><span class="s3">'&lt;meta id=&quot;encoding&quot; charset=&quot;x-sjis&quot; /&gt;'</span><span class="s1">)</span>

        <span class="s0"># Here's a document incorporating that meta tag.</span>
        <span class="s1">shift_jis_html = (</span>
            <span class="s3">'&lt;html&gt;&lt;head&gt;</span><span class="s4">\n</span><span class="s3">%s</span><span class="s4">\n</span><span class="s3">'</span>
            <span class="s3">'&lt;meta http-equiv=&quot;Content-language&quot; content=&quot;ja&quot;/&gt;'</span>
            <span class="s3">'&lt;/head&gt;&lt;body&gt;Shift-JIS markup goes here.'</span><span class="s1">) % meta_tag</span>
        <span class="s1">soup = self.soup(shift_jis_html)</span>

        <span class="s0"># Parse the document, and the charset is seemingly unaffected.</span>
        <span class="s1">parsed_meta = soup.find(</span><span class="s3">'meta'</span><span class="s4">, </span><span class="s1">id=</span><span class="s3">&quot;encoding&quot;</span><span class="s1">)</span>
        <span class="s1">charset = parsed_meta[</span><span class="s3">'charset'</span><span class="s1">]</span>
        <span class="s1">self.assertEqual(</span><span class="s3">'x-sjis'</span><span class="s4">, </span><span class="s1">charset)</span>

        <span class="s0"># But that value is actually a CharsetMetaAttributeValue object.</span>
        <span class="s1">self.assertTrue(isinstance(charset</span><span class="s4">, </span><span class="s1">CharsetMetaAttributeValue))</span>

        <span class="s0"># And it will take on a value that reflects its current</span>
        <span class="s0"># encoding.</span>
        <span class="s1">self.assertEqual(</span><span class="s3">'utf8'</span><span class="s4">, </span><span class="s1">charset.encode(</span><span class="s3">&quot;utf8&quot;</span><span class="s1">))</span>

    <span class="s4">def </span><span class="s1">test_python_specific_encodings_not_used_in_charset(self):</span>
        <span class="s0"># You can encode an HTML document using a Python-specific</span>
        <span class="s0"># encoding, but that encoding won't be mentioned _inside_ the</span>
        <span class="s0"># resulting document. Instead, the document will appear to</span>
        <span class="s0"># have no encoding.</span>
        <span class="s4">for </span><span class="s1">markup </span><span class="s4">in </span><span class="s1">[</span>
            <span class="s6">b'&lt;meta charset=&quot;utf8&quot;&gt;&lt;/head&gt;'</span>
            <span class="s6">b'&lt;meta id=&quot;encoding&quot; charset=&quot;utf-8&quot; /&gt;'</span>
        <span class="s1">]:</span>
            <span class="s1">soup = self.soup(markup)</span>
            <span class="s4">for </span><span class="s1">encoding </span><span class="s4">in </span><span class="s1">PYTHON_SPECIFIC_ENCODINGS:</span>
                <span class="s4">if </span><span class="s1">encoding </span><span class="s4">in </span><span class="s1">(</span>
                    <span class="s3">'idna'</span><span class="s4">, </span><span class="s3">'mbcs'</span><span class="s4">, </span><span class="s3">'oem'</span><span class="s4">, </span><span class="s3">'undefined'</span><span class="s4">,</span>
                    <span class="s3">'string_escape'</span><span class="s4">, </span><span class="s3">'string-escape'</span>
                <span class="s1">):</span>
                    <span class="s0"># For one reason or another, these will raise an</span>
                    <span class="s0"># exception if we actually try to use them, so don't</span>
                    <span class="s0"># bother.</span>
                    <span class="s4">continue</span>
                <span class="s1">encoded = soup.encode(encoding)</span>
                <span class="s4">assert </span><span class="s6">b'meta charset=&quot;&quot;' </span><span class="s4">in </span><span class="s1">encoded</span>
                <span class="s4">assert </span><span class="s1">encoding.encode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">) </span><span class="s4">not in </span><span class="s1">encoded</span>
        
    <span class="s4">def </span><span class="s1">test_tag_with_no_attributes_can_have_attributes_added(self):</span>
        <span class="s1">data = self.soup(</span><span class="s3">&quot;&lt;a&gt;text&lt;/a&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">data.a[</span><span class="s3">'foo'</span><span class="s1">] = </span><span class="s3">'bar'</span>
        <span class="s1">self.assertEqual(</span><span class="s3">'&lt;a foo=&quot;bar&quot;&gt;text&lt;/a&gt;'</span><span class="s4">, </span><span class="s1">data.a.decode())</span>

    <span class="s4">def </span><span class="s1">test_closing_tag_with_no_opening_tag(self):</span>
        <span class="s0"># Without BeautifulSoup.open_tag_counter, the &lt;/span&gt; tag will</span>
        <span class="s0"># cause _popToTag to be called over and over again as we look</span>
        <span class="s0"># for a &lt;span&gt; tag that wasn't there. The result is that 'text2'</span>
        <span class="s0"># will show up outside the body of the document.</span>
        <span class="s1">soup = self.soup(</span><span class="s3">&quot;&lt;body&gt;&lt;div&gt;&lt;p&gt;text1&lt;/p&gt;&lt;/span&gt;text2&lt;/div&gt;&lt;/body&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s3">&quot;&lt;body&gt;&lt;div&gt;&lt;p&gt;text1&lt;/p&gt;text2&lt;/div&gt;&lt;/body&gt;&quot;</span><span class="s4">, </span><span class="s1">soup.body.decode()</span>
        <span class="s1">)</span>
        
    <span class="s4">def </span><span class="s1">test_worst_case(self):</span>
        <span class="s2">&quot;&quot;&quot;Test the worst case (currently) for linking issues.&quot;&quot;&quot;</span>

        <span class="s1">soup = self.soup(BAD_DOCUMENT)</span>
        <span class="s1">self.linkage_validator(soup)</span>


<span class="s4">class </span><span class="s1">XMLTreeBuilderSmokeTest(object):</span>

    <span class="s4">def </span><span class="s1">test_pickle_and_unpickle_identity(self):</span>
        <span class="s0"># Pickling a tree, then unpickling it, yields a tree identical</span>
        <span class="s0"># to the original.</span>
        <span class="s1">tree = self.soup(</span><span class="s3">&quot;&lt;a&gt;&lt;b&gt;foo&lt;/a&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">dumped = pickle.dumps(tree</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">loaded = pickle.loads(dumped)</span>
        <span class="s1">self.assertEqual(loaded.__class__</span><span class="s4">, </span><span class="s1">BeautifulSoup)</span>
        <span class="s1">self.assertEqual(loaded.decode()</span><span class="s4">, </span><span class="s1">tree.decode())</span>

    <span class="s4">def </span><span class="s1">test_docstring_generated(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s3">&quot;&lt;root/&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.encode()</span><span class="s4">, </span><span class="s6">b'&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><span class="s4">\n</span><span class="s6">&lt;root/&gt;'</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_xml_declaration(self):</span>
        <span class="s1">markup = </span><span class="s6">b&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf8&quot;?&gt;</span><span class="s4">\n</span><span class="s6">&lt;foo/&gt;&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">self.assertEqual(markup</span><span class="s4">, </span><span class="s1">soup.encode(</span><span class="s3">&quot;utf8&quot;</span><span class="s1">))</span>

    <span class="s4">def </span><span class="s1">test_python_specific_encodings_not_used_in_xml_declaration(self):</span>
        <span class="s0"># You can encode an XML document using a Python-specific</span>
        <span class="s0"># encoding, but that encoding won't be mentioned _inside_ the</span>
        <span class="s0"># resulting document.</span>
        <span class="s1">markup = </span><span class="s6">b&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;</span><span class="s4">\n</span><span class="s6">&lt;foo/&gt;&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s4">for </span><span class="s1">encoding </span><span class="s4">in </span><span class="s1">PYTHON_SPECIFIC_ENCODINGS:</span>
            <span class="s4">if </span><span class="s1">encoding </span><span class="s4">in </span><span class="s1">(</span>
                <span class="s3">'idna'</span><span class="s4">, </span><span class="s3">'mbcs'</span><span class="s4">, </span><span class="s3">'oem'</span><span class="s4">, </span><span class="s3">'undefined'</span><span class="s4">,</span>
                <span class="s3">'string_escape'</span><span class="s4">, </span><span class="s3">'string-escape'</span>
            <span class="s1">):</span>
                <span class="s0"># For one reason or another, these will raise an</span>
                <span class="s0"># exception if we actually try to use them, so don't</span>
                <span class="s0"># bother.</span>
                <span class="s4">continue</span>
            <span class="s1">encoded = soup.encode(encoding)</span>
            <span class="s4">assert </span><span class="s6">b'&lt;?xml version=&quot;1.0&quot;?&gt;' </span><span class="s4">in </span><span class="s1">encoded</span>
            <span class="s4">assert </span><span class="s1">encoding.encode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">) </span><span class="s4">not in </span><span class="s1">encoded</span>

    <span class="s4">def </span><span class="s1">test_processing_instruction(self):</span>
        <span class="s1">markup = </span><span class="s6">b&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf8&quot;?&gt;</span><span class="s4">\n</span><span class="s6">&lt;?PITarget PIContent?&gt;&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">self.assertEqual(markup</span><span class="s4">, </span><span class="s1">soup.encode(</span><span class="s3">&quot;utf8&quot;</span><span class="s1">))</span>

    <span class="s4">def </span><span class="s1">test_real_xhtml_document(self):</span>
        <span class="s2">&quot;&quot;&quot;A real XHTML document should come out *exactly* the same as it went in.&quot;&quot;&quot;</span>
        <span class="s1">markup = </span><span class="s6">b&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;&gt; 
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; 
&lt;head&gt;&lt;title&gt;Hello.&lt;/title&gt;&lt;/head&gt; 
&lt;body&gt;Goodbye.&lt;/body&gt; 
&lt;/html&gt;&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.encode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s1">markup)</span>
       
    <span class="s4">def </span><span class="s1">test_nested_namespaces(self):</span>
        <span class="s1">doc = </span><span class="s6">b&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt; 
&lt;parent xmlns=&quot;http://ns1/&quot;&gt; 
&lt;child xmlns=&quot;http://ns2/&quot; xmlns:ns3=&quot;http://ns3/&quot;&gt; 
&lt;grandchild ns3:attr=&quot;value&quot; xmlns=&quot;http://ns4/&quot;/&gt; 
&lt;/child&gt; 
&lt;/parent&gt;&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(doc)</span>
        <span class="s1">self.assertEqual(doc</span><span class="s4">, </span><span class="s1">soup.encode())</span>
        
    <span class="s4">def </span><span class="s1">test_formatter_processes_script_tag_for_xml_documents(self):</span>
        <span class="s1">doc = </span><span class="s3">&quot;&quot;&quot; 
  &lt;script type=&quot;text/javascript&quot;&gt; 
  &lt;/script&gt; 
&quot;&quot;&quot;</span>
        <span class="s1">soup = BeautifulSoup(doc</span><span class="s4">, </span><span class="s3">&quot;lxml-xml&quot;</span><span class="s1">)</span>
        <span class="s0"># lxml would have stripped this while parsing, but we can add</span>
        <span class="s0"># it later.</span>
        <span class="s1">soup.script.string = </span><span class="s3">'console.log(&quot;&lt; &lt; hey &gt; &gt; &quot;);'</span>
        <span class="s1">encoded = soup.encode()</span>
        <span class="s1">self.assertTrue(</span><span class="s6">b&quot;&amp;lt; &amp;lt; hey &amp;gt; &amp;gt;&quot; </span><span class="s4">in </span><span class="s1">encoded)</span>

    <span class="s4">def </span><span class="s1">test_can_parse_unicode_document(self):</span>
        <span class="s1">markup = </span><span class="s3">'&lt;?xml version=&quot;1.0&quot; encoding=&quot;euc-jp&quot;&gt;&lt;root&gt;Sacr</span><span class="s4">\N{LATIN SMALL LETTER E WITH ACUTE} </span><span class="s3">bleu!&lt;/root&gt;'</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">self.assertEqual(</span><span class="s3">'Sacr</span><span class="s4">\xe9 </span><span class="s3">bleu!'</span><span class="s4">, </span><span class="s1">soup.root.string)</span>

    <span class="s4">def </span><span class="s1">test_popping_namespaced_tag(self):</span>
        <span class="s1">markup = </span><span class="s3">'&lt;rss xmlns:dc=&quot;foo&quot;&gt;&lt;dc:creator&gt;b&lt;/dc:creator&gt;&lt;dc:date&gt;2012-07-02T20:33:42Z&lt;/dc:date&gt;&lt;dc:rights&gt;c&lt;/dc:rights&gt;&lt;image&gt;d&lt;/image&gt;&lt;/rss&gt;'</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">str(soup.rss)</span><span class="s4">, </span><span class="s1">markup)</span>

    <span class="s4">def </span><span class="s1">test_docstring_includes_correct_encoding(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s3">&quot;&lt;root/&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.encode(</span><span class="s3">&quot;latin1&quot;</span><span class="s1">)</span><span class="s4">,</span>
            <span class="s6">b'&lt;?xml version=&quot;1.0&quot; encoding=&quot;latin1&quot;?&gt;</span><span class="s4">\n</span><span class="s6">&lt;root/&gt;'</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_large_xml_document(self):</span>
        <span class="s2">&quot;&quot;&quot;A large XML document should come out the same as it went in.&quot;&quot;&quot;</span>
        <span class="s1">markup = (</span><span class="s6">b'&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><span class="s4">\n</span><span class="s6">&lt;root&gt;'</span>
                  <span class="s1">+ </span><span class="s6">b'0' </span><span class="s1">* (</span><span class="s5">2</span><span class="s1">**</span><span class="s5">12</span><span class="s1">)</span>
                  <span class="s1">+ </span><span class="s6">b'&lt;/root&gt;'</span><span class="s1">)</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">self.assertEqual(soup.encode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s1">markup)</span>


    <span class="s4">def </span><span class="s1">test_tags_are_empty_element_if_and_only_if_they_are_empty(self):</span>
        <span class="s1">self.assertSoupEquals(</span><span class="s3">&quot;&lt;p&gt;&quot;</span><span class="s4">, </span><span class="s3">&quot;&lt;p/&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertSoupEquals(</span><span class="s3">&quot;&lt;p&gt;foo&lt;/p&gt;&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_namespaces_are_preserved(self):</span>
        <span class="s1">markup = </span><span class="s3">'&lt;root xmlns:a=&quot;http://example.com/&quot; xmlns:b=&quot;http://example.net/&quot;&gt;&lt;a:foo&gt;This tag is in the a namespace&lt;/a:foo&gt;&lt;b:foo&gt;This tag is in the b namespace&lt;/b:foo&gt;&lt;/root&gt;'</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">root = soup.root</span>
        <span class="s1">self.assertEqual(</span><span class="s3">&quot;http://example.com/&quot;</span><span class="s4">, </span><span class="s1">root[</span><span class="s3">'xmlns:a'</span><span class="s1">])</span>
        <span class="s1">self.assertEqual(</span><span class="s3">&quot;http://example.net/&quot;</span><span class="s4">, </span><span class="s1">root[</span><span class="s3">'xmlns:b'</span><span class="s1">])</span>

    <span class="s4">def </span><span class="s1">test_closing_namespaced_tag(self):</span>
        <span class="s1">markup = </span><span class="s3">'&lt;p xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot;&gt;&lt;dc:date&gt;20010504&lt;/dc:date&gt;&lt;/p&gt;'</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">self.assertEqual(str(soup.p)</span><span class="s4">, </span><span class="s1">markup)</span>

    <span class="s4">def </span><span class="s1">test_namespaced_attributes(self):</span>
        <span class="s1">markup = </span><span class="s3">'&lt;foo xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;&lt;bar xsi:schemaLocation=&quot;http://www.example.com&quot;/&gt;&lt;/foo&gt;'</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">self.assertEqual(str(soup.foo)</span><span class="s4">, </span><span class="s1">markup)</span>

    <span class="s4">def </span><span class="s1">test_namespaced_attributes_xml_namespace(self):</span>
        <span class="s1">markup = </span><span class="s3">'&lt;foo xml:lang=&quot;fr&quot;&gt;bar&lt;/foo&gt;'</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">self.assertEqual(str(soup.foo)</span><span class="s4">, </span><span class="s1">markup)</span>

    <span class="s4">def </span><span class="s1">test_find_by_prefixed_name(self):</span>
        <span class="s1">doc = </span><span class="s3">&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 
&lt;Document xmlns=&quot;http://example.com/ns0&quot; 
    xmlns:ns1=&quot;http://example.com/ns1&quot; 
    xmlns:ns2=&quot;http://example.com/ns2&quot; 
    &lt;ns1:tag&gt;foo&lt;/ns1:tag&gt; 
    &lt;ns1:tag&gt;bar&lt;/ns1:tag&gt; 
    &lt;ns2:tag key=&quot;value&quot;&gt;baz&lt;/ns2:tag&gt; 
&lt;/Document&gt; 
&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(doc)</span>

        <span class="s0"># There are three &lt;tag&gt; tags.</span>
        <span class="s1">self.assertEqual(</span><span class="s5">3</span><span class="s4">, </span><span class="s1">len(soup.find_all(</span><span class="s3">'tag'</span><span class="s1">)))</span>

        <span class="s0"># But two of them are ns1:tag and one of them is ns2:tag.</span>
        <span class="s1">self.assertEqual(</span><span class="s5">2</span><span class="s4">, </span><span class="s1">len(soup.find_all(</span><span class="s3">'ns1:tag'</span><span class="s1">)))</span>
        <span class="s1">self.assertEqual(</span><span class="s5">1</span><span class="s4">, </span><span class="s1">len(soup.find_all(</span><span class="s3">'ns2:tag'</span><span class="s1">)))</span>
        
        <span class="s1">self.assertEqual(</span><span class="s5">1</span><span class="s4">, </span><span class="s1">len(soup.find_all(</span><span class="s3">'ns2:tag'</span><span class="s4">, </span><span class="s1">key=</span><span class="s3">'value'</span><span class="s1">)))</span>
        <span class="s1">self.assertEqual(</span><span class="s5">3</span><span class="s4">, </span><span class="s1">len(soup.find_all([</span><span class="s3">'ns1:tag'</span><span class="s4">, </span><span class="s3">'ns2:tag'</span><span class="s1">])))</span>
        
    <span class="s4">def </span><span class="s1">test_copy_tag_preserves_namespace(self):</span>
        <span class="s1">xml = </span><span class="s3">&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt; 
&lt;w:document xmlns:w=&quot;http://example.com/ns0&quot;/&gt;&quot;&quot;&quot;</span>
    
        <span class="s1">soup = self.soup(xml)</span>
        <span class="s1">tag = soup.document</span>
        <span class="s1">duplicate = copy.copy(tag)</span>

        <span class="s0"># The two tags have the same namespace prefix.</span>
        <span class="s1">self.assertEqual(tag.prefix</span><span class="s4">, </span><span class="s1">duplicate.prefix)</span>

    <span class="s4">def </span><span class="s1">test_worst_case(self):</span>
        <span class="s2">&quot;&quot;&quot;Test the worst case (currently) for linking issues.&quot;&quot;&quot;</span>

        <span class="s1">soup = self.soup(BAD_DOCUMENT)</span>
        <span class="s1">self.linkage_validator(soup)</span>


<span class="s4">class </span><span class="s1">HTML5TreeBuilderSmokeTest(HTMLTreeBuilderSmokeTest):</span>
    <span class="s2">&quot;&quot;&quot;Smoke test for a tree builder that supports HTML5.&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">test_real_xhtml_document(self):</span>
        <span class="s0"># Since XHTML is not HTML5, HTML5 parsers are not tested to handle</span>
        <span class="s0"># XHTML documents in any particular way.</span>
        <span class="s4">pass</span>

    <span class="s4">def </span><span class="s1">test_html_tags_have_namespace(self):</span>
        <span class="s1">markup = </span><span class="s3">&quot;&lt;a&gt;&quot;</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">self.assertEqual(</span><span class="s3">&quot;http://www.w3.org/1999/xhtml&quot;</span><span class="s4">, </span><span class="s1">soup.a.namespace)</span>

    <span class="s4">def </span><span class="s1">test_svg_tags_have_namespace(self):</span>
        <span class="s1">markup = </span><span class="s3">'&lt;svg&gt;&lt;circle/&gt;&lt;/svg&gt;'</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">namespace = </span><span class="s3">&quot;http://www.w3.org/2000/svg&quot;</span>
        <span class="s1">self.assertEqual(namespace</span><span class="s4">, </span><span class="s1">soup.svg.namespace)</span>
        <span class="s1">self.assertEqual(namespace</span><span class="s4">, </span><span class="s1">soup.circle.namespace)</span>


    <span class="s4">def </span><span class="s1">test_mathml_tags_have_namespace(self):</span>
        <span class="s1">markup = </span><span class="s3">'&lt;math&gt;&lt;msqrt&gt;5&lt;/msqrt&gt;&lt;/math&gt;'</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">namespace = </span><span class="s3">'http://www.w3.org/1998/Math/MathML'</span>
        <span class="s1">self.assertEqual(namespace</span><span class="s4">, </span><span class="s1">soup.math.namespace)</span>
        <span class="s1">self.assertEqual(namespace</span><span class="s4">, </span><span class="s1">soup.msqrt.namespace)</span>

    <span class="s4">def </span><span class="s1">test_xml_declaration_becomes_comment(self):</span>
        <span class="s1">markup = </span><span class="s3">'&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;html&gt;&lt;/html&gt;'</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">self.assertTrue(isinstance(soup.contents[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">Comment))</span>
        <span class="s1">self.assertEqual(soup.contents[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s3">'?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span><span class="s3">&quot;html&quot;</span><span class="s4">, </span><span class="s1">soup.contents[</span><span class="s5">0</span><span class="s1">].next_element.name)</span>

<span class="s4">def </span><span class="s1">skipIf(condition</span><span class="s4">, </span><span class="s1">reason):</span>
   <span class="s4">def </span><span class="s1">nothing(test</span><span class="s4">, </span><span class="s1">*args</span><span class="s4">, </span><span class="s1">**kwargs):</span>
       <span class="s4">return None</span>

   <span class="s4">def </span><span class="s1">decorator(test_item):</span>
       <span class="s4">if </span><span class="s1">condition:</span>
           <span class="s4">return </span><span class="s1">nothing</span>
       <span class="s4">else</span><span class="s1">:</span>
           <span class="s4">return </span><span class="s1">test_item</span>

   <span class="s4">return </span><span class="s1">decorator</span>
</pre>
</body>
</html>