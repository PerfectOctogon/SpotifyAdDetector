<html>
<head>
<title>_response.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_response.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Response classes. 
 
The seek_wrapper code is not used if you're using UserAgent with 
.set_seekable_responses(False), or if you're using the urllib2-level interface 
HTTPEquivProcessor.  Class closeable_response is instantiated by some handlers 
(AbstractHTTPHandler), but the closeable_response interface is only depended 
upon by Browser-level code.  Function upgrade_response is only used if you're 
using Browser. 
 
 
Copyright 2006 John J. Lee &lt;jjl@pobox.com&gt; 
 
This code is free software; you can redistribute it and/or modify it 
under the terms of the BSD or ZPL 2.1 licenses (see the file LICENSE 
included with the distribution). 
 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">absolute_import</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span>
<span class="s2">import </span><span class="s1">copy</span>
<span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">BytesIO</span>

<span class="s2">from </span><span class="s1">._headersutil </span><span class="s2">import </span><span class="s1">normalize_header_name</span>
<span class="s2">from </span><span class="s1">.polyglot </span><span class="s2">import </span><span class="s1">HTTPError</span><span class="s2">, </span><span class="s1">create_response_info</span>


<span class="s2">def </span><span class="s1">len_of_seekable(file_):</span>
    <span class="s3"># this function exists because evaluation of len(file_.getvalue()) on every</span>
    <span class="s3"># .read() from seek_wrapper would be O(N**2) in number of .read()s</span>
    <span class="s1">pos = file_.tell()</span>
    <span class="s1">file_.seek(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)  </span><span class="s3"># to end</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">file_.tell()</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s1">file_.seek(pos)</span>


<span class="s3"># XXX Andrew Dalke kindly sent me a similar class in response to my request on</span>
<span class="s3"># comp.lang.python, which I then proceeded to lose.  I wrote this class</span>
<span class="s3"># instead, but I think he's released his code publicly since, could pinch the</span>
<span class="s3"># tests from it, at least...</span>


<span class="s3"># For testing seek_wrapper invariant (note that</span>
<span class="s3"># test_urllib2.HandlerTest.test_seekable is expected to fail when this</span>
<span class="s3"># invariant checking is turned on).  The invariant checking is done by module</span>
<span class="s3"># ipdc, which is available here:</span>
<span class="s3"># http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/436834</span>
<span class="s3"># from ipdbc import ContractBase</span>
<span class="s3"># class seek_wrapper(ContractBase):</span>
<span class="s2">class </span><span class="s1">seek_wrapper:</span>
    <span class="s0">&quot;&quot;&quot;Adds a seek method to a file object. 
 
    This is only designed for seeking on readonly file-like objects. 
 
    Wrapped file-like object must have a read method.  The readline method is 
    only supported if that method is present on the wrapped object.  The 
    readlines method is always supported.  xreadlines and iteration are 
    supported only for Python 2.2 and above. 
 
    Public attributes: 
 
    wrapped: the wrapped file object 
    is_closed: true iff .close() has been called 
 
    WARNING: All other attributes of the wrapped object (ie. those that are not 
    one of wrapped, read, readline, readlines, xreadlines, __iter__ and next) 
    are passed through unaltered, which may or may not make sense for your 
    particular file object. 
 
    &quot;&quot;&quot;</span>

    <span class="s3"># General strategy is to check that cache is full enough, then delegate to</span>
    <span class="s3"># the cache (self.__cache, which is a BytesIO instance).  A seek</span>
    <span class="s3"># position (self.__pos) is maintained independently of the cache, in order</span>
    <span class="s3"># that a single cache may be shared between multiple seek_wrapper objects.</span>
    <span class="s3"># Copying using module copy shares the cache in this way.</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">wrapped):</span>
        <span class="s1">self.wrapped = wrapped</span>
        <span class="s1">self.__read_complete_state = [</span><span class="s2">False</span><span class="s1">]</span>
        <span class="s1">self.__is_closed_state = [</span><span class="s2">False</span><span class="s1">]</span>
        <span class="s1">self.__have_readline = hasattr(self.wrapped</span><span class="s2">, </span><span class="s5">&quot;readline&quot;</span><span class="s1">)</span>
        <span class="s1">self.__cache = BytesIO()</span>
        <span class="s1">self.__pos = </span><span class="s4">0  </span><span class="s3"># seek position</span>

    <span class="s2">def </span><span class="s1">invariant(self):</span>
        <span class="s3"># The end of the cache is always at the same place as the end of the</span>
        <span class="s3"># wrapped file (though the .tell() method is not required to be present</span>
        <span class="s3"># on wrapped file).</span>
        <span class="s2">return </span><span class="s1">self.wrapped.tell() == len(self.__cache.getvalue())</span>

    <span class="s2">def </span><span class="s1">close(self):</span>
        <span class="s1">self.wrapped.close()</span>
        <span class="s1">self.is_closed = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">if </span><span class="s1">name == </span><span class="s5">&quot;is_closed&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.__is_closed_state[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">name == </span><span class="s5">&quot;read_complete&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.__read_complete_state[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s1">wrapped = self.__dict__.get(</span><span class="s5">&quot;wrapped&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">wrapped:</span>
            <span class="s2">return </span><span class="s1">getattr(wrapped</span><span class="s2">, </span><span class="s1">name)</span>

        <span class="s2">return </span><span class="s1">getattr(self.__class__</span><span class="s2">, </span><span class="s1">name)</span>

    <span class="s2">def </span><span class="s1">__setattr__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">if </span><span class="s1">name == </span><span class="s5">&quot;is_closed&quot;</span><span class="s1">:</span>
            <span class="s1">self.__is_closed_state[</span><span class="s4">0</span><span class="s1">] = bool(value)</span>
        <span class="s2">elif </span><span class="s1">name == </span><span class="s5">&quot;read_complete&quot;</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">self.is_closed:</span>
                <span class="s1">self.__read_complete_state[</span><span class="s4">0</span><span class="s1">] = bool(value)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.__dict__[name] = value</span>

    <span class="s2">def </span><span class="s1">seek(self</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">whence=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s2">assert </span><span class="s1">whence </span><span class="s2">in </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>

        <span class="s3"># how much data, if any, do we need to read?</span>
        <span class="s2">if </span><span class="s1">whence == </span><span class="s4">2</span><span class="s1">:  </span><span class="s3"># 2: relative to end of *wrapped* file</span>
            <span class="s2">if </span><span class="s1">offset &lt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;negative seek offset&quot;</span><span class="s1">)</span>
            <span class="s3"># since we don't know yet where the end of that file is, we must</span>
            <span class="s3"># read everything</span>
            <span class="s1">to_read = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">whence == </span><span class="s4">0</span><span class="s1">:  </span><span class="s3"># 0: absolute</span>
                <span class="s2">if </span><span class="s1">offset &lt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;negative seek offset&quot;</span><span class="s1">)</span>
                <span class="s1">dest = offset</span>
            <span class="s2">else</span><span class="s1">:  </span><span class="s3"># 1: relative to current position</span>
                <span class="s1">pos = self.__pos</span>
                <span class="s2">if </span><span class="s1">pos &lt; offset:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;seek to before start of file&quot;</span><span class="s1">)</span>
                <span class="s1">dest = pos + offset</span>
            <span class="s1">end = len_of_seekable(self.__cache)</span>
            <span class="s1">to_read = dest - end</span>
            <span class="s2">if </span><span class="s1">to_read &lt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">to_read = </span><span class="s4">0</span>

        <span class="s2">if </span><span class="s1">to_read != </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self.__cache.seek(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">to_read </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">assert </span><span class="s1">whence == </span><span class="s4">2</span>
                <span class="s1">self.__cache.write(self.wrapped.read())</span>
                <span class="s1">self.read_complete = </span><span class="s2">True</span>
                <span class="s1">self.__pos = self.__cache.tell() - offset</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">data = self.wrapped.read(to_read)</span>
                <span class="s2">if not </span><span class="s1">data:</span>
                    <span class="s1">self.read_complete = </span><span class="s2">True</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self.__cache.write(data)</span>
                <span class="s3"># Don't raise an exception even if we've seek()ed past the end</span>
                <span class="s3"># of .wrapped, since fseek() doesn't complain in that case.</span>
                <span class="s3"># Also like fseek(), pretend we have seek()ed past the end,</span>
                <span class="s3"># i.e. not:</span>
                <span class="s3"># self.__pos = self.__cache.tell()</span>
                <span class="s3"># but rather:</span>
                <span class="s1">self.__pos = dest</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.__pos = dest</span>

    <span class="s2">def </span><span class="s1">tell(self):</span>
        <span class="s2">return </span><span class="s1">self.__pos</span>

    <span class="s2">def </span><span class="s1">__copy__(self):</span>
        <span class="s1">cpy = self.__class__(self.wrapped)</span>
        <span class="s1">cpy.__cache = self.__cache</span>
        <span class="s1">cpy.__read_complete_state = self.__read_complete_state</span>
        <span class="s1">cpy.__is_closed_state = self.__is_closed_state</span>
        <span class="s2">return </span><span class="s1">cpy</span>

    <span class="s2">def </span><span class="s1">get_data(self):</span>
        <span class="s1">pos = self.__pos</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.seek(</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">self.read(-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">self.__pos = pos</span>

    <span class="s2">def </span><span class="s1">read(self</span><span class="s2">, </span><span class="s1">size=-</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">pos = self.__pos</span>
        <span class="s1">end = len_of_seekable(self.__cache)</span>
        <span class="s1">available = end - pos</span>

        <span class="s3"># enough data already cached?</span>
        <span class="s2">if </span><span class="s1">size &lt;= available </span><span class="s2">and </span><span class="s1">size != -</span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">self.__cache.seek(pos)</span>
            <span class="s1">self.__pos = pos + size</span>
            <span class="s2">return </span><span class="s1">self.__cache.read(size)</span>

        <span class="s3"># no, so read sufficient data from wrapped file and cache it</span>
        <span class="s1">self.__cache.seek(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">size == -</span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">self.__cache.write(self.wrapped.read())</span>
            <span class="s1">self.read_complete = </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">to_read = size - available</span>
            <span class="s2">assert </span><span class="s1">to_read &gt; </span><span class="s4">0</span>
            <span class="s1">data = self.wrapped.read(to_read)</span>
            <span class="s2">if not </span><span class="s1">data:</span>
                <span class="s1">self.read_complete = </span><span class="s2">True</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.__cache.write(data)</span>
        <span class="s1">self.__cache.seek(pos)</span>

        <span class="s1">data = self.__cache.read(size)</span>
        <span class="s1">self.__pos = self.__cache.tell()</span>
        <span class="s2">assert </span><span class="s1">self.__pos == pos + len(data)</span>
        <span class="s2">return </span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">readline(self</span><span class="s2">, </span><span class="s1">size=-</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s2">if not </span><span class="s1">self.__have_readline:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s5">&quot;no readline method on wrapped object&quot;</span><span class="s1">)</span>

        <span class="s3"># line we're about to read might not be complete in the cache, so</span>
        <span class="s3"># read another line first</span>
        <span class="s1">pos = self.__pos</span>
        <span class="s1">self.__cache.seek(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">data = self.wrapped.readline()</span>
        <span class="s2">if not </span><span class="s1">data:</span>
            <span class="s1">self.read_complete = </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.__cache.write(data)</span>
        <span class="s1">self.__cache.seek(pos)</span>

        <span class="s1">data = self.__cache.readline()</span>
        <span class="s2">if </span><span class="s1">size != -</span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">r = data[:size]</span>
            <span class="s1">self.__pos = pos + size</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">r = data</span>
            <span class="s1">self.__pos = pos + len(data)</span>
        <span class="s2">return </span><span class="s1">r</span>

    <span class="s2">def </span><span class="s1">readlines(self</span><span class="s2">, </span><span class="s1">sizehint=-</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">pos = self.__pos</span>
        <span class="s1">self.__cache.seek(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.__cache.write(self.wrapped.read())</span>
        <span class="s1">self.read_complete = </span><span class="s2">True</span>
        <span class="s1">self.__cache.seek(pos)</span>
        <span class="s1">data = self.__cache.readlines(sizehint)</span>
        <span class="s1">self.__pos = self.__cache.tell()</span>
        <span class="s2">return </span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__next__(self):</span>
        <span class="s1">line = self.readline()</span>
        <span class="s2">if not </span><span class="s1">line:</span>
            <span class="s2">raise </span><span class="s1">StopIteration</span>
        <span class="s2">return </span><span class="s1">line</span>
    <span class="s1">next = __next__</span>

    <span class="s1">xreadlines = __iter__</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s5">&quot;&lt;%s at %s whose wrapped object = %r&gt;&quot; </span><span class="s1">%</span>
                <span class="s1">(self.__class__.__name__</span><span class="s2">, </span><span class="s1">hex(abs(id(self)))</span><span class="s2">, </span><span class="s1">self.wrapped))</span>


<span class="s2">class </span><span class="s1">response_seek_wrapper(seek_wrapper):</span>
    <span class="s0">&quot;&quot;&quot; 
    Supports copying response objects and setting response body data. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">wrapped):</span>
        <span class="s1">seek_wrapper.__init__(self</span><span class="s2">, </span><span class="s1">wrapped)</span>
        <span class="s1">self._headers = self.wrapped.info()</span>

    <span class="s2">def </span><span class="s1">__copy__(self):</span>
        <span class="s1">cpy = seek_wrapper.__copy__(self)</span>
        <span class="s3"># copy headers from delegate</span>
        <span class="s1">cpy._headers = copy.copy(self.info())</span>
        <span class="s2">return </span><span class="s1">cpy</span>

    <span class="s3"># Note that .info() and .geturl() (the only two urllib2 response methods</span>
    <span class="s3"># that are not implemented by seek_wrapper) must be here explicitly rather</span>
    <span class="s3"># than by seek_wrapper's __getattr__ delegation) so that the nasty</span>
    <span class="s3"># dynamically-created HTTPError classes in get_seek_wrapper_class() get the</span>
    <span class="s3"># wrapped object's implementation, and not HTTPError's.</span>

    <span class="s2">def </span><span class="s1">info(self):</span>
        <span class="s2">return </span><span class="s1">self._headers</span>

    <span class="s2">def </span><span class="s1">geturl(self):</span>
        <span class="s2">return </span><span class="s1">self.wrapped.geturl()</span>

    <span class="s2">def </span><span class="s1">set_data(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">self.seek(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.read()</span>
        <span class="s1">self.close()</span>
        <span class="s1">cache = self._seek_wrapper__cache = BytesIO()</span>
        <span class="s1">cache.write(data)</span>
        <span class="s1">self.seek(</span><span class="s4">0</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">eoffile:</span>
    <span class="s3"># file-like object that always claims to be at end-of-file...</span>

    <span class="s2">def </span><span class="s1">read(self</span><span class="s2">, </span><span class="s1">size=-</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s6">b&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">readline(self</span><span class="s2">, </span><span class="s1">size=-</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s6">b&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__next__(self):</span>
        <span class="s2">return </span><span class="s6">b&quot;&quot;</span>
    <span class="s1">next = __next__</span>

    <span class="s2">def </span><span class="s1">close(self):</span>
        <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">eofresponse(eoffile):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">headers</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">msg):</span>
        <span class="s1">self._url = url</span>
        <span class="s1">self._headers = headers</span>
        <span class="s1">self.code = code</span>
        <span class="s1">self.msg = msg</span>

    <span class="s2">def </span><span class="s1">geturl(self):</span>
        <span class="s2">return </span><span class="s1">self._url</span>

    <span class="s2">def </span><span class="s1">info(self):</span>
        <span class="s2">return </span><span class="s1">self._headers</span>


<span class="s2">class </span><span class="s1">closeable_response:</span>
    <span class="s0">&quot;&quot;&quot;Avoids unnecessarily clobbering urllib.addinfourl methods on .close(). 
 
    Only supports responses returned by mechanize.HTTPHandler. 
 
    After .close(), the following methods are supported: 
 
    .read() 
    .readline() 
    .info() 
    .geturl() 
    .__iter__() 
    .next() 
    .close() 
 
    and the following attributes are supported: 
 
    .code 
    .msg 
    .http_version 
 
    Also supports pickling (but the stdlib currently does something to prevent 
    it: http://python.org/sf/1144636). 
 
    &quot;&quot;&quot;</span>
    <span class="s3"># presence of this attr indicates is useable after .close()</span>
    <span class="s1">closeable_response = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">fp</span><span class="s2">, </span><span class="s1">headers</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">code=</span><span class="s4">200</span><span class="s2">, </span><span class="s1">msg=</span><span class="s5">'OK'</span><span class="s2">, </span><span class="s1">http_version=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self._set_fp(fp)</span>
        <span class="s1">self._headers = headers</span>
        <span class="s1">self._url = url</span>
        <span class="s1">self.code = code</span>
        <span class="s1">self.msg = msg</span>
        <span class="s1">self.http_version = http_version</span>

    <span class="s2">def </span><span class="s1">_set_fp(self</span><span class="s2">, </span><span class="s1">fp):</span>
        <span class="s1">self.fp = fp</span>
        <span class="s1">self.read = self.fp.read</span>
        <span class="s1">self.readline = self.fp.readline</span>
        <span class="s2">if </span><span class="s1">hasattr(self.fp</span><span class="s2">, </span><span class="s5">&quot;readlines&quot;</span><span class="s1">):</span>
            <span class="s1">self.readlines = self.fp.readlines</span>
        <span class="s2">if </span><span class="s1">hasattr(self.fp</span><span class="s2">, </span><span class="s5">&quot;fileno&quot;</span><span class="s1">):</span>
            <span class="s1">self.fileno = self.fp.fileno</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.fileno = </span><span class="s2">lambda</span><span class="s1">: </span><span class="s2">None</span>
        <span class="s1">self.__iter__ = self.fp.__iter__</span>
        <span class="s1">self.next = partial(next</span><span class="s2">, </span><span class="s1">self.fp)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s5">'&lt;%s at %s whose fp = %r&gt;' </span><span class="s1">% (self.__class__.__name__</span><span class="s2">,</span>
                                             <span class="s1">hex(abs(id(self)))</span><span class="s2">, </span><span class="s1">self.fp)</span>

    <span class="s2">def </span><span class="s1">info(self):</span>
        <span class="s2">return </span><span class="s1">self._headers</span>

    <span class="s2">def </span><span class="s1">getcode(self):</span>
        <span class="s2">return </span><span class="s1">self.code</span>

    <span class="s2">def </span><span class="s1">get_header_values(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">return </span><span class="s1">self._headers.getheaders(name)</span>

    <span class="s2">def </span><span class="s1">get_all_header_names(self</span><span class="s2">, </span><span class="s1">normalize=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">ans = []</span>
        <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">self._headers.headers:</span>
            <span class="s1">h = line.partition(</span><span class="s5">':'</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">normalize:</span>
                <span class="s1">h = normalize_header_name(h)</span>
            <span class="s1">ans.append(h)</span>
        <span class="s2">return </span><span class="s1">ans</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">return </span><span class="s1">self._headers[name]</span>

    <span class="s2">def </span><span class="s1">get(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">default):</span>
        <span class="s2">return </span><span class="s1">self._headers.get(name)</span>

    <span class="s2">def </span><span class="s1">geturl(self):</span>
        <span class="s2">return </span><span class="s1">self._url</span>

    <span class="s2">def </span><span class="s1">close(self):</span>
        <span class="s1">wrapped = self.fp</span>
        <span class="s1">wrapped.close()</span>
        <span class="s1">new_wrapped = eofresponse(self._url</span><span class="s2">, </span><span class="s1">self._headers</span><span class="s2">, </span><span class="s1">self.code</span><span class="s2">,</span>
                                  <span class="s1">self.msg)</span>
        <span class="s1">self._set_fp(new_wrapped)</span>


<span class="s2">def </span><span class="s1">test_response(data=</span><span class="s5">'test data'</span><span class="s2">,</span>
                  <span class="s1">headers=[]</span><span class="s2">,</span>
                  <span class="s1">url=</span><span class="s2">None,</span>
                  <span class="s1">code=</span><span class="s4">200</span><span class="s2">,</span>
                  <span class="s1">msg=</span><span class="s5">&quot;OK&quot;</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">make_response(data</span><span class="s2">, </span><span class="s1">headers</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">msg)</span>


<span class="s2">def </span><span class="s1">test_html_response(data=</span><span class="s5">'test data'</span><span class="s2">,</span>
                       <span class="s1">headers=[]</span><span class="s2">,</span>
                       <span class="s1">url=</span><span class="s2">None,</span>
                       <span class="s1">code=</span><span class="s4">200</span><span class="s2">,</span>
                       <span class="s1">msg=</span><span class="s5">&quot;OK&quot;</span><span class="s1">):</span>
    <span class="s1">headers += [(</span><span class="s5">&quot;Content-type&quot;</span><span class="s2">, </span><span class="s5">&quot;text/html&quot;</span><span class="s1">)]</span>
    <span class="s2">return </span><span class="s1">make_response(data</span><span class="s2">, </span><span class="s1">headers</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">msg)</span>


<span class="s2">def </span><span class="s1">make_response(data</span><span class="s2">, </span><span class="s1">headers</span><span class="s2">, </span><span class="s1">url=</span><span class="s2">None, </span><span class="s1">code=</span><span class="s4">200</span><span class="s2">, </span><span class="s1">msg=</span><span class="s5">&quot;OK&quot;</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Convenient factory for objects implementing response interface. 
 
    data: string containing response body data 
    headers: sequence of (name, value) pairs 
    url: URL of response 
    code: integer response code (e.g. 200) 
    msg: string response code message (e.g. &quot;OK&quot;) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">mime_headers = make_headers(headers)</span>
    <span class="s2">if not </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">bytes):</span>
        <span class="s1">data = data.encode(</span><span class="s5">'utf-8'</span><span class="s1">)</span>
    <span class="s1">r = closeable_response(BytesIO(data)</span><span class="s2">, </span><span class="s1">mime_headers</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">msg)</span>
    <span class="s2">return </span><span class="s1">response_seek_wrapper(r)</span>


<span class="s2">def </span><span class="s1">make_headers(headers):</span>
    <span class="s0">&quot;&quot;&quot; 
    headers: sequence of (name, value) pairs 
    &quot;&quot;&quot;</span>
    <span class="s1">hdr_text = []</span>
    <span class="s2">for </span><span class="s1">name_value </span><span class="s2">in </span><span class="s1">headers:</span>
        <span class="s1">hdr_text.append(</span><span class="s5">&quot;%s: %s&quot; </span><span class="s1">% name_value)</span>
    <span class="s1">ans = </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s1">.join(hdr_text)</span>
    <span class="s2">if not </span><span class="s1">isinstance(ans</span><span class="s2">, </span><span class="s1">bytes):</span>
        <span class="s1">ans = ans.encode(</span><span class="s5">'iso-8859-1'</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">create_response_info(BytesIO(ans))</span>


<span class="s3"># Rest of this module is especially horrible, but needed, at least until fork</span>
<span class="s3"># urllib2.  Even then, may want to preseve urllib2 compatibility.</span>


<span class="s2">def </span><span class="s1">get_seek_wrapper_class(response):</span>
    <span class="s3"># in order to wrap response objects that are also exceptions, we must</span>
    <span class="s3"># dynamically subclass the exception :-(((</span>
    <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">isinstance(response</span><span class="s2">, </span><span class="s1">HTTPError) </span><span class="s2">and</span>
            <span class="s2">not </span><span class="s1">isinstance(response</span><span class="s2">, </span><span class="s1">seek_wrapper)</span>
    <span class="s1">):</span>
        <span class="s2">if </span><span class="s1">response.__class__.__module__ == </span><span class="s5">&quot;__builtin__&quot;</span><span class="s1">:</span>
            <span class="s1">exc_class_name = response.__class__.__name__</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">exc_class_name = </span><span class="s5">&quot;%s.%s&quot; </span><span class="s1">% (response.__class__.__module__</span><span class="s2">,</span>
                                        <span class="s1">response.__class__.__name__)</span>

        <span class="s2">class </span><span class="s1">httperror_seek_wrapper(response_seek_wrapper</span><span class="s2">,</span>
                                     <span class="s1">response.__class__):</span>
            <span class="s3"># this only derives from HTTPError in order to be a subclass --</span>
            <span class="s3"># the HTTPError behaviour comes from delegation</span>

            <span class="s1">_exc_class_name = exc_class_name</span>

            <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">wrapped):</span>
                <span class="s1">response_seek_wrapper.__init__(self</span><span class="s2">, </span><span class="s1">wrapped)</span>
                <span class="s3"># be compatible with undocumented HTTPError attributes :-(</span>
                <span class="s1">self.hdrs = wrapped.info()</span>
                <span class="s1">self.filename = wrapped.geturl()</span>

            <span class="s2">def </span><span class="s1">__repr__(self):</span>
                <span class="s2">return </span><span class="s1">(</span><span class="s5">&quot;&lt;%s (%s instance) at %s &quot;</span>
                        <span class="s5">&quot;whose wrapped object = %r&gt;&quot; </span><span class="s1">%</span>
                        <span class="s1">(self.__class__.__name__</span><span class="s2">, </span><span class="s1">self._exc_class_name</span><span class="s2">,</span>
                         <span class="s1">hex(abs(id(self)))</span><span class="s2">, </span><span class="s1">self.wrapped))</span>

        <span class="s1">wrapper_class = httperror_seek_wrapper</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">wrapper_class = response_seek_wrapper</span>
    <span class="s2">return </span><span class="s1">wrapper_class</span>


<span class="s2">def </span><span class="s1">needs_seek_wrapper(obj):</span>
    <span class="s2">return </span><span class="s1">(</span>
            <span class="s2">not </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">seek_wrapper) </span><span class="s2">and </span><span class="s1">(</span>
                <span class="s1">hasattr(obj</span><span class="s2">, </span><span class="s5">'seek'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">HTTPError)</span>
                <span class="s2">or not </span><span class="s1">hasattr(obj</span><span class="s2">, </span><span class="s5">'get_data'</span><span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">)</span>


<span class="s2">def </span><span class="s1">seek_wrapped_response(response):</span>
    <span class="s0">&quot;&quot;&quot;Return a copy of response that supports seekable response interface. 
 
    Accepts responses from both mechanize and urllib2 handlers. 
 
    Copes with both ordinary response instances and HTTPError instances (which 
    can't be simply wrapped due to the requirement of preserving the exception 
    base class). 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">needs_seek_wrapper(response):</span>
        <span class="s1">wrapper_class = get_seek_wrapper_class(response)</span>
        <span class="s1">response = wrapper_class(response)</span>
    <span class="s2">assert </span><span class="s1">hasattr(response</span><span class="s2">, </span><span class="s5">&quot;get_data&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">response</span>


<span class="s2">def </span><span class="s1">upgrade_response(response):</span>
    <span class="s0">&quot;&quot;&quot;Return a copy of response that supports Browser response interface. 
 
    Browser response interface is that of &quot;seekable responses&quot; 
    (response_seek_wrapper), plus the requirement that responses must be 
    useable after .close() (closeable_response). 
 
    Accepts responses from both mechanize and urllib2 handlers. 
 
    Copes with both ordinary response instances and HTTPError instances (which 
    can't be simply wrapped due to the requirement of preserving the exception 
    base class). 
    &quot;&quot;&quot;</span>
    <span class="s1">wrapper_class = get_seek_wrapper_class(response)</span>
    <span class="s2">if </span><span class="s1">hasattr(response</span><span class="s2">, </span><span class="s5">&quot;closeable_response&quot;</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">needs_seek_wrapper(response):</span>
            <span class="s1">response = wrapper_class(response)</span>
        <span class="s2">assert </span><span class="s1">hasattr(response</span><span class="s2">, </span><span class="s5">&quot;get_data&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">copy.copy(response)</span>

    <span class="s3"># a urllib2 handler constructed the response, i.e. the response is an</span>
    <span class="s3"># urllib.addinfourl or a urllib2.HTTPError, instead of a</span>
    <span class="s3"># _Util.closeable_response as returned by e.g. mechanize.HTTPHandler</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">code = response.code</span>
    <span class="s2">except </span><span class="s1">AttributeError:</span>
        <span class="s1">code = </span><span class="s2">None</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">msg = response.msg</span>
    <span class="s2">except </span><span class="s1">AttributeError:</span>
        <span class="s1">msg = </span><span class="s2">None</span>

    <span class="s3"># may have already-.read() data from .seek() cache</span>
    <span class="s1">data = </span><span class="s2">None</span>
    <span class="s1">get_data = getattr(response</span><span class="s2">, </span><span class="s5">&quot;get_data&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">get_data:</span>
        <span class="s1">data = get_data()</span>

    <span class="s1">response = closeable_response(response.fp</span><span class="s2">,</span>
                                  <span class="s1">response.info()</span><span class="s2">, </span><span class="s1">response.geturl()</span><span class="s2">, </span><span class="s1">code</span><span class="s2">,</span>
                                  <span class="s1">msg)</span>
    <span class="s1">response = wrapper_class(response)</span>
    <span class="s2">if </span><span class="s1">data:</span>
        <span class="s1">response.set_data(data)</span>
    <span class="s2">return </span><span class="s1">response</span>
</pre>
</body>
</html>