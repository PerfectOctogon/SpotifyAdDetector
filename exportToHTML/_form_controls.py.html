<html>
<head>
<title>_form_controls.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_form_controls.py</font>
</center></td></tr></table>
<pre><span class="s0">#!/usr/bin/env python</span>
<span class="s0"># vim:fileencoding=utf-8</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">absolute_import</span>

<span class="s2">import </span><span class="s1">random</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">BytesIO</span>
<span class="s2">from </span><span class="s1">mimetypes </span><span class="s2">import </span><span class="s1">guess_type</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">_request</span>
<span class="s2">from </span><span class="s1">.polyglot </span><span class="s2">import </span><span class="s1">(as_unicode</span><span class="s2">, </span><span class="s1">is_py2</span><span class="s2">, </span><span class="s1">iteritems</span><span class="s2">, </span><span class="s1">unicode_type</span><span class="s2">, </span><span class="s1">urlencode</span><span class="s2">,</span>
                       <span class="s1">urlparse</span><span class="s2">, </span><span class="s1">urlunparse)</span>

<span class="s2">if </span><span class="s1">is_py2:</span>
    <span class="s2">from </span><span class="s1">cStringIO </span><span class="s2">import </span><span class="s1">StringIO</span>
<span class="s2">else</span><span class="s1">:</span>
    <span class="s2">class </span><span class="s1">StringIO(BytesIO):</span>

        <span class="s2">def </span><span class="s1">write(self</span><span class="s2">, </span><span class="s1">x):</span>
            <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">x = x.encode(</span><span class="s3">'utf-8'</span><span class="s1">)</span>
            <span class="s1">BytesIO.write(self</span><span class="s2">, </span><span class="s1">x)</span>


<span class="s2">class </span><span class="s1">Missing:</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">LocateError(ValueError):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">AmbiguityError(LocateError):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">ControlNotFoundError(LocateError):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">ItemNotFoundError(LocateError):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">ItemCountError(ValueError):</span>
    <span class="s2">pass</span>


<span class="s1">_compress_re = re.compile(</span><span class="s3">r&quot;\s+&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">deprecation(message</span><span class="s2">, </span><span class="s1">stack_offset=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s1">warnings.warn(message</span><span class="s2">, </span><span class="s1">DeprecationWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s4">3 </span><span class="s1">+ stack_offset)</span>


<span class="s2">def </span><span class="s1">compress_whitespace(text):</span>
    <span class="s2">return </span><span class="s1">re.sub(</span><span class="s3">r'\s+'</span><span class="s2">, </span><span class="s3">' '</span><span class="s2">, </span><span class="s1">text </span><span class="s2">or </span><span class="s3">''</span><span class="s1">).strip()</span>


<span class="s2">def </span><span class="s1">isstringlike(x):</span>
    <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">(bytes</span><span class="s2">, </span><span class="s1">unicode_type)):</span>
        <span class="s2">return True</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">x + </span><span class="s3">&quot;&quot;</span>
        <span class="s2">return True</span>
    <span class="s2">except </span><span class="s1">Exception:</span>
        <span class="s2">return False</span>


<span class="s2">def </span><span class="s1">choose_boundary():</span>
    <span class="s5">&quot;&quot;&quot;Return a string usable as a multipart boundary.&quot;&quot;&quot;</span>
    <span class="s0"># follow IE and firefox</span>
    <span class="s1">nonce = </span><span class="s3">&quot;&quot;</span><span class="s1">.join(str(random.randint(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">sys.maxsize - </span><span class="s4">1</span><span class="s1">)) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
    <span class="s2">return </span><span class="s3">&quot;-&quot; </span><span class="s1">* </span><span class="s4">27 </span><span class="s1">+ nonce</span>


<span class="s0"># This cut-n-pasted MimeWriter from standard library is here so can add</span>
<span class="s0"># to HTTP headers rather than message body when appropriate.  It also uses</span>
<span class="s0"># \r\n in place of \n.  This is a bit nasty.</span>
<span class="s2">class </span><span class="s1">MimeWriter:</span>
    <span class="s5">&quot;&quot;&quot;Generic MIME writer. 
 
    Methods: 
 
    __init__() 
    addheader() 
    flushheaders() 
    startbody() 
    startmultipartbody() 
    nextpart() 
    lastpart() 
 
    A MIME writer is much more primitive than a MIME parser.  It 
    doesn't seek around on the output file, and it doesn't use large 
    amounts of buffer space, so you have to write the parts in the 
    order they should occur on the output file.  It does buffer the 
    headers you add, allowing you to rearrange their order. 
 
    General usage is: 
 
    .. code-block:: python 
 
        f = &lt;open the output file&gt; 
        w = MimeWriter(f) 
        ...call w.addheader(key, value) 0 or more times... 
 
    followed by either: 
 
    .. code-block:: python 
 
        f = w.startbody(content_type) 
        ...call f.write(data) for body data... 
 
    or: 
 
    .. code-block:: python 
 
        w.startmultipartbody(subtype) 
        for each part: 
            subwriter = w.nextpart() 
            ...use the subwriter's methods to create the subpart... 
        w.lastpart() 
 
    The subwriter is another MimeWriter instance, and should be 
    treated in the same way as the toplevel MimeWriter.  This way, 
    writing recursive body parts is easy. 
 
    Warning: don't forget to call lastpart()! 
 
    XXX There should be more state so calls made in the wrong order 
    are detected. 
 
    Some special cases: 
 
    - startbody() just returns the file passed to the constructor; 
      but don't use this knowledge, as it may be changed. 
 
    - startmultipartbody() actually returns a file as well; 
      this can be used to write the initial 'if you can read this your 
      mailer is not MIME-aware' message. 
 
    - If you call flushheaders(), the headers accumulated so far are 
      written out (and forgotten); this is useful if you don't need a 
      body part at all, e.g. for a subpart of type message/rfc822 
      that's (mis)used to store some header-like information. 
 
    - Passing a keyword argument 'prefix=&lt;flag&gt;' to addheader(), 
      start*body() affects where the header is inserted; 0 means 
      append at the end, 1 means insert at the start; default is 
      append for addheader(), but insert for start*body(), which use 
      it to determine where the Content-type header goes. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">fp</span><span class="s2">, </span><span class="s1">http_hdrs=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self._http_hdrs = http_hdrs</span>
        <span class="s1">self._fp = fp</span>
        <span class="s1">self._headers = []</span>
        <span class="s1">self._boundary = []</span>
        <span class="s1">self._first_part = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">addheader(self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">prefix=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">add_to_http_hdrs=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        prefix is ignored if add_to_http_hdrs is true. 
        &quot;&quot;&quot;</span>
        <span class="s1">lines = value.split(</span><span class="s3">&quot;</span><span class="s2">\r\n</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s2">while </span><span class="s1">lines </span><span class="s2">and not </span><span class="s1">lines[-</span><span class="s4">1</span><span class="s1">]:</span>
            <span class="s2">del </span><span class="s1">lines[-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">while </span><span class="s1">lines </span><span class="s2">and not </span><span class="s1">lines[</span><span class="s4">0</span><span class="s1">]:</span>
            <span class="s2">del </span><span class="s1">lines[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">add_to_http_hdrs:</span>
            <span class="s1">value = </span><span class="s3">&quot;&quot;</span><span class="s1">.join(lines)</span>
            <span class="s0"># 2.2 urllib2 doesn't normalize header case</span>
            <span class="s1">self._http_hdrs.append((key.capitalize()</span><span class="s2">, </span><span class="s1">value))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">len(lines)):</span>
                <span class="s1">lines[i] = </span><span class="s3">&quot;    &quot; </span><span class="s1">+ lines[i].strip()</span>
            <span class="s1">value = </span><span class="s3">&quot;</span><span class="s2">\r\n</span><span class="s3">&quot;</span><span class="s1">.join(lines) + </span><span class="s3">&quot;</span><span class="s2">\r\n</span><span class="s3">&quot;</span>
            <span class="s1">line = key.title() + </span><span class="s3">&quot;: &quot; </span><span class="s1">+ value</span>
            <span class="s2">if </span><span class="s1">prefix:</span>
                <span class="s1">self._headers.insert(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">line)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._headers.append(line)</span>

    <span class="s2">def </span><span class="s1">flushheaders(self):</span>
        <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">self._headers:</span>
            <span class="s1">self._fp.write(line)</span>
        <span class="s1">self._headers = []</span>

    <span class="s2">def </span><span class="s1">startbody(self</span><span class="s2">,</span>
                  <span class="s1">ctype=</span><span class="s2">None,</span>
                  <span class="s1">plist=[]</span><span class="s2">,</span>
                  <span class="s1">prefix=</span><span class="s4">1</span><span class="s2">,</span>
                  <span class="s1">add_to_http_hdrs=</span><span class="s4">0</span><span class="s2">,</span>
                  <span class="s1">content_type=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        prefix is ignored if add_to_http_hdrs is true. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">content_type </span><span class="s2">and </span><span class="s1">ctype:</span>
            <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">plist:</span>
                <span class="s1">ctype = ctype + </span><span class="s3">';</span><span class="s2">\r\n </span><span class="s3">%s=%s' </span><span class="s1">% (name</span><span class="s2">, </span><span class="s1">value)</span>
            <span class="s1">self.addheader(</span>
                <span class="s3">&quot;Content-Type&quot;</span><span class="s2">,</span>
                <span class="s1">ctype</span><span class="s2">,</span>
                <span class="s1">prefix=prefix</span><span class="s2">,</span>
                <span class="s1">add_to_http_hdrs=add_to_http_hdrs)</span>
        <span class="s1">self.flushheaders()</span>
        <span class="s2">if not </span><span class="s1">add_to_http_hdrs:</span>
            <span class="s1">self._fp.write(</span><span class="s3">&quot;</span><span class="s2">\r\n</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s1">self._first_part = </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">self._fp</span>

    <span class="s2">def </span><span class="s1">startmultipartbody(self</span><span class="s2">,</span>
                           <span class="s1">subtype</span><span class="s2">,</span>
                           <span class="s1">boundary=</span><span class="s2">None,</span>
                           <span class="s1">plist=[]</span><span class="s2">,</span>
                           <span class="s1">prefix=</span><span class="s4">1</span><span class="s2">,</span>
                           <span class="s1">add_to_http_hdrs=</span><span class="s4">0</span><span class="s2">,</span>
                           <span class="s1">content_type=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">boundary = boundary </span><span class="s2">or </span><span class="s1">choose_boundary()</span>
        <span class="s1">self._boundary.append(boundary)</span>
        <span class="s2">return </span><span class="s1">self.startbody(</span>
            <span class="s3">&quot;multipart/&quot; </span><span class="s1">+ subtype</span><span class="s2">, </span><span class="s1">[(</span><span class="s3">&quot;boundary&quot;</span><span class="s2">, </span><span class="s1">boundary)] + plist</span><span class="s2">,</span>
            <span class="s1">prefix=prefix</span><span class="s2">,</span>
            <span class="s1">add_to_http_hdrs=add_to_http_hdrs</span><span class="s2">,</span>
            <span class="s1">content_type=content_type)</span>

    <span class="s2">def </span><span class="s1">nextpart(self):</span>
        <span class="s1">boundary = self._boundary[-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self._first_part:</span>
            <span class="s1">self._first_part = </span><span class="s2">False</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._fp.write(</span><span class="s3">&quot;</span><span class="s2">\r\n</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s1">self._fp.write(</span><span class="s3">&quot;--&quot; </span><span class="s1">+ boundary + </span><span class="s3">&quot;</span><span class="s2">\r\n</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self.__class__(self._fp)</span>

    <span class="s2">def </span><span class="s1">lastpart(self):</span>
        <span class="s2">if </span><span class="s1">self._first_part:</span>
            <span class="s1">self.nextpart()</span>
        <span class="s1">boundary = self._boundary.pop()</span>
        <span class="s1">self._fp.write(</span><span class="s3">&quot;</span><span class="s2">\r\n</span><span class="s3">--&quot; </span><span class="s1">+ boundary + </span><span class="s3">&quot;--</span><span class="s2">\r\n</span><span class="s3">&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Label:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">text</span><span class="s2">, </span><span class="s1">for_id=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.id = for_id</span>
        <span class="s1">self.text = compress_whitespace(text </span><span class="s2">or </span><span class="s3">''</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s3">&quot;&lt;Label(id=%r, text=%r)&gt;&quot; </span><span class="s1">% (self.id</span><span class="s2">, </span><span class="s1">self.text)</span>

    <span class="s1">__str__ = __repr__</span>


<span class="s2">def </span><span class="s1">_get_label(attrs):</span>
    <span class="s1">text = attrs.get(</span><span class="s3">&quot;__label&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">text </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">Label(text)</span>


<span class="s2">class </span><span class="s1">Control:</span>
    <span class="s5">&quot;&quot;&quot;An HTML form control. 
 
    An HTMLForm contains a sequence of Controls.  The Controls in an HTMLForm 
    are accessed using the HTMLForm.find_control method or the 
    HTMLForm.controls attribute. 
 
    Control instances are usually constructed using the ParseFile / 
    ParseResponse functions.  If you use those functions, you can ignore the 
    rest of this paragraph.  A Control is only properly initialised after the 
    fixup method has been called.  In fact, this is only strictly necessary for 
    ListControl instances.  This is necessary because ListControls are built up 
    from ListControls each containing only a single item, and their initial 
    value(s) can only be known after the sequence is complete. 
 
    The types and values that are acceptable for assignment to the value 
    attribute are defined by subclasses. 
 
    If the disabled attribute is true, this represents the state typically 
    represented by browsers by 'greying out' a control.  If the disabled 
    attribute is true, the Control will raise AttributeError if an attempt is 
    made to change its value.  In addition, the control will not be considered 
    'successful' as defined by the W3C HTML 4 standard -- ie. it will 
    contribute no data to the return value of the HTMLForm.click* methods.  To 
    enable a control, set the disabled attribute to a false value. 
 
    If the readonly attribute is true, the Control will raise AttributeError if 
    an attempt is made to change its value.  To make a control writable, set 
    the readonly attribute to a false value. 
 
    All controls have the disabled and readonly attributes, not only those that 
    may have the HTML attributes of the same names. 
 
    On assignment to the value attribute, the following exceptions are raised: 
    TypeError, AttributeError (if the value attribute should not be assigned 
    to, because the control is disabled, for example) and ValueError. 
 
    If the name or value attributes are None, or the value is an empty list, or 
    if the control is disabled, the control is not successful. 
 
    Public attributes: 
 
    :ivar str type: string describing type of control (see the keys of the 
        HTMLForm.type2class dictionary for the allowable values) (readonly) 
    :ivar str name: name of control (readonly) 
    :ivar value: current value of control (subclasses may allow a single value, 
        a sequence of values, or either) 
    :ivar bool disabled: disabled state 
    :ivar bool readonly: readonly state 
    :ivar str id: value of id HTML attribute 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        type: string describing type of control (see the keys of the 
         HTMLForm.type2class dictionary for the allowable values) 
        name: control name 
        attrs: HTML attributes of control's HTML element 
 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s2">def </span><span class="s1">add_to_form(self</span><span class="s2">, </span><span class="s1">form):</span>
        <span class="s1">self._form = form</span>
        <span class="s1">form.controls.append(self)</span>

    <span class="s2">def </span><span class="s1">fixup(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">is_of_kind(self</span><span class="s2">, </span><span class="s1">kind):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s2">def </span><span class="s1">clear(self):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s2">def </span><span class="s1">__setattr__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s2">def </span><span class="s1">pairs(self):</span>
        <span class="s5">&quot;&quot;&quot;Return list of (key, value) pairs suitable for passing to urlencode. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[(k</span><span class="s2">, </span><span class="s1">v) </span><span class="s2">for </span><span class="s1">(i</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v) </span><span class="s2">in </span><span class="s1">self._totally_ordered_pairs()]</span>

    <span class="s2">def </span><span class="s1">_totally_ordered_pairs(self):</span>
        <span class="s5">&quot;&quot;&quot;Return list of (key, value, index) tuples. 
 
        Like pairs, but allows preserving correct ordering even where several 
        controls are involved. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s2">def </span><span class="s1">_write_mime_data(self</span><span class="s2">, </span><span class="s1">mw</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s5">&quot;&quot;&quot;Write data for a subitem of this control to a MimeWriter.&quot;&quot;&quot;</span>
        <span class="s0"># called by HTMLForm</span>
        <span class="s1">mw2 = mw.nextpart()</span>
        <span class="s1">mw2.addheader(</span>
            <span class="s3">&quot;Content-Disposition&quot;</span><span class="s2">, </span><span class="s3">'form-data; name=&quot;%s&quot;' </span><span class="s1">% as_unicode(name)</span><span class="s2">,</span>
            <span class="s4">1</span><span class="s1">)</span>
        <span class="s1">f = mw2.startbody(prefix=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">f.write(value)</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s2">def </span><span class="s1">get_labels(self):</span>
        <span class="s5">&quot;&quot;&quot;Return all labels (Label instances) for this control. 
 
        If the control was surrounded by a &lt;label&gt; tag, that will be the first 
        label; all other labels, connected by 'for' and 'id', are in the order 
        that appear in the HTML. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">res = []</span>
        <span class="s2">if </span><span class="s1">self._label:</span>
            <span class="s1">res.append(self._label)</span>
        <span class="s2">if </span><span class="s1">self.id:</span>
            <span class="s1">res.extend(self._form._id_to_labels.get(self.id</span><span class="s2">, </span><span class="s1">()))</span>
        <span class="s2">return </span><span class="s1">res</span>


<span class="s0"># ---------------------------------------------------</span>
<span class="s2">class </span><span class="s1">ScalarControl(Control):</span>
    <span class="s5">&quot;&quot;&quot;Control whose value is not restricted to one of a prescribed set. 
 
    Some ScalarControls don't accept any value attribute.  Otherwise, takes a 
    single value, which must be string-like. 
 
    Additional read-only public attribute: 
 
    :ivar dict attrs: dictionary mapping the names of original HTML attributes 
        of the control to their values 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self._index = index</span>
        <span class="s1">self._label = _get_label(attrs)</span>
        <span class="s1">self.__dict__[</span><span class="s3">&quot;type&quot;</span><span class="s1">] = type.lower()</span>
        <span class="s1">self.__dict__[</span><span class="s3">&quot;name&quot;</span><span class="s1">] = name</span>
        <span class="s1">self._value = attrs.get(</span><span class="s3">&quot;value&quot;</span><span class="s1">)</span>
        <span class="s1">self.disabled = </span><span class="s3">'disabled' </span><span class="s2">in </span><span class="s1">attrs</span>
        <span class="s1">self.readonly = </span><span class="s3">'readonly' </span><span class="s2">in </span><span class="s1">attrs</span>
        <span class="s1">self.id = attrs.get(</span><span class="s3">&quot;id&quot;</span><span class="s1">)</span>

        <span class="s1">self.attrs = dict(attrs)</span>

        <span class="s1">self._clicked = </span><span class="s2">False</span>

        <span class="s1">self._urlparse = urlparse</span>
        <span class="s1">self._urlunparse = urlunparse</span>

    <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">if </span><span class="s1">name == </span><span class="s3">&quot;value&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.__dict__[</span><span class="s3">&quot;_value&quot;</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;%s instance has no attribute '%s'&quot; </span><span class="s1">%</span>
                                 <span class="s1">(self.__class__.__name__</span><span class="s2">, </span><span class="s1">name))</span>

    <span class="s2">def </span><span class="s1">__setattr__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">if </span><span class="s1">name == </span><span class="s3">&quot;value&quot;</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">isstringlike(value):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;must assign a string&quot;</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">self.readonly:</span>
                <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;control '%s' is readonly&quot; </span><span class="s1">% self.name)</span>
            <span class="s2">elif </span><span class="s1">self.disabled:</span>
                <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;control '%s' is disabled&quot; </span><span class="s1">% self.name)</span>
            <span class="s1">self.__dict__[</span><span class="s3">&quot;_value&quot;</span><span class="s1">] = value</span>
        <span class="s2">elif </span><span class="s1">name </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;name&quot;</span><span class="s2">, </span><span class="s3">&quot;type&quot;</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;%s attribute is readonly&quot; </span><span class="s1">% name)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.__dict__[name] = value</span>

    <span class="s2">def </span><span class="s1">_totally_ordered_pairs(self):</span>
        <span class="s1">name = self.name</span>
        <span class="s1">value = self.value</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">is None or </span><span class="s1">value </span><span class="s2">is None or </span><span class="s1">self.disabled:</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s2">return </span><span class="s1">[(self._index</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value)]</span>

    <span class="s2">def </span><span class="s1">clear(self):</span>
        <span class="s2">if </span><span class="s1">self.readonly:</span>
            <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;control '%s' is readonly&quot; </span><span class="s1">% self.name)</span>
        <span class="s1">self.__dict__[</span><span class="s3">&quot;_value&quot;</span><span class="s1">] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s1">name = self.name</span>
        <span class="s1">value = self.value</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">name = </span><span class="s3">&quot;&lt;None&gt;&quot;</span>
        <span class="s2">if </span><span class="s1">value </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">value = </span><span class="s3">&quot;&lt;None&gt;&quot;</span>

        <span class="s1">infos = []</span>
        <span class="s2">if </span><span class="s1">self.disabled:</span>
            <span class="s1">infos.append(</span><span class="s3">&quot;disabled&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.readonly:</span>
            <span class="s1">infos.append(</span><span class="s3">&quot;readonly&quot;</span><span class="s1">)</span>
        <span class="s1">info = </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(infos)</span>
        <span class="s2">if </span><span class="s1">info:</span>
            <span class="s1">info = </span><span class="s3">&quot; (%s)&quot; </span><span class="s1">% info</span>

        <span class="s2">return </span><span class="s3">&quot;&lt;%s(%s=%s)%s&gt;&quot; </span><span class="s1">% (self.__class__.__name__</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">info)</span>


<span class="s0"># ---------------------------------------------------</span>
<span class="s2">class </span><span class="s1">TextControl(ScalarControl):</span>
    <span class="s5">&quot;&quot;&quot;Textual input control. 
 
    Covers HTML elements: INPUT/TEXT, INPUT/PASSWORD, INPUT/HIDDEN, TEXTAREA 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">ScalarControl.__init__(self</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">index)</span>
        <span class="s2">if </span><span class="s1">self.type == </span><span class="s3">&quot;hidden&quot;</span><span class="s1">:</span>
            <span class="s1">self.readonly = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">self._value </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._value = </span><span class="s3">&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">is_of_kind(self</span><span class="s2">, </span><span class="s1">kind):</span>
        <span class="s2">return </span><span class="s1">kind == </span><span class="s3">&quot;text&quot;</span>


<span class="s0"># ---------------------------------------------------</span>
<span class="s2">class </span><span class="s1">FileControl(ScalarControl):</span>
    <span class="s5">&quot;&quot;&quot;File upload with INPUT TYPE=FILE. 
 
    The value attribute of a FileControl is always None.  Use add_file instead. 
 
    Additional public method: :meth:`add_file` 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">ScalarControl.__init__(self</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">index)</span>
        <span class="s1">self._value = </span><span class="s2">None</span>
        <span class="s1">self._upload_data = []</span>

    <span class="s2">def </span><span class="s1">is_of_kind(self</span><span class="s2">, </span><span class="s1">kind):</span>
        <span class="s2">return </span><span class="s1">kind == </span><span class="s3">&quot;file&quot;</span>

    <span class="s2">def </span><span class="s1">clear(self):</span>
        <span class="s2">if </span><span class="s1">self.readonly:</span>
            <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;control '%s' is readonly&quot; </span><span class="s1">% self.name)</span>
        <span class="s1">self._upload_data = []</span>

    <span class="s2">def </span><span class="s1">__setattr__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;value&quot;</span><span class="s2">, </span><span class="s3">&quot;name&quot;</span><span class="s2">, </span><span class="s3">&quot;type&quot;</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;%s attribute is readonly&quot; </span><span class="s1">% name)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.__dict__[name] = value</span>

    <span class="s2">def </span><span class="s1">add_file(self</span><span class="s2">, </span><span class="s1">file_object</span><span class="s2">, </span><span class="s1">content_type=</span><span class="s2">None, </span><span class="s1">filename=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">''' Add data from the specified file to be uploaded. content_type and 
        filename are sent in the HTTP headers if specified. '''</span>
        <span class="s2">if not </span><span class="s1">hasattr(file_object</span><span class="s2">, </span><span class="s3">&quot;read&quot;</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;file-like object must have read method&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">content_type </span><span class="s2">is not None and not </span><span class="s1">isstringlike(content_type):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;content type must be None or string-like&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">filename </span><span class="s2">is not None and not </span><span class="s1">isstringlike(filename):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;filename must be None or string-like&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">content_type </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">getattr(file_object</span><span class="s2">, </span><span class="s3">'name'</span><span class="s2">, None</span><span class="s1">):</span>
                <span class="s1">content_type = guess_type(file_object.name)[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">content_type = content_type </span><span class="s2">or </span><span class="s3">&quot;application/octet-stream&quot;</span>
        <span class="s1">self._upload_data.append((file_object</span><span class="s2">, </span><span class="s1">content_type</span><span class="s2">, </span><span class="s1">filename))</span>

    <span class="s2">def </span><span class="s1">_totally_ordered_pairs(self):</span>
        <span class="s0"># XXX should it be successful even if unnamed?</span>
        <span class="s2">if </span><span class="s1">self.name </span><span class="s2">is None or </span><span class="s1">self.disabled:</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s2">return </span><span class="s1">[(self._index</span><span class="s2">, </span><span class="s1">self.name</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)]</span>

    <span class="s0"># If enctype is application/x-www-form-urlencoded and there's a FILE</span>
    <span class="s0"># control present, what should be sent?  Strictly, it should be 'name=data'</span>
    <span class="s0"># (see HTML 4.01 spec., section 17.13.2), but code sends &quot;name=&quot; ATM.  What</span>
    <span class="s0"># about multiple file upload?</span>
    <span class="s2">def </span><span class="s1">_write_mime_data(self</span><span class="s2">, </span><span class="s1">mw</span><span class="s2">, </span><span class="s1">_name</span><span class="s2">, </span><span class="s1">_value):</span>
        <span class="s0"># called by HTMLForm</span>
        <span class="s0"># assert _name == self.name and _value == ''</span>
        <span class="s2">if </span><span class="s1">len(self._upload_data) &lt; </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">len(self._upload_data) == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">file_object = BytesIO()</span>
                <span class="s1">content_type = </span><span class="s3">&quot;application/octet-stream&quot;</span>
                <span class="s1">filename = </span><span class="s3">&quot;&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">file_object</span><span class="s2">, </span><span class="s1">content_type</span><span class="s2">, </span><span class="s1">filename = self._upload_data[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">filename </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">filename = </span><span class="s3">&quot;&quot;</span>
            <span class="s1">mw2 = mw.nextpart()</span>
            <span class="s1">fn_part = </span><span class="s3">'; filename=&quot;%s&quot;' </span><span class="s1">% filename</span>
            <span class="s1">disp = </span><span class="s3">'form-data; name=&quot;%s&quot;%s' </span><span class="s1">% (self.name</span><span class="s2">, </span><span class="s1">fn_part)</span>
            <span class="s1">mw2.addheader(</span><span class="s3">&quot;Content-Disposition&quot;</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">, </span><span class="s1">prefix=</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">fh = mw2.startbody(content_type</span><span class="s2">, </span><span class="s1">prefix=</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">fh.write(file_object.read())</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># multiple files</span>
            <span class="s1">mw2 = mw.nextpart()</span>
            <span class="s1">disp = </span><span class="s3">'form-data; name=&quot;%s&quot;' </span><span class="s1">% self.name</span>
            <span class="s1">mw2.addheader(</span><span class="s3">&quot;Content-Disposition&quot;</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">, </span><span class="s1">prefix=</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">fh = mw2.startmultipartbody(</span><span class="s3">&quot;mixed&quot;</span><span class="s2">, </span><span class="s1">prefix=</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">file_object</span><span class="s2">, </span><span class="s1">content_type</span><span class="s2">, </span><span class="s1">filename </span><span class="s2">in </span><span class="s1">self._upload_data:</span>
                <span class="s1">mw3 = mw2.nextpart()</span>
                <span class="s2">if </span><span class="s1">filename </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">filename = </span><span class="s3">&quot;&quot;</span>
                <span class="s1">fn_part = </span><span class="s3">'; filename=&quot;%s&quot;' </span><span class="s1">% filename</span>
                <span class="s1">disp = </span><span class="s3">&quot;file%s&quot; </span><span class="s1">% fn_part</span>
                <span class="s1">mw3.addheader(</span><span class="s3">&quot;Content-Disposition&quot;</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">, </span><span class="s1">prefix=</span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">fh2 = mw3.startbody(content_type</span><span class="s2">, </span><span class="s1">prefix=</span><span class="s4">0</span><span class="s1">)</span>
                <span class="s1">fh2.write(file_object.read())</span>
            <span class="s1">mw2.lastpart()</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s1">name = self.name</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">name = </span><span class="s3">&quot;&lt;None&gt;&quot;</span>

        <span class="s2">if not </span><span class="s1">self._upload_data:</span>
            <span class="s1">value = </span><span class="s3">&quot;&lt;No files added&gt;&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">value = []</span>
            <span class="s2">for </span><span class="s1">file</span><span class="s2">, </span><span class="s1">ctype</span><span class="s2">, </span><span class="s1">filename </span><span class="s2">in </span><span class="s1">self._upload_data:</span>
                <span class="s2">if </span><span class="s1">filename </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">value.append(</span><span class="s3">&quot;&lt;Unnamed file&gt;&quot;</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">value.append(filename)</span>
            <span class="s1">value = </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(value)</span>

        <span class="s1">info = []</span>
        <span class="s2">if </span><span class="s1">self.disabled:</span>
            <span class="s1">info.append(</span><span class="s3">&quot;disabled&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.readonly:</span>
            <span class="s1">info.append(</span><span class="s3">&quot;readonly&quot;</span><span class="s1">)</span>
        <span class="s1">info = </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(info)</span>
        <span class="s2">if </span><span class="s1">info:</span>
            <span class="s1">info = </span><span class="s3">&quot; (%s)&quot; </span><span class="s1">% info</span>

        <span class="s2">return </span><span class="s3">&quot;&lt;%s(%s=%s)%s&gt;&quot; </span><span class="s1">% (self.__class__.__name__</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">info)</span>


<span class="s0"># ---------------------------------------------------</span>
<span class="s0"># ---------------------------------------------------</span>
<span class="s2">class </span><span class="s1">IgnoreControl(ScalarControl):</span>
    <span class="s5">&quot;&quot;&quot;Control that we're not interested in. 
 
    Covers html elements: INPUT/RESET, BUTTON/RESET, INPUT/BUTTON, 
    BUTTON/BUTTON 
 
    These controls are always unsuccessful, in the terminology of HTML 4 (ie. 
    they never require any information to be returned to the server). 
 
    BUTTON/BUTTON is used to generate events for script embedded in HTML. 
 
    The value attribute of IgnoreControl is always None. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">ScalarControl.__init__(self</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">index)</span>
        <span class="s1">self._value = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">is_of_kind(self</span><span class="s2">, </span><span class="s1">kind):</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">__setattr__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">if </span><span class="s1">name == </span><span class="s3">&quot;value&quot;</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;control '%s' is ignored, hence read-only&quot; </span><span class="s1">%</span>
                                 <span class="s1">self.name)</span>
        <span class="s2">elif </span><span class="s1">name </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;name&quot;</span><span class="s2">, </span><span class="s3">&quot;type&quot;</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;%s attribute is readonly&quot; </span><span class="s1">% name)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.__dict__[name] = value</span>


<span class="s0"># ---------------------------------------------------</span>
<span class="s0"># ListControls</span>

<span class="s0"># helpers and subsidiary classes</span>


<span class="s2">class </span><span class="s1">Item:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">control</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">label = _get_label(attrs)</span>
        <span class="s1">self.__dict__.update({</span>
            <span class="s3">&quot;name&quot;</span><span class="s1">: attrs[</span><span class="s3">&quot;value&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s3">&quot;_labels&quot;</span><span class="s1">: label </span><span class="s2">and </span><span class="s1">[label] </span><span class="s2">or </span><span class="s1">[]</span><span class="s2">,</span>
            <span class="s3">&quot;attrs&quot;</span><span class="s1">: attrs</span><span class="s2">,</span>
            <span class="s3">&quot;_control&quot;</span><span class="s1">: control</span><span class="s2">,</span>
            <span class="s3">&quot;disabled&quot;</span><span class="s1">: </span><span class="s3">'disabled' </span><span class="s2">in </span><span class="s1">attrs</span><span class="s2">,</span>
            <span class="s3">&quot;_selected&quot;</span><span class="s1">: </span><span class="s2">False,</span>
            <span class="s3">&quot;id&quot;</span><span class="s1">: attrs.get(</span><span class="s3">&quot;id&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;_index&quot;</span><span class="s1">: index</span><span class="s2">,</span>
        <span class="s1">})</span>
        <span class="s1">control.items.append(self)</span>

    <span class="s2">def </span><span class="s1">get_labels(self):</span>
        <span class="s5">&quot;&quot;&quot;Return all labels (Label instances) for this item. 
 
        For items that represent radio buttons or checkboxes, if the item was 
        surrounded by a &lt;label&gt; tag, that will be the first label; all other 
        labels, connected by 'for' and 'id', are in the order that appear in 
        the HTML. 
 
        For items that represent select options, if the option had a label 
        attribute, that will be the first label.  If the option has contents 
        (text within the option tags) and it is not the same as the label 
        attribute (if any), that will be a label.  There is nothing in the 
        spec to my knowledge that makes an option with an id unable to be the 
        target of a label's for attribute, so those are included, if any, for 
        the sake of consistency and completeness. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">res = []</span>
        <span class="s1">res.extend(self._labels)</span>
        <span class="s2">if </span><span class="s1">self.id:</span>
            <span class="s1">res.extend(self._control._form._id_to_labels.get(self.id</span><span class="s2">, </span><span class="s1">()))</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">if </span><span class="s1">name == </span><span class="s3">&quot;selected&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._selected</span>
        <span class="s2">raise </span><span class="s1">AttributeError(name)</span>

    <span class="s2">def </span><span class="s1">__setattr__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">if </span><span class="s1">name == </span><span class="s3">&quot;selected&quot;</span><span class="s1">:</span>
            <span class="s1">self._control._set_selected_state(self</span><span class="s2">, </span><span class="s1">value)</span>
        <span class="s2">elif </span><span class="s1">name == </span><span class="s3">&quot;disabled&quot;</span><span class="s1">:</span>
            <span class="s1">self.__dict__[</span><span class="s3">&quot;disabled&quot;</span><span class="s1">] = bool(value)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">AttributeError(name)</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s1">res = self.name</span>
        <span class="s2">if </span><span class="s1">self.selected:</span>
            <span class="s1">res = </span><span class="s3">&quot;*&quot; </span><span class="s1">+ res</span>
        <span class="s2">if </span><span class="s1">self.disabled:</span>
            <span class="s1">res = </span><span class="s3">&quot;(%s)&quot; </span><span class="s1">% res</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s0"># XXX appending the attrs without distinguishing them from name and id</span>
        <span class="s0"># is silly</span>
        <span class="s1">attrs = [(</span><span class="s3">&quot;name&quot;</span><span class="s2">, </span><span class="s1">self.name)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;id&quot;</span><span class="s2">, </span><span class="s1">self.id)] + list(</span>
                <span class="s1">iteritems(self.attrs))</span>
        <span class="s2">return </span><span class="s3">&quot;&lt;%s %s&gt;&quot; </span><span class="s1">% (self.__class__.__name__</span><span class="s2">,</span>
                            <span class="s3">&quot; &quot;</span><span class="s1">.join([</span><span class="s3">&quot;%s=%r&quot; </span><span class="s1">% (k</span><span class="s2">, </span><span class="s1">v) </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">attrs]))</span>


<span class="s2">def </span><span class="s1">disambiguate(items</span><span class="s2">, </span><span class="s1">nr</span><span class="s2">, </span><span class="s1">**kwds):</span>
    <span class="s1">msgs = []</span>
    <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">iteritems(kwds):</span>
        <span class="s1">msgs.append(</span><span class="s3">&quot;%s=%r&quot; </span><span class="s1">% (key</span><span class="s2">, </span><span class="s1">value))</span>
    <span class="s1">msg = </span><span class="s3">&quot; &quot;</span><span class="s1">.join(msgs)</span>
    <span class="s2">if not </span><span class="s1">items:</span>
        <span class="s2">raise </span><span class="s1">ItemNotFoundError(msg)</span>
    <span class="s2">if </span><span class="s1">nr </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">len(items) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">AmbiguityError(msg)</span>
        <span class="s1">nr = </span><span class="s4">0</span>
    <span class="s2">if </span><span class="s1">len(items) &lt;= nr:</span>
        <span class="s2">raise </span><span class="s1">ItemNotFoundError(msg)</span>
    <span class="s2">return </span><span class="s1">items[nr]</span>


<span class="s2">class </span><span class="s1">ListControl(Control):</span>
    <span class="s5">&quot;&quot;&quot;Control representing a sequence of items. 
 
    The value attribute of a ListControl represents the successful list items 
    in the control.  The successful list items are those that are selected and 
    not disabled. 
 
    ListControl implements both list controls that take a length-1 value 
    (single-selection) and those that take length &gt;1 values 
    (multiple-selection). 
 
    ListControls accept sequence values only.  Some controls only accept 
    sequences of length 0 or 1 (RADIO, and single-selection SELECT). 
    In those cases, ItemCountError is raised if len(sequence) &gt; 1.  CHECKBOXes 
    and multiple-selection SELECTs (those having the &quot;multiple&quot; HTML attribute) 
    accept sequences of any length. 
 
    Note the following mistake: 
 
    .. code-block:: python 
 
        control.value = some_value 
        assert control.value == some_value    # not necessarily true 
 
    The reason for this is that the value attribute always gives the list items 
    in the order they were listed in the HTML. 
 
    ListControl items can also be referred to by their labels instead of names. 
    Use the label argument to .get(), and the .set_value_by_label(), 
    .get_value_by_label() methods. 
 
    Note that, rather confusingly, though SELECT controls are represented in 
    HTML by SELECT elements (which contain OPTION elements, representing 
    individual list items), CHECKBOXes and RADIOs are not represented by *any* 
    element.  Instead, those controls are represented by a collection of INPUT 
    elements.  For example, this is a SELECT control, named &quot;control1&quot;:: 
 
        &lt;select name=&quot;control1&quot;&gt; 
        &lt;option&gt;foo&lt;/option&gt; 
        &lt;option value=&quot;1&quot;&gt;bar&lt;/option&gt; 
        &lt;/select&gt; 
 
    and this is a CHECKBOX control, named &quot;control2&quot;:: 
 
        &lt;input type=&quot;checkbox&quot; name=&quot;control2&quot; value=&quot;foo&quot; id=&quot;cbe1&quot;&gt; 
        &lt;input type=&quot;checkbox&quot; name=&quot;control2&quot; value=&quot;bar&quot; id=&quot;cbe2&quot;&gt; 
 
    The id attribute of a CHECKBOX or RADIO ListControl is always that of its 
    first element (for example, &quot;cbe1&quot; above). 
 
 
    Additional read-only public attribute: multiple. 
 
    &quot;&quot;&quot;</span>

    <span class="s0"># ListControls are built up by the parser from their component items by</span>
    <span class="s0"># creating one ListControl per item, consolidating them into a single</span>
    <span class="s0"># master ListControl held by the HTMLForm:</span>

    <span class="s0"># -User calls form.new_control(...)</span>
    <span class="s0"># -Form creates Control, and calls control.add_to_form(self).</span>
    <span class="s0"># -Control looks for a Control with the same name and type in the form,</span>
    <span class="s0">#  and if it finds one, merges itself with that control by calling</span>
    <span class="s0">#  control.merge_control(self).  The first Control added to the form, of</span>
    <span class="s0">#  a particular name and type, is the only one that survives in the</span>
    <span class="s0">#  form.</span>
    <span class="s0"># -Form calls control.fixup for all its controls.  ListControls in the</span>
    <span class="s0">#  form know they can now safely pick their default values.</span>

    <span class="s0"># To create a ListControl without an HTMLForm, use:</span>

    <span class="s0"># control.merge_control(new_control)</span>

    <span class="s0"># (actually, it's much easier just to use ParseFile)</span>

    <span class="s1">_label = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">,</span>
                 <span class="s1">type</span><span class="s2">,</span>
                 <span class="s1">name</span><span class="s2">,</span>
                 <span class="s1">attrs={}</span><span class="s2">,</span>
                 <span class="s1">select_default=</span><span class="s2">False,</span>
                 <span class="s1">called_as_base_class=</span><span class="s2">False,</span>
                 <span class="s1">index=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        select_default: for RADIO and multiple-selection SELECT controls, pick 
         the first item as the default if no 'selected' HTML attribute is 
         present 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">called_as_base_class:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

        <span class="s1">self.__dict__[</span><span class="s3">&quot;type&quot;</span><span class="s1">] = type.lower()</span>
        <span class="s1">self.__dict__[</span><span class="s3">&quot;name&quot;</span><span class="s1">] = name</span>
        <span class="s1">self._value = attrs.get(</span><span class="s3">&quot;value&quot;</span><span class="s1">)</span>
        <span class="s1">self.disabled = </span><span class="s2">False</span>
        <span class="s1">self.readonly = </span><span class="s2">False</span>
        <span class="s1">self.id = attrs.get(</span><span class="s3">&quot;id&quot;</span><span class="s1">)</span>
        <span class="s1">self._closed = </span><span class="s2">False</span>

        <span class="s0"># As Controls are merged in with .merge_control(), self.attrs will</span>
        <span class="s0"># refer to each Control in turn -- always the most recently merged</span>
        <span class="s0"># control.  Each merged-in Control instance corresponds to a single</span>
        <span class="s0"># list item: see ListControl.__doc__.:</span>
        <span class="s1">self.items = []</span>
        <span class="s1">self._form = </span><span class="s2">None</span>

        <span class="s1">self._select_default = select_default</span>
        <span class="s1">self._clicked = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">clear(self):</span>
        <span class="s1">self.value = []</span>

    <span class="s2">def </span><span class="s1">is_of_kind(self</span><span class="s2">, </span><span class="s1">kind):</span>
        <span class="s2">if </span><span class="s1">kind == </span><span class="s3">&quot;list&quot;</span><span class="s1">:</span>
            <span class="s2">return True</span>
        <span class="s2">elif </span><span class="s1">kind == </span><span class="s3">&quot;multilist&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">bool(self.multiple)</span>
        <span class="s2">elif </span><span class="s1">kind == </span><span class="s3">&quot;singlelist&quot;</span><span class="s1">:</span>
            <span class="s2">return not </span><span class="s1">self.multiple</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">get_items(self</span><span class="s2">, </span><span class="s1">name=</span><span class="s2">None, </span><span class="s1">label=</span><span class="s2">None, </span><span class="s1">id=</span><span class="s2">None,</span>
                  <span class="s1">exclude_disabled=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Return matching items by name or label. 
 
        For argument docs, see the docstring for .get() 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">is not None and not </span><span class="s1">isstringlike(name):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;item name must be string-like&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">label </span><span class="s2">is not None and not </span><span class="s1">isstringlike(label):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;item label must be string-like&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">id </span><span class="s2">is not None and not </span><span class="s1">isstringlike(id):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;item id must be string-like&quot;</span><span class="s1">)</span>
        <span class="s1">items = []  </span><span class="s0"># order is important</span>
        <span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">self.items:</span>
            <span class="s2">if </span><span class="s1">exclude_disabled </span><span class="s2">and </span><span class="s1">o.disabled:</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">is not None and </span><span class="s1">o.name != name:</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">label </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">o.get_labels():</span>
                    <span class="s2">if </span><span class="s1">label </span><span class="s2">in </span><span class="s1">l.text:</span>
                        <span class="s2">break</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">id </span><span class="s2">is not None and </span><span class="s1">o.id != id:</span>
                <span class="s2">continue</span>
            <span class="s1">items.append(o)</span>
        <span class="s2">return </span><span class="s1">items</span>

    <span class="s2">def </span><span class="s1">get(self</span><span class="s2">,</span>
            <span class="s1">name=</span><span class="s2">None,</span>
            <span class="s1">label=</span><span class="s2">None,</span>
            <span class="s1">id=</span><span class="s2">None,</span>
            <span class="s1">nr=</span><span class="s2">None,</span>
            <span class="s1">exclude_disabled=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Return item by name or label, disambiguating if necessary with nr. 
 
        All arguments must be passed by name, with the exception of 'name', 
        which may be used as a positional argument. 
 
        If name is specified, then the item must have the indicated name. 
 
        If label is specified, then the item must have a label whose 
        whitespace-compressed, stripped, text substring-matches the indicated 
        label string (e.g. label=&quot;please choose&quot; will match 
        &quot;  Do  please  choose an item &quot;). 
 
        If id is specified, then the item must have the indicated id. 
 
        nr is an optional 0-based index of the items matching the query. 
 
        If nr is the default None value and more than item is found, raises 
        AmbiguityError. 
 
        If no item is found, or if items are found but nr is specified and not 
        found, raises ItemNotFoundError. 
 
        Optionally excludes disabled items. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">items = self.get_items(name</span><span class="s2">, </span><span class="s1">label</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">exclude_disabled)</span>
        <span class="s2">return </span><span class="s1">disambiguate(items</span><span class="s2">, </span><span class="s1">nr</span><span class="s2">, </span><span class="s1">name=name</span><span class="s2">, </span><span class="s1">label=label</span><span class="s2">, </span><span class="s1">id=id)</span>

    <span class="s2">def </span><span class="s1">_get(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">by_label=</span><span class="s2">False, </span><span class="s1">nr=</span><span class="s2">None, </span><span class="s1">exclude_disabled=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0"># strictly for use by deprecated methods</span>
        <span class="s2">if </span><span class="s1">by_label:</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s1">label = </span><span class="s2">None, </span><span class="s1">name</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s1">label = name</span><span class="s2">, None</span>
        <span class="s2">return </span><span class="s1">self.get(name</span><span class="s2">, </span><span class="s1">label</span><span class="s2">, </span><span class="s1">nr</span><span class="s2">, </span><span class="s1">exclude_disabled)</span>

    <span class="s2">def </span><span class="s1">toggle(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">by_label=</span><span class="s2">False, </span><span class="s1">nr=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Deprecated: given a name or label and optional disambiguating index 
        nr, toggle the matching item's selection. 
 
        Selecting items follows the behavior described in the docstring of the 
        'get' method. 
 
        if the item is disabled, or this control is disabled or readonly, 
        raise AttributeError. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">deprecation(</span>
            <span class="s3">&quot;item = control.get(...); item.selected = not item.selected&quot;</span><span class="s1">)</span>
        <span class="s1">o = self._get(name</span><span class="s2">, </span><span class="s1">by_label</span><span class="s2">, </span><span class="s1">nr)</span>
        <span class="s1">self._set_selected_state(o</span><span class="s2">, not </span><span class="s1">o.selected)</span>

    <span class="s2">def </span><span class="s1">set(self</span><span class="s2">, </span><span class="s1">selected</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">by_label=</span><span class="s2">False, </span><span class="s1">nr=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Deprecated: given a name or label and optional disambiguating index 
        nr, set the matching item's selection to the bool value of selected. 
 
        Selecting items follows the behavior described in the docstring of the 
        'get' method. 
 
        if the item is disabled, or this control is disabled or readonly, 
        raise AttributeError. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">deprecation(</span><span class="s3">&quot;control.get(...).selected = &lt;boolean&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self._set_selected_state(self._get(name</span><span class="s2">, </span><span class="s1">by_label</span><span class="s2">, </span><span class="s1">nr)</span><span class="s2">, </span><span class="s1">selected)</span>

    <span class="s2">def </span><span class="s1">_set_selected_state(self</span><span class="s2">, </span><span class="s1">item</span><span class="s2">, </span><span class="s1">action):</span>
        <span class="s0"># action:</span>
        <span class="s0"># bool False: off</span>
        <span class="s0"># bool True: on</span>
        <span class="s2">if </span><span class="s1">self.disabled:</span>
            <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;control '%s' is disabled&quot; </span><span class="s1">% self.name)</span>
        <span class="s2">if </span><span class="s1">self.readonly:</span>
            <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;control '%s' is readonly&quot; </span><span class="s1">% self.name)</span>
        <span class="s1">action == bool(action)</span>
        <span class="s2">if </span><span class="s1">item.disabled:</span>
            <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;item is disabled&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.multiple:</span>
            <span class="s1">item.__dict__[</span><span class="s3">&quot;_selected&quot;</span><span class="s1">] = action</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">action:</span>
                <span class="s1">item.__dict__[</span><span class="s3">&quot;_selected&quot;</span><span class="s1">] = </span><span class="s2">False</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">self.items:</span>
                    <span class="s1">o.__dict__[</span><span class="s3">&quot;_selected&quot;</span><span class="s1">] = </span><span class="s2">False</span>
                <span class="s1">item.__dict__[</span><span class="s3">&quot;_selected&quot;</span><span class="s1">] = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">toggle_single(self</span><span class="s2">, </span><span class="s1">by_label=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Deprecated: toggle the selection of the single item in this control. 
 
        Raises ItemCountError if the control does not contain only one item. 
 
        by_label argument is ignored, and included only for backwards 
        compatibility. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">deprecation(</span>
            <span class="s3">&quot;control.items[0].selected = not control.items[0].selected&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">len(self.items) != </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ItemCountError(</span><span class="s3">&quot;'%s' is not a single-item control&quot; </span><span class="s1">%</span>
                                 <span class="s1">self.name)</span>
        <span class="s1">item = self.items[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self._set_selected_state(item</span><span class="s2">, not </span><span class="s1">item.selected)</span>

    <span class="s2">def </span><span class="s1">set_single(self</span><span class="s2">, </span><span class="s1">selected</span><span class="s2">, </span><span class="s1">by_label=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Deprecated: set the selection of the single item in this control. 
 
        Raises ItemCountError if the control does not contain only one item. 
 
        by_label argument is ignored, and included only for backwards 
        compatibility. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">deprecation(</span><span class="s3">&quot;control.items[0].selected = &lt;boolean&gt;&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">len(self.items) != </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ItemCountError(</span><span class="s3">&quot;'%s' is not a single-item control&quot; </span><span class="s1">%</span>
                                 <span class="s1">self.name)</span>
        <span class="s1">self._set_selected_state(self.items[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">selected)</span>

    <span class="s2">def </span><span class="s1">get_item_disabled(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">by_label=</span><span class="s2">False, </span><span class="s1">nr=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Get disabled state of named list item in a ListControl.&quot;&quot;&quot;</span>
        <span class="s1">deprecation(</span><span class="s3">&quot;control.get(...).disabled&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._get(name</span><span class="s2">, </span><span class="s1">by_label</span><span class="s2">, </span><span class="s1">nr).disabled</span>

    <span class="s2">def </span><span class="s1">set_item_disabled(self</span><span class="s2">, </span><span class="s1">disabled</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">by_label=</span><span class="s2">False, </span><span class="s1">nr=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Set disabled state of named list item in a ListControl. 
 
        :arg disabled: boolean disabled state 
 
        &quot;&quot;&quot;</span>
        <span class="s1">deprecation(</span><span class="s3">&quot;control.get(...).disabled = &lt;boolean&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self._get(name</span><span class="s2">, </span><span class="s1">by_label</span><span class="s2">, </span><span class="s1">nr).disabled = disabled</span>

    <span class="s2">def </span><span class="s1">set_all_items_disabled(self</span><span class="s2">, </span><span class="s1">disabled):</span>
        <span class="s5">&quot;&quot;&quot;Set disabled state of all list items in a ListControl. 
 
        :arg disabled: boolean disabled state 
 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">self.items:</span>
            <span class="s1">o.disabled = disabled</span>

    <span class="s2">def </span><span class="s1">get_item_attrs(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">by_label=</span><span class="s2">False, </span><span class="s1">nr=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Return dictionary of HTML attributes for a single ListControl item. 
 
        The HTML element types that describe list items are: OPTION for SELECT 
        controls, INPUT for the rest.  These elements have HTML attributes that 
        you may occasionally want to know about -- for example, the &quot;alt&quot; HTML 
        attribute gives a text string describing the item (graphical browsers 
        usually display this as a tooltip). 
 
        The returned dictionary maps HTML attribute names to values.  The names 
        and values are taken from the original HTML. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">deprecation(</span><span class="s3">&quot;control.get(...).attrs&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._get(name</span><span class="s2">, </span><span class="s1">by_label</span><span class="s2">, </span><span class="s1">nr).attrs</span>

    <span class="s2">def </span><span class="s1">close_control(self):</span>
        <span class="s1">self._closed = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">add_to_form(self</span><span class="s2">, </span><span class="s1">form):</span>
        <span class="s2">assert </span><span class="s1">self._form </span><span class="s2">is None or </span><span class="s1">form == self._form</span><span class="s2">, </span><span class="s1">(</span>
            <span class="s3">&quot;can't add control to more than one form&quot;</span><span class="s1">)</span>
        <span class="s1">self._form = form</span>
        <span class="s2">if </span><span class="s1">self.name </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s0"># always count nameless elements as separate controls</span>
            <span class="s1">Control.add_to_form(self</span><span class="s2">, </span><span class="s1">form)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range(len(form.controls) - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">):</span>
                <span class="s1">control = form.controls[ii]</span>
                <span class="s2">if </span><span class="s1">control.name == self.name </span><span class="s2">and </span><span class="s1">control.type == self.type:</span>
                    <span class="s2">if </span><span class="s1">control._closed:</span>
                        <span class="s1">Control.add_to_form(self</span><span class="s2">, </span><span class="s1">form)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">control.merge_control(self)</span>
                    <span class="s2">break</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">Control.add_to_form(self</span><span class="s2">, </span><span class="s1">form)</span>

    <span class="s2">def </span><span class="s1">merge_control(self</span><span class="s2">, </span><span class="s1">control):</span>
        <span class="s2">assert </span><span class="s1">bool(control.multiple) == bool(self.multiple)</span>
        <span class="s0"># usually, isinstance(control, self.__class__)</span>
        <span class="s1">self.items.extend(control.items)</span>

    <span class="s2">def </span><span class="s1">fixup(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        ListControls are built up from component list items (which are also 
        ListControls) during parsing.  This method should be called after all 
        items have been added.  See :class:`mechanize.ListControl` for the 
        reason this is required. 
 
        &quot;&quot;&quot;</span>
        <span class="s0"># Need to set default selection where no item was indicated as being</span>
        <span class="s0"># selected by the HTML:</span>

        <span class="s0"># CHECKBOX:</span>
        <span class="s0">#  Nothing should be selected.</span>
        <span class="s0"># SELECT/single, SELECT/multiple and RADIO:</span>
        <span class="s0">#  RFC 1866 (HTML 2.0): says first item should be selected.</span>
        <span class="s0">#  W3C HTML 4.01 Specification: says that client behaviour is</span>
        <span class="s0">#   undefined in this case.  For RADIO, exactly one must be selected,</span>
        <span class="s0">#   though which one is undefined.</span>
        <span class="s0">#  Both Netscape and Microsoft Internet Explorer (IE) choose first</span>
        <span class="s0">#   item for SELECT/single.  However, both IE5 and Mozilla (both 1.0</span>
        <span class="s0">#   and Firebird 0.6) leave all items unselected for RADIO and</span>
        <span class="s0">#   SELECT/multiple.</span>

        <span class="s0"># Since both Netscape and IE all choose the first item for</span>
        <span class="s0"># SELECT/single, we do the same.  OTOH, both Netscape and IE</span>
        <span class="s0"># leave SELECT/multiple with nothing selected, in violation of RFC 1866</span>
        <span class="s0"># (but not in violation of the W3C HTML 4 standard); the same is true</span>
        <span class="s0"># of RADIO (which *is* in violation of the HTML 4 standard).  We follow</span>
        <span class="s0"># RFC 1866 if the _select_default attribute is set, and Netscape and IE</span>
        <span class="s0"># otherwise.  RFC 1866 and HTML 4 are always violated insofar as you</span>
        <span class="s0"># can deselect all items in a RadioControl.</span>

        <span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">self.items:</span>
            <span class="s0"># set items' controls to self, now that we've merged</span>
            <span class="s1">o.__dict__[</span><span class="s3">&quot;_control&quot;</span><span class="s1">] = self</span>

    <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">if </span><span class="s1">name == </span><span class="s3">&quot;value&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.name </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">[]</span>
            <span class="s2">return </span><span class="s1">[</span>
                <span class="s1">o.name </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">self.items </span><span class="s2">if </span><span class="s1">o.selected </span><span class="s2">and </span><span class="s1">(</span><span class="s2">not </span><span class="s1">o.disabled)</span>
            <span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;%s instance has no attribute '%s'&quot; </span><span class="s1">%</span>
                                 <span class="s1">(self.__class__.__name__</span><span class="s2">, </span><span class="s1">name))</span>

    <span class="s2">def </span><span class="s1">__setattr__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">if </span><span class="s1">name == </span><span class="s3">&quot;value&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.disabled:</span>
                <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;control '%s' is disabled&quot; </span><span class="s1">% self.name)</span>
            <span class="s2">if </span><span class="s1">self.readonly:</span>
                <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;control '%s' is readonly&quot; </span><span class="s1">% self.name)</span>
            <span class="s1">self._set_value(value)</span>
        <span class="s2">elif </span><span class="s1">name </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;name&quot;</span><span class="s2">, </span><span class="s3">&quot;type&quot;</span><span class="s2">, </span><span class="s3">&quot;multiple&quot;</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;%s attribute is readonly&quot; </span><span class="s1">% name)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.__dict__[name] = value</span>

    <span class="s2">def </span><span class="s1">_set_value(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">if </span><span class="s1">value </span><span class="s2">is None or </span><span class="s1">isstringlike(value):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;ListControl, must set a sequence&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">value:</span>
            <span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">self.items:</span>
                <span class="s2">if not </span><span class="s1">o.disabled:</span>
                    <span class="s1">o.selected = </span><span class="s2">False</span>
        <span class="s2">elif </span><span class="s1">self.multiple:</span>
            <span class="s1">self._multiple_set_value(value)</span>
        <span class="s2">elif </span><span class="s1">len(value) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ItemCountError(</span><span class="s3">&quot;single selection list, must set sequence of &quot;</span>
                                 <span class="s3">&quot;length 0 or 1&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._single_set_value(value)</span>

    <span class="s2">def </span><span class="s1">_get_items(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">target=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">all_items = self.get_items(name)</span>
        <span class="s1">items = [o </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">all_items </span><span class="s2">if not </span><span class="s1">o.disabled]</span>
        <span class="s2">if </span><span class="s1">len(items) &lt; target:</span>
            <span class="s2">if </span><span class="s1">len(all_items) &lt; target:</span>
                <span class="s2">raise </span><span class="s1">ItemNotFoundError(</span><span class="s3">&quot;insufficient items with name %r&quot; </span><span class="s1">%</span>
                                        <span class="s1">name)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">AttributeError(</span>
                    <span class="s3">&quot;insufficient non-disabled items with name %s&quot; </span><span class="s1">% name)</span>
        <span class="s1">on = []</span>
        <span class="s1">off = []</span>
        <span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">items:</span>
            <span class="s2">if </span><span class="s1">o.selected:</span>
                <span class="s1">on.append(o)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">off.append(o)</span>
        <span class="s2">return </span><span class="s1">on</span><span class="s2">, </span><span class="s1">off</span>

    <span class="s2">def </span><span class="s1">_single_set_value(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">assert </span><span class="s1">len(value) == </span><span class="s4">1</span>
        <span class="s1">on</span><span class="s2">, </span><span class="s1">off = self._get_items(value[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">len(on) &lt;= </span><span class="s4">1</span>
        <span class="s2">if not </span><span class="s1">on:</span>
            <span class="s1">off[</span><span class="s4">0</span><span class="s1">].selected = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_multiple_set_value(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">turn_on = []  </span><span class="s0"># transactional-ish</span>
        <span class="s1">turn_off = [</span>
            <span class="s1">item </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">self.items</span>
            <span class="s2">if </span><span class="s1">item.selected </span><span class="s2">and </span><span class="s1">(</span><span class="s2">not </span><span class="s1">item.disabled)</span>
        <span class="s1">]</span>
        <span class="s1">names = {}</span>
        <span class="s2">for </span><span class="s1">nn </span><span class="s2">in </span><span class="s1">value:</span>
            <span class="s1">names[nn] = names.setdefault(nn</span><span class="s2">, </span><span class="s4">0</span><span class="s1">) + </span><span class="s4">1</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">count </span><span class="s2">in </span><span class="s1">iteritems(names):</span>
            <span class="s1">on</span><span class="s2">, </span><span class="s1">off = self._get_items(name</span><span class="s2">, </span><span class="s1">count)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(count):</span>
                <span class="s2">if </span><span class="s1">on:</span>
                    <span class="s1">item = on[</span><span class="s4">0</span><span class="s1">]</span>
                    <span class="s2">del </span><span class="s1">on[</span><span class="s4">0</span><span class="s1">]</span>
                    <span class="s2">del </span><span class="s1">turn_off[turn_off.index(item)]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">item = off[</span><span class="s4">0</span><span class="s1">]</span>
                    <span class="s2">del </span><span class="s1">off[</span><span class="s4">0</span><span class="s1">]</span>
                    <span class="s1">turn_on.append(item)</span>
        <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">turn_off:</span>
            <span class="s1">item.selected = </span><span class="s2">False</span>
        <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">turn_on:</span>
            <span class="s1">item.selected = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_value_by_label(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s5">&quot;&quot;&quot;Set the value of control by item labels. 
 
        value is expected to be an iterable of strings that are substrings of 
        the item labels that should be selected.  Before substring matching is 
        performed, the original label text is whitespace-compressed 
        (consecutive whitespace characters are converted to a single space 
        character) and leading and trailing whitespace is stripped. Ambiguous 
        labels: it will not complain as long as all ambiguous labels share the 
        same item name (e.g. OPTION value). 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isstringlike(value):</span>
            <span class="s2">raise </span><span class="s1">TypeError(value)</span>
        <span class="s2">if not </span><span class="s1">self.multiple </span><span class="s2">and </span><span class="s1">len(value) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ItemCountError(</span><span class="s3">&quot;single selection list, must set sequence of &quot;</span>
                                 <span class="s3">&quot;length 0 or 1&quot;</span><span class="s1">)</span>
        <span class="s1">items = []</span>
        <span class="s2">for </span><span class="s1">nn </span><span class="s2">in </span><span class="s1">value:</span>
            <span class="s1">found = self.get_items(label=nn)</span>
            <span class="s2">if </span><span class="s1">len(found) &gt; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s0"># ambiguous labels are fine as long as item names (e.g.</span>
                <span class="s0"># OPTION values) are same</span>
                <span class="s1">opt_name = found[</span><span class="s4">0</span><span class="s1">].name</span>
                <span class="s2">if </span><span class="s1">[o </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">found[</span><span class="s4">1</span><span class="s1">:] </span><span class="s2">if </span><span class="s1">o.name != opt_name]:</span>
                    <span class="s2">raise </span><span class="s1">AmbiguityError(nn)</span>
            <span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">found:</span>
                <span class="s0"># For the multiple-item case, we could try to be smarter,</span>
                <span class="s0"># saving them up and trying to resolve, but that's too much.</span>
                <span class="s2">if </span><span class="s1">o </span><span class="s2">not in </span><span class="s1">items:</span>
                    <span class="s1">items.append(o)</span>
                    <span class="s2">break</span>
            <span class="s2">else</span><span class="s1">:  </span><span class="s0"># all of them are used</span>
                <span class="s2">raise </span><span class="s1">ItemNotFoundError(nn)</span>
        <span class="s0"># now we have all the items that should be on</span>
        <span class="s0"># let's just turn everything off and then back on.</span>
        <span class="s1">self.value = []</span>
        <span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">items:</span>
            <span class="s1">o.selected = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_value_by_label(self):</span>
        <span class="s5">&quot;&quot;&quot;Return the value of the control as given by normalized labels.&quot;&quot;&quot;</span>
        <span class="s1">res = []</span>
        <span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">self.items:</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">not </span><span class="s1">o.disabled) </span><span class="s2">and </span><span class="s1">o.selected:</span>
                <span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">o.get_labels():</span>
                    <span class="s2">if </span><span class="s1">l.text:</span>
                        <span class="s1">res.append(l.text)</span>
                        <span class="s2">break</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">res.append(</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">def </span><span class="s1">possible_items(self</span><span class="s2">, </span><span class="s1">by_label=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Deprecated: return the names or labels of all possible items. 
 
        Includes disabled items, which may be misleading for some use cases. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">deprecation(</span><span class="s3">&quot;[item.name for item in self.items]&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">by_label:</span>
            <span class="s1">res = []</span>
            <span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">self.items:</span>
                <span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">o.get_labels():</span>
                    <span class="s2">if </span><span class="s1">l.text:</span>
                        <span class="s1">res.append(l.text)</span>
                        <span class="s2">break</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">res.append(</span><span class="s2">None</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">res</span>
        <span class="s2">return </span><span class="s1">[o.name </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">self.items]</span>

    <span class="s2">def </span><span class="s1">_totally_ordered_pairs(self):</span>
        <span class="s2">if </span><span class="s1">self.disabled </span><span class="s2">or </span><span class="s1">self.name </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[(o._index</span><span class="s2">, </span><span class="s1">self.name</span><span class="s2">, </span><span class="s1">o.name) </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">self.items</span>
                    <span class="s2">if </span><span class="s1">o.selected </span><span class="s2">and not </span><span class="s1">o.disabled]</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s1">name = self.name</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">name = </span><span class="s3">&quot;&lt;None&gt;&quot;</span>

        <span class="s1">display = [str(o) </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">self.items]</span>

        <span class="s1">infos = []</span>
        <span class="s2">if </span><span class="s1">self.disabled:</span>
            <span class="s1">infos.append(</span><span class="s3">&quot;disabled&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.readonly:</span>
            <span class="s1">infos.append(</span><span class="s3">&quot;readonly&quot;</span><span class="s1">)</span>
        <span class="s1">info = </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(infos)</span>
        <span class="s2">if </span><span class="s1">info:</span>
            <span class="s1">info = </span><span class="s3">&quot; (%s)&quot; </span><span class="s1">% info</span>

        <span class="s2">return </span><span class="s3">&quot;&lt;%s(%s=[%s])%s&gt;&quot; </span><span class="s1">% (self.__class__.__name__</span><span class="s2">, </span><span class="s1">name</span><span class="s2">,</span>
                                    <span class="s3">&quot;, &quot;</span><span class="s1">.join(display)</span><span class="s2">, </span><span class="s1">info)</span>


<span class="s2">class </span><span class="s1">RadioControl(ListControl):</span>
    <span class="s5">&quot;&quot;&quot; 
    Covers: 
 
    INPUT/RADIO 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">select_default=</span><span class="s2">False, </span><span class="s1">index=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">attrs.setdefault(</span><span class="s3">&quot;value&quot;</span><span class="s2">, </span><span class="s3">&quot;on&quot;</span><span class="s1">)</span>
        <span class="s1">ListControl.__init__(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">type</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">,</span>
            <span class="s1">attrs</span><span class="s2">,</span>
            <span class="s1">select_default</span><span class="s2">,</span>
            <span class="s1">called_as_base_class=</span><span class="s2">True,</span>
            <span class="s1">index=index)</span>
        <span class="s1">self.__dict__[</span><span class="s3">&quot;multiple&quot;</span><span class="s1">] = </span><span class="s2">False</span>
        <span class="s1">o = Item(self</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">index)</span>
        <span class="s1">o.__dict__[</span><span class="s3">&quot;_selected&quot;</span><span class="s1">] = </span><span class="s3">'checked' </span><span class="s2">in </span><span class="s1">attrs</span>

    <span class="s2">def </span><span class="s1">fixup(self):</span>
        <span class="s1">ListControl.fixup(self)</span>
        <span class="s1">found = [o </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">self.items </span><span class="s2">if </span><span class="s1">o.selected </span><span class="s2">and not </span><span class="s1">o.disabled]</span>
        <span class="s2">if not </span><span class="s1">found:</span>
            <span class="s2">if </span><span class="s1">self._select_default:</span>
                <span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">self.items:</span>
                    <span class="s2">if not </span><span class="s1">o.disabled:</span>
                        <span class="s1">o.selected = </span><span class="s2">True</span>
                        <span class="s2">break</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># Ensure only one item selected.  Choose the last one,</span>
            <span class="s0"># following IE and Firefox.</span>
            <span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">found[:-</span><span class="s4">1</span><span class="s1">]:</span>
                <span class="s1">o.selected = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">get_labels(self):</span>
        <span class="s2">return </span><span class="s1">[]</span>


<span class="s2">class </span><span class="s1">CheckboxControl(ListControl):</span>
    <span class="s5">&quot;&quot;&quot; 
    Covers: 
 
    INPUT/CHECKBOX 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">select_default=</span><span class="s2">False, </span><span class="s1">index=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">attrs.setdefault(</span><span class="s3">&quot;value&quot;</span><span class="s2">, </span><span class="s3">&quot;on&quot;</span><span class="s1">)</span>
        <span class="s1">ListControl.__init__(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">type</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">,</span>
            <span class="s1">attrs</span><span class="s2">,</span>
            <span class="s1">select_default</span><span class="s2">,</span>
            <span class="s1">called_as_base_class=</span><span class="s2">True,</span>
            <span class="s1">index=index)</span>
        <span class="s1">self.__dict__[</span><span class="s3">&quot;multiple&quot;</span><span class="s1">] = </span><span class="s2">True</span>
        <span class="s1">o = Item(self</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">index)</span>
        <span class="s1">o.__dict__[</span><span class="s3">&quot;_selected&quot;</span><span class="s1">] = </span><span class="s3">'checked' </span><span class="s2">in </span><span class="s1">attrs</span>

    <span class="s2">def </span><span class="s1">get_labels(self):</span>
        <span class="s2">return </span><span class="s1">[]</span>


<span class="s2">class </span><span class="s1">SelectControl(ListControl):</span>
    <span class="s5">&quot;&quot;&quot; 
    Covers: 
 
    SELECT (and OPTION) 
 
 
    OPTION 'values', in HTML parlance, are Item 'names' in mechanize parlance. 
 
    SELECT control values and labels are subject to some messy defaulting 
    rules.  For example, if the HTML representation of the control is:: 
 
        &lt;SELECT name=year&gt; 
            &lt;OPTION value=0 label=&quot;2002&quot;&gt;current year&lt;/OPTION&gt; 
            &lt;OPTION value=1&gt;2001&lt;/OPTION&gt; 
            &lt;OPTION&gt;2000&lt;/OPTION&gt; 
        &lt;/SELECT&gt; 
 
    The items, in order, have labels &quot;2002&quot;, &quot;2001&quot; and &quot;2000&quot;, whereas their 
    names (the OPTION values) are &quot;0&quot;, &quot;1&quot; and &quot;2000&quot; respectively.  Note that 
    the value of the last OPTION in this example defaults to its contents, as 
    specified by RFC 1866, as do the labels of the second and third OPTIONs. 
 
    The OPTION labels are sometimes more meaningful than the OPTION values, 
    which can make for more maintainable code. 
 
    Additional read-only public attribute: attrs 
 
    The attrs attribute is a dictionary of the original HTML attributes of the 
    SELECT element.  Other ListControls do not have this attribute, because in 
    other cases the control as a whole does not correspond to any single HTML 
    element.  control.get(...).attrs may be used as usual to get at the HTML 
    attributes of the HTML elements corresponding to individual list items (for 
    SELECT controls, these are OPTION elements). 
 
    Another special case is that the Item.attrs dictionaries have a special key 
    &quot;contents&quot; which does not correspond to any real HTML attribute, but rather 
    contains the contents of the OPTION element:: 
 
        &lt;OPTION&gt;this bit&lt;/OPTION&gt; 
 
    &quot;&quot;&quot;</span>

    <span class="s0"># HTML attributes here are treated slightly differently from other list</span>
    <span class="s0"># controls:</span>
    <span class="s0"># -The SELECT HTML attributes dictionary is stuffed into the OPTION</span>
    <span class="s0">#  HTML attributes dictionary under the &quot;__select&quot; key.</span>
    <span class="s0"># -The content of each OPTION element is stored under the special</span>
    <span class="s0">#  &quot;contents&quot; key of the dictionary.</span>
    <span class="s0"># After all this, the dictionary is passed to the SelectControl constructor</span>
    <span class="s0"># as the attrs argument, as usual.  However:</span>
    <span class="s0"># -The first SelectControl constructed when building up a SELECT control</span>
    <span class="s0">#  has a constructor attrs argument containing only the __select key -- so</span>
    <span class="s0">#  this SelectControl represents an empty SELECT control.</span>
    <span class="s0"># -Subsequent SelectControls have both OPTION HTML-attribute in attrs and</span>
    <span class="s0">#  the __select dictionary containing the SELECT HTML-attributes.</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">select_default=</span><span class="s2">False, </span><span class="s1">index=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0"># fish out the SELECT HTML attributes from the OPTION HTML attributes</span>
        <span class="s0"># dictionary</span>
        <span class="s1">self.attrs = dict(attrs[</span><span class="s3">&quot;__select&quot;</span><span class="s1">])</span>
        <span class="s1">self.__dict__[</span><span class="s3">&quot;_label&quot;</span><span class="s1">] = _get_label(self.attrs)</span>
        <span class="s1">self.__dict__[</span><span class="s3">&quot;id&quot;</span><span class="s1">] = self.attrs.get(</span><span class="s3">&quot;id&quot;</span><span class="s1">)</span>
        <span class="s1">self.__dict__[</span><span class="s3">&quot;multiple&quot;</span><span class="s1">] = </span><span class="s3">'multiple' </span><span class="s2">in </span><span class="s1">self.attrs</span>
        <span class="s0"># the majority of the contents, label, and value dance already happened</span>
        <span class="s1">contents = attrs.get(</span><span class="s3">&quot;contents&quot;</span><span class="s1">)</span>
        <span class="s1">attrs = dict(attrs)</span>
        <span class="s2">del </span><span class="s1">attrs[</span><span class="s3">&quot;__select&quot;</span><span class="s1">]</span>

        <span class="s1">ListControl.__init__(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">type</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">,</span>
            <span class="s1">self.attrs</span><span class="s2">,</span>
            <span class="s1">select_default</span><span class="s2">,</span>
            <span class="s1">called_as_base_class=</span><span class="s2">True,</span>
            <span class="s1">index=index)</span>
        <span class="s1">self.disabled = </span><span class="s3">'disabled' </span><span class="s2">in </span><span class="s1">self.attrs</span>
        <span class="s1">self.readonly = </span><span class="s3">'readonly' </span><span class="s2">in </span><span class="s1">self.attrs</span>
        <span class="s2">if </span><span class="s3">'value' </span><span class="s2">in </span><span class="s1">attrs:</span>
            <span class="s0"># otherwise it is a marker 'select started' token</span>
            <span class="s1">o = Item(self</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">index)</span>
            <span class="s1">o.__dict__[</span><span class="s3">&quot;_selected&quot;</span><span class="s1">] = </span><span class="s3">'selected' </span><span class="s2">in </span><span class="s1">attrs</span>
            <span class="s0"># add 'label' label and contents label, if different.  If both are</span>
            <span class="s0"># provided, the 'label' label is used for display in HTML</span>
            <span class="s0"># 4.0-compliant browsers (and any lower spec? not sure) while the</span>
            <span class="s0"># contents are used for display in older or less-compliant</span>
            <span class="s0"># browsers.  We make label objects for both, if the values are</span>
            <span class="s0"># different.</span>
            <span class="s1">label = attrs.get(</span><span class="s3">&quot;label&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">label:</span>
                <span class="s1">o._labels.append(Label(label))</span>
                <span class="s2">if </span><span class="s1">contents </span><span class="s2">and </span><span class="s1">contents != label:</span>
                    <span class="s1">o._labels.append(Label(contents))</span>
            <span class="s2">elif </span><span class="s1">contents:</span>
                <span class="s1">o._labels.append(Label(contents))</span>

    <span class="s2">def </span><span class="s1">fixup(self):</span>
        <span class="s1">ListControl.fixup(self)</span>
        <span class="s0"># Firefox doesn't exclude disabled items from those considered here</span>
        <span class="s0"># (i.e. from 'found', for both branches of the if below).  Note that</span>
        <span class="s0"># IE6 doesn't support the disabled attribute on OPTIONs at all.</span>
        <span class="s1">found = [o </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">self.items </span><span class="s2">if </span><span class="s1">o.selected]</span>
        <span class="s2">if not </span><span class="s1">found:</span>
            <span class="s2">if not </span><span class="s1">self.multiple </span><span class="s2">or </span><span class="s1">self._select_default:</span>
                <span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">self.items:</span>
                    <span class="s2">if not </span><span class="s1">o.disabled:</span>
                        <span class="s1">was_disabled = self.disabled</span>
                        <span class="s1">self.disabled = </span><span class="s2">False</span>
                        <span class="s2">try</span><span class="s1">:</span>
                            <span class="s1">o.selected = </span><span class="s2">True</span>
                        <span class="s2">finally</span><span class="s1">:</span>
                            <span class="s1">o.disabled = was_disabled</span>
                        <span class="s2">break</span>
        <span class="s2">elif not </span><span class="s1">self.multiple:</span>
            <span class="s0"># Ensure only one item selected.  Choose the last one,</span>
            <span class="s0"># following IE and Firefox.</span>
            <span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">found[:-</span><span class="s4">1</span><span class="s1">]:</span>
                <span class="s1">o.selected = </span><span class="s2">False</span>


<span class="s0"># ---------------------------------------------------</span>
<span class="s2">class </span><span class="s1">SubmitControl(ScalarControl):</span>
    <span class="s5">&quot;&quot;&quot; 
    Covers: 
 
    INPUT/SUBMIT 
    BUTTON/SUBMIT 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">ScalarControl.__init__(self</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">index)</span>
        <span class="s0"># IE5 defaults SUBMIT value to &quot;Submit Query&quot;; Firebird 0.6 leaves it</span>
        <span class="s0"># blank, Konqueror 3.1 defaults to &quot;Submit&quot;.  HTML spec. doesn't seem</span>
        <span class="s0"># to define this.</span>
        <span class="s2">if </span><span class="s1">self.value </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.__dict__[</span><span class="s3">'_value'</span><span class="s1">] = </span><span class="s3">&quot;&quot;</span>
        <span class="s1">self.readonly = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_labels(self):</span>
        <span class="s1">res = []</span>
        <span class="s2">if </span><span class="s1">self.value:</span>
            <span class="s1">res.append(Label(self.value))</span>
        <span class="s1">res.extend(ScalarControl.get_labels(self))</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">def </span><span class="s1">is_of_kind(self</span><span class="s2">, </span><span class="s1">kind):</span>
        <span class="s2">return </span><span class="s1">kind == </span><span class="s3">&quot;clickable&quot;</span>

    <span class="s2">def </span><span class="s1">_click(self</span><span class="s2">, </span><span class="s1">form</span><span class="s2">, </span><span class="s1">coord</span><span class="s2">, </span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">request_class=_request.Request):</span>
        <span class="s1">self._clicked = coord</span>
        <span class="s1">r = form._switch_click(return_type</span><span class="s2">, </span><span class="s1">request_class)</span>
        <span class="s1">self._clicked = </span><span class="s2">False</span>
        <span class="s2">return </span><span class="s1">r</span>

    <span class="s2">def </span><span class="s1">_totally_ordered_pairs(self):</span>
        <span class="s2">if not </span><span class="s1">self._clicked:</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s2">return </span><span class="s1">ScalarControl._totally_ordered_pairs(self)</span>


<span class="s0"># ---------------------------------------------------</span>
<span class="s2">class </span><span class="s1">ImageControl(SubmitControl):</span>
    <span class="s5">&quot;&quot;&quot; 
    Covers: 
 
    INPUT/IMAGE 
 
    Coordinates are specified using one of the HTMLForm.click* methods. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">index=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">SubmitControl.__init__(self</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">index)</span>
        <span class="s1">self.readonly = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">_totally_ordered_pairs(self):</span>
        <span class="s1">clicked = self._clicked</span>
        <span class="s2">if </span><span class="s1">self.disabled </span><span class="s2">or not </span><span class="s1">clicked:</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s1">name = self.name</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s1">pairs = [</span>
            <span class="s1">(self._index</span><span class="s2">, </span><span class="s3">&quot;%s.x&quot; </span><span class="s1">% name</span><span class="s2">, </span><span class="s1">str(clicked[</span><span class="s4">0</span><span class="s1">]))</span><span class="s2">,</span>
            <span class="s1">(self._index + </span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;%s.y&quot; </span><span class="s1">% name</span><span class="s2">, </span><span class="s1">str(clicked[</span><span class="s4">1</span><span class="s1">]))</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">value = self._value</span>
        <span class="s2">if </span><span class="s1">value:</span>
            <span class="s1">pairs.append((self._index + </span><span class="s4">2</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value))</span>
        <span class="s2">return </span><span class="s1">pairs</span>

    <span class="s1">get_labels = ScalarControl.get_labels</span>


<span class="s0"># aliases, just to make str(control) and str(form) clearer</span>
<span class="s2">class </span><span class="s1">PasswordControl(TextControl):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">HiddenControl(TextControl):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TextareaControl(TextControl):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">SubmitButtonControl(SubmitControl):</span>
    <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">is_listcontrol(control):</span>
    <span class="s2">return </span><span class="s1">control.is_of_kind(</span><span class="s3">&quot;list&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">HTMLForm:</span>
    <span class="s5">&quot;&quot;&quot; 
    Represents a single HTML &lt;form&gt; ... &lt;/form&gt; element. 
 
    A form consists of a sequence of controls that usually have names, and 
    which can take on various values.  The values of the various types of 
    controls represent variously: text, zero-or-one-of-many or many-of-many 
    choices, and files to be uploaded.  Some controls can be clicked on to 
    submit the form, and clickable controls' values sometimes include the 
    coordinates of the click. 
 
    Forms can be filled in with data to be returned to the server, and then 
    submitted, using the click method to generate a request object suitable for 
    passing to :func:`mechanize.urlopen` (or the click_request_data or 
    click_pairs methods for integration with third-party code). 
 
    Usually, HTMLForm instances are not created directly.  Instead, they are 
    automatically created when visting a page with a mechanize Browser.  If you 
    do construct HTMLForm objects yourself, however, note that an HTMLForm 
    instance is only properly initialised after the fixup method has been 
    called.  See :class:`mechanize.ListControl` for the reason this is 
    required. 
 
    Indexing a form (form[&quot;control_name&quot;]) returns the named Control's value 
    attribute.  Assignment to a form index (form[&quot;control_name&quot;] = something) 
    is equivalent to assignment to the named Control's value attribute.  If you 
    need to be more specific than just supplying the control's name, use the 
    set_value and get_value methods. 
 
    ListControl values are lists of item names (specifically, the names of the 
    items that are selected and not disabled, and hence are &quot;successful&quot; -- ie. 
    cause data to be returned to the server).  The list item's name is the 
    value of the corresponding HTML element's&quot;value&quot; attribute. 
 
    Example:: 
 
      &lt;INPUT type=&quot;CHECKBOX&quot; name=&quot;cheeses&quot; value=&quot;leicester&quot;&gt;&lt;/INPUT&gt; 
      &lt;INPUT type=&quot;CHECKBOX&quot; name=&quot;cheeses&quot; value=&quot;cheddar&quot;&gt;&lt;/INPUT&gt; 
 
    defines a CHECKBOX control with name &quot;cheeses&quot; which has two items, named 
    &quot;leicester&quot; and &quot;cheddar&quot;. 
 
    Another example:: 
 
      &lt;SELECT name=&quot;more_cheeses&quot;&gt; 
        &lt;OPTION&gt;1&lt;/OPTION&gt; 
        &lt;OPTION value=&quot;2&quot; label=&quot;CHEDDAR&quot;&gt;cheddar&lt;/OPTION&gt; 
      &lt;/SELECT&gt; 
 
    defines a SELECT control with name &quot;more_cheeses&quot; which has two items, 
    named &quot;1&quot; and &quot;2&quot; (because the OPTION element's value HTML attribute 
    defaults to the element contents -- see :class:`mechanize.SelectControl` 
    for more on these defaulting rules). 
 
    To select, deselect or otherwise manipulate individual list items, use the 
    :meth:`mechanize.HTMLForm.find_control()` and 
    :meth:`mechanize.ListControl.get()` methods.  To set the whole value, do as 
    for any other control: use indexing or the `set_value/get_value` methods. 
 
    Example: 
 
    .. code-block:: python 
 
        # select *only* the item named &quot;cheddar&quot; 
        form[&quot;cheeses&quot;] = [&quot;cheddar&quot;] 
        # select &quot;cheddar&quot;, leave other items unaffected 
        form.find_control(&quot;cheeses&quot;).get(&quot;cheddar&quot;).selected = True 
 
    Some controls (RADIO and SELECT without the multiple attribute) can only 
    have zero or one items selected at a time.  Some controls (CHECKBOX and 
    SELECT with the multiple attribute) can have multiple items selected at a 
    time.  To set the whole value of a ListControl, assign a sequence to a form 
    index: 
 
    .. code-block:: python 
 
        form[&quot;cheeses&quot;] = [&quot;cheddar&quot;, &quot;leicester&quot;] 
 
    If the ListControl is not multiple-selection, the assigned list must be of 
    length one. 
 
    To check if a control has an item, if an item is selected, or if an item is 
    successful (selected and not disabled), respectively: 
 
    .. code-block:: python 
 
        &quot;cheddar&quot; in [item.name for item in form.find_control(&quot;cheeses&quot;).items] 
        &quot;cheddar&quot; in [item.name for item in form.find_control(&quot;cheeses&quot;).items 
                        and item.selected] 
        &quot;cheddar&quot; in form[&quot;cheeses&quot;] 
        # or 
        &quot;cheddar&quot; in form.get_value(&quot;cheeses&quot;) 
 
    Note that some list items may be disabled (see below). 
 
    Note the following mistake: 
 
    .. code-block:: python 
 
        form[control_name] = control_value 
        assert form[control_name] == control_value  # not necessarily true 
 
    The reason for this is that form[control_name] always gives the list items 
    in the order they were listed in the HTML. 
 
    List items (hence list values, too) can be referred to in terms of list 
    item labels rather than list item names using the appropriate label 
    arguments.  Note that each item may have several labels. 
 
    The question of default values of OPTION contents, labels and values is 
    somewhat complicated: see :class:`mechanize.SelectControl` and 
    :meth:`mechanize.ListControl.get_item_attrs()` if you think you need to 
    know. 
 
    Controls can be disabled or readonly.  In either case, the control's value 
    cannot be changed until you clear those flags (see example below). 
    Disabled is the state typically represented by browsers by 'greying out' a 
    control.  Disabled controls are not 'successful' -- they don't cause data 
    to get returned to the server.  Readonly controls usually appear in 
    browsers as read-only text boxes.  Readonly controls are successful.  List 
    items can also be disabled.  Attempts to select or deselect disabled items 
    fail with AttributeError. 
 
    If a lot of controls are readonly, it can be useful to do this: 
 
    .. code-block:: python 
 
        form.set_all_readonly(False) 
 
    To clear a control's value attribute, so that it is not successful (until a 
    value is subsequently set): 
 
    .. code-block:: python 
 
        form.clear(&quot;cheeses&quot;) 
 
    More examples: 
 
    .. code-block:: python 
 
        control = form.find_control(&quot;cheeses&quot;) 
        control.disabled = False 
        control.readonly = False 
        control.get(&quot;gruyere&quot;).disabled = True 
        control.items[0].selected = True 
 
    See the various Control classes for further documentation.  Many methods 
    take name, type, kind, id, label and nr arguments to specify the control to 
    be operated on: see :meth:`mechanize.HTMLForm.find_control()`. 
 
    ControlNotFoundError (subclass of ValueError) is raised if the specified 
    control can't be found.  This includes occasions where a non-ListControl 
    is found, but the method (set, for example) requires a ListControl. 
    ItemNotFoundError (subclass of ValueError) is raised if a list item can't 
    be found.  ItemCountError (subclass of ValueError) is raised if an attempt 
    is made to select more than one item and the control doesn't allow that, or 
    set/get_single are called and the control contains more than one item. 
    AttributeError is raised if a control or item is readonly or disabled and 
    an attempt is made to alter its value. 
 
    Security note: Remember that any passwords you store in HTMLForm instances 
    will be saved to disk in the clear if you pickle them (directly or 
    indirectly).  The simplest solution to this is to avoid pickling HTMLForm 
    objects.  You could also pickle before filling in any password, or just set 
    the password to &quot;&quot; before pickling. 
 
 
    Public attributes: 
 
    :ivar action: full (absolute URI) form action 
    :ivar method: &quot;GET&quot; or &quot;POST&quot; 
    :ivar enctype: form transfer encoding MIME type 
    :ivar name: name of form (None if no name was specified) 
    :ivar attrs: dictionary mapping original HTML form attributes to their 
        values 
    :ivar controls: list of Control instances; do not alter this list 
        (instead, call form.new_control to make a Control and add it to the 
        form, or control.add_to_form if you already have a Control instance) 
 
 
 
    Methods for form filling: 
 
    Most of the these methods have very similar arguments.  See 
    :meth:`mechanize.HTMLForm.find_control()` for details of the name, type, 
    kind, label and nr arguments. 
 
    .. code-block:: python 
 
        def find_control(self, 
                        name=None, type=None, kind=None, id=None, 
                        predicate=None, nr=None, label=None) 
 
        get_value(name=None, type=None, kind=None, id=None, nr=None, 
                by_label=False,  # by_label is deprecated 
                label=None) 
        set_value(value, 
                name=None, type=None, kind=None, id=None, nr=None, 
                by_label=False,  # by_label is deprecated 
                label=None) 
 
        clear_all() 
        clear(name=None, type=None, kind=None, id=None, nr=None, label=None) 
 
        set_all_readonly(readonly) 
 
 
    Method applying only to FileControls: 
 
    .. code-block:: python 
 
        add_file(file_object, 
             content_type=&quot;application/octet-stream&quot;, filename=None, 
             name=None, id=None, nr=None, label=None) 
 
 
    Methods applying only to clickable controls: 
 
    .. code-block:: python 
 
        click(name=None, type=None, id=None, nr=0, coord=(1,1), label=None) 
        click_request_data(name=None, type=None, id=None, nr=0, coord=(1,1), 
                        label=None) 
        click_pairs(name=None, type=None, id=None, nr=0, coord=(1,1), 
                        label=None) 
 
    &quot;&quot;&quot;</span>

    <span class="s1">type2class = {</span>
        <span class="s3">&quot;text&quot;</span><span class="s1">: TextControl</span><span class="s2">,</span>
        <span class="s3">&quot;password&quot;</span><span class="s1">: PasswordControl</span><span class="s2">,</span>
        <span class="s3">&quot;hidden&quot;</span><span class="s1">: HiddenControl</span><span class="s2">,</span>
        <span class="s3">&quot;textarea&quot;</span><span class="s1">: TextareaControl</span><span class="s2">,</span>
        <span class="s3">&quot;file&quot;</span><span class="s1">: FileControl</span><span class="s2">,</span>
        <span class="s3">&quot;button&quot;</span><span class="s1">: IgnoreControl</span><span class="s2">,</span>
        <span class="s3">&quot;buttonbutton&quot;</span><span class="s1">: IgnoreControl</span><span class="s2">,</span>
        <span class="s3">&quot;reset&quot;</span><span class="s1">: IgnoreControl</span><span class="s2">,</span>
        <span class="s3">&quot;resetbutton&quot;</span><span class="s1">: IgnoreControl</span><span class="s2">,</span>
        <span class="s3">&quot;submit&quot;</span><span class="s1">: SubmitControl</span><span class="s2">,</span>
        <span class="s3">&quot;submitbutton&quot;</span><span class="s1">: SubmitButtonControl</span><span class="s2">,</span>
        <span class="s3">&quot;image&quot;</span><span class="s1">: ImageControl</span><span class="s2">,</span>
        <span class="s3">&quot;radio&quot;</span><span class="s1">: RadioControl</span><span class="s2">,</span>
        <span class="s3">&quot;checkbox&quot;</span><span class="s1">: CheckboxControl</span><span class="s2">,</span>
        <span class="s3">&quot;select&quot;</span><span class="s1">: SelectControl</span><span class="s2">,</span>
    <span class="s1">}</span>

    <span class="s0"># ---------------------------------------------------</span>
    <span class="s0"># Initialisation.  Use ParseResponse / ParseFile instead.</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">,</span>
                 <span class="s1">action</span><span class="s2">,</span>
                 <span class="s1">method=</span><span class="s3">&quot;GET&quot;</span><span class="s2">,</span>
                 <span class="s1">enctype=</span><span class="s3">&quot;application/x-www-form-urlencoded&quot;</span><span class="s2">,</span>
                 <span class="s1">name=</span><span class="s2">None,</span>
                 <span class="s1">attrs=</span><span class="s2">None,</span>
                 <span class="s1">request_class=_request.Request</span><span class="s2">,</span>
                 <span class="s1">forms=</span><span class="s2">None,</span>
                 <span class="s1">labels=</span><span class="s2">None,</span>
                 <span class="s1">id_to_labels=</span><span class="s2">None,</span>
                 <span class="s1">encoding=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        In the usual case, use ParseResponse (or ParseFile) to create new 
        HTMLForm objects. 
 
        action: full (absolute URI) form action 
        method: &quot;GET&quot; or &quot;POST&quot; 
        enctype: form transfer encoding MIME type 
        name: name of form 
        attrs: dictionary mapping original HTML form attributes to their values 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.action = action</span>
        <span class="s1">self.method = method</span>
        <span class="s1">self.enctype = enctype</span>
        <span class="s1">self.form_encoding = encoding </span><span class="s2">or </span><span class="s3">'utf-8'</span>
        <span class="s1">self.name = name</span>
        <span class="s2">if </span><span class="s1">attrs </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.attrs = dict(attrs)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.attrs = {}</span>
        <span class="s1">self.controls = []</span>
        <span class="s1">self._request_class = request_class</span>

        <span class="s0"># these attributes are used by zope.testbrowser</span>
        <span class="s1">self._forms = forms  </span><span class="s0"># this is a semi-public API!</span>
        <span class="s1">self._labels = labels  </span><span class="s0"># this is a semi-public API!</span>
        <span class="s1">self._id_to_labels = id_to_labels  </span><span class="s0"># this is a semi-public API!</span>

        <span class="s1">self._urlunparse = urlunparse</span>
        <span class="s1">self._urlparse = urlparse</span>

    <span class="s2">def </span><span class="s1">new_control(self</span><span class="s2">,</span>
                    <span class="s1">type</span><span class="s2">,</span>
                    <span class="s1">name</span><span class="s2">,</span>
                    <span class="s1">attrs</span><span class="s2">,</span>
                    <span class="s1">ignore_unknown=</span><span class="s2">False,</span>
                    <span class="s1">select_default=</span><span class="s2">False,</span>
                    <span class="s1">index=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Adds a new control to the form. 
 
        This is usually called by mechanize.  Don't call it 
        yourself unless you're building your own Control instances. 
 
        Note that controls representing lists of items are built up from 
        controls holding only a single list item.  See 
        :class:`mechanize.ListControl` for further information. 
 
        :arg type: type of control (see :class:`mechanize.Control` for a list) 
        :arg attrs: HTML attributes of control 
        :arg ignore_unknown: if true, use a dummy Control instance for controls 
            of unknown type; otherwise, use a TextControl 
        :arg select_default: for RADIO and multiple-selection SELECT controls, 
            pick the first item as the default if no 'selected' HTML attribute 
            is present (this defaulting happens when the HTMLForm.fixup method 
            is called) 
        :arg index: index of corresponding element in HTML (see 
            MoreFormTests.test_interspersed_controls for motivation) 
 
        &quot;&quot;&quot;</span>
        <span class="s1">type = type.lower()</span>
        <span class="s1">klass = self.type2class.get(type)</span>
        <span class="s2">if </span><span class="s1">klass </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">ignore_unknown:</span>
                <span class="s1">klass = IgnoreControl</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">klass = TextControl</span>

        <span class="s1">a = dict(attrs)</span>
        <span class="s2">if </span><span class="s1">issubclass(klass</span><span class="s2">, </span><span class="s1">ListControl):</span>
            <span class="s1">control = klass(type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">select_default</span><span class="s2">, </span><span class="s1">index)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">control = klass(type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">index)</span>

        <span class="s2">if </span><span class="s1">type == </span><span class="s3">&quot;select&quot; </span><span class="s2">and </span><span class="s1">len(attrs) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range(len(self.controls) - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">):</span>
                <span class="s1">ctl = self.controls[ii]</span>
                <span class="s2">if </span><span class="s1">ctl.type == </span><span class="s3">&quot;select&quot;</span><span class="s1">:</span>
                    <span class="s1">ctl.close_control()</span>
                    <span class="s2">break</span>

        <span class="s1">control.add_to_form(self)</span>
        <span class="s1">control._urlparse = self._urlparse</span>
        <span class="s1">control._urlunparse = self._urlunparse</span>

    <span class="s2">def </span><span class="s1">fixup(self):</span>
        <span class="s5">&quot;&quot;&quot;Normalise form after all controls have been added. 
 
        This is usually called by ParseFile and ParseResponse.  Don't call it 
        youself unless you're building your own Control instances. 
 
        This method should only be called once, after all controls have been 
        added to the form. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">control </span><span class="s2">in </span><span class="s1">self.controls:</span>
            <span class="s1">control.fixup()</span>
            <span class="s1">control.form_encoding = self.form_encoding</span>

<span class="s0"># ---------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s1">header = </span><span class="s3">&quot;%s%s %s %s&quot; </span><span class="s1">% ((self.name </span><span class="s2">and </span><span class="s1">self.name + </span><span class="s3">&quot; &quot; </span><span class="s2">or </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
                                 <span class="s1">self.method</span><span class="s2">, </span><span class="s1">self.action</span><span class="s2">, </span><span class="s1">self.enctype)</span>
        <span class="s1">rep = [header]</span>
        <span class="s2">for </span><span class="s1">control </span><span class="s2">in </span><span class="s1">self.controls:</span>
            <span class="s1">rep.append(</span><span class="s3">&quot;  %s&quot; </span><span class="s1">% str(control))</span>
        <span class="s2">return </span><span class="s3">&quot;&lt;%s&gt;&quot; </span><span class="s1">% </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join(rep)</span>

<span class="s0"># ---------------------------------------------------</span>
<span class="s0"># Form-filling methods.</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">return </span><span class="s1">self.find_control(name).value</span>

    <span class="s2">def </span><span class="s1">__contains__(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">return </span><span class="s1">bool(self.find_control(name))</span>

    <span class="s2">def </span><span class="s1">__setitem__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">control = self.find_control(name)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">control.value = value</span>
        <span class="s2">except </span><span class="s1">AttributeError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">ValueError(str(e))</span>

    <span class="s2">def </span><span class="s1">get_value(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">name=</span><span class="s2">None,</span>
            <span class="s1">type=</span><span class="s2">None,</span>
            <span class="s1">kind=</span><span class="s2">None,</span>
            <span class="s1">id=</span><span class="s2">None,</span>
            <span class="s1">nr=</span><span class="s2">None,</span>
            <span class="s1">by_label=</span><span class="s2">False,  </span><span class="s0"># by_label is deprecated</span>
            <span class="s1">label=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Return value of control. 
 
        If only name and value arguments are supplied, equivalent to 
 
        .. code-block:: python 
 
            form[name] 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">by_label:</span>
            <span class="s1">deprecation(</span><span class="s3">&quot;form.get_value_by_label(...)&quot;</span><span class="s1">)</span>
        <span class="s1">c = self.find_control(name</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">label=label</span><span class="s2">, </span><span class="s1">nr=nr)</span>
        <span class="s2">if </span><span class="s1">by_label:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">meth = c.get_value_by_label</span>
            <span class="s2">except </span><span class="s1">AttributeError:</span>
                <span class="s2">raise </span><span class="s1">NotImplementedError(</span>
                    <span class="s3">&quot;control '%s' does not yet support by_label&quot; </span><span class="s1">% c.name)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">meth()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">c.value</span>

    <span class="s2">def </span><span class="s1">set_value(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">value</span><span class="s2">,</span>
            <span class="s1">name=</span><span class="s2">None,</span>
            <span class="s1">type=</span><span class="s2">None,</span>
            <span class="s1">kind=</span><span class="s2">None,</span>
            <span class="s1">id=</span><span class="s2">None,</span>
            <span class="s1">nr=</span><span class="s2">None,</span>
            <span class="s1">by_label=</span><span class="s2">False,  </span><span class="s0"># by_label is deprecated</span>
            <span class="s1">label=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Set value of control. 
 
        If only name and value arguments are supplied, equivalent to 
 
        .. code-block:: python 
 
            form[name] = value 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">by_label:</span>
            <span class="s1">deprecation(</span><span class="s3">&quot;form.get_value_by_label(...)&quot;</span><span class="s1">)</span>
        <span class="s1">c = self.find_control(name</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">label=label</span><span class="s2">, </span><span class="s1">nr=nr)</span>
        <span class="s2">if </span><span class="s1">by_label:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">meth = c.set_value_by_label</span>
            <span class="s2">except </span><span class="s1">AttributeError:</span>
                <span class="s2">raise </span><span class="s1">NotImplementedError(</span>
                    <span class="s3">&quot;control '%s' does not yet support by_label&quot; </span><span class="s1">% c.name)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">meth(value)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">c.value = value</span>

    <span class="s2">def </span><span class="s1">get_value_by_label(self</span><span class="s2">,</span>
                           <span class="s1">name=</span><span class="s2">None,</span>
                           <span class="s1">type=</span><span class="s2">None,</span>
                           <span class="s1">kind=</span><span class="s2">None,</span>
                           <span class="s1">id=</span><span class="s2">None,</span>
                           <span class="s1">label=</span><span class="s2">None,</span>
                           <span class="s1">nr=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
 
        All arguments should be passed by name. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">c = self.find_control(name</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">label=label</span><span class="s2">, </span><span class="s1">nr=nr)</span>
        <span class="s2">return </span><span class="s1">c.get_value_by_label()</span>

    <span class="s2">def </span><span class="s1">set_value_by_label(self</span><span class="s2">,</span>
                           <span class="s1">value</span><span class="s2">,</span>
                           <span class="s1">name=</span><span class="s2">None,</span>
                           <span class="s1">type=</span><span class="s2">None,</span>
                           <span class="s1">kind=</span><span class="s2">None,</span>
                           <span class="s1">id=</span><span class="s2">None,</span>
                           <span class="s1">label=</span><span class="s2">None,</span>
                           <span class="s1">nr=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
 
        All arguments should be passed by name. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">c = self.find_control(name</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">label=label</span><span class="s2">, </span><span class="s1">nr=nr)</span>
        <span class="s1">c.set_value_by_label(value)</span>

    <span class="s2">def </span><span class="s1">set_all_readonly(self</span><span class="s2">, </span><span class="s1">readonly):</span>
        <span class="s2">for </span><span class="s1">control </span><span class="s2">in </span><span class="s1">self.controls:</span>
            <span class="s1">control.readonly = bool(readonly)</span>

    <span class="s2">def </span><span class="s1">clear_all(self):</span>
        <span class="s5">&quot;&quot;&quot;Clear the value attributes of all controls in the form. 
 
        See :meth:`mechanize.HTMLForm.clear()` 
 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">control </span><span class="s2">in </span><span class="s1">self.controls:</span>
            <span class="s1">control.clear()</span>

    <span class="s2">def </span><span class="s1">clear(self</span><span class="s2">,</span>
              <span class="s1">name=</span><span class="s2">None,</span>
              <span class="s1">type=</span><span class="s2">None,</span>
              <span class="s1">kind=</span><span class="s2">None,</span>
              <span class="s1">id=</span><span class="s2">None,</span>
              <span class="s1">nr=</span><span class="s2">None,</span>
              <span class="s1">label=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Clear the value attribute of a control. 
 
        As a result, the affected control will not be successful until a value 
        is subsequently set.  AttributeError is raised on readonly controls. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">c = self.find_control(name</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">label=label</span><span class="s2">, </span><span class="s1">nr=nr)</span>
        <span class="s1">c.clear()</span>

<span class="s0"># ---------------------------------------------------</span>
<span class="s0"># Form-filling methods applying only to ListControls.</span>

    <span class="s2">def </span><span class="s1">possible_items(</span>
            <span class="s1">self</span><span class="s2">,  </span><span class="s0"># deprecated</span>
            <span class="s1">name=</span><span class="s2">None,</span>
            <span class="s1">type=</span><span class="s2">None,</span>
            <span class="s1">kind=</span><span class="s2">None,</span>
            <span class="s1">id=</span><span class="s2">None,</span>
            <span class="s1">nr=</span><span class="s2">None,</span>
            <span class="s1">by_label=</span><span class="s2">False,</span>
            <span class="s1">label=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Return a list of all values that the specified control can take.&quot;&quot;&quot;</span>
        <span class="s1">c = self._find_list_control(name</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">label</span><span class="s2">, </span><span class="s1">nr)</span>
        <span class="s2">return </span><span class="s1">c.possible_items(by_label)</span>

    <span class="s2">def </span><span class="s1">set(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">selected</span><span class="s2">,</span>
            <span class="s1">item_name</span><span class="s2">,  </span><span class="s0"># deprecated</span>
            <span class="s1">name=</span><span class="s2">None,</span>
            <span class="s1">type=</span><span class="s2">None,</span>
            <span class="s1">kind=</span><span class="s2">None,</span>
            <span class="s1">id=</span><span class="s2">None,</span>
            <span class="s1">nr=</span><span class="s2">None,</span>
            <span class="s1">by_label=</span><span class="s2">False,</span>
            <span class="s1">label=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Select / deselect named list item. 
 
        :arg selected: boolean selected state 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._find_list_control(name</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">label</span><span class="s2">, </span><span class="s1">nr).set(</span>
            <span class="s1">selected</span><span class="s2">, </span><span class="s1">item_name</span><span class="s2">, </span><span class="s1">by_label)</span>

    <span class="s2">def </span><span class="s1">toggle(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">item_name</span><span class="s2">,  </span><span class="s0"># deprecated</span>
            <span class="s1">name=</span><span class="s2">None,</span>
            <span class="s1">type=</span><span class="s2">None,</span>
            <span class="s1">kind=</span><span class="s2">None,</span>
            <span class="s1">id=</span><span class="s2">None,</span>
            <span class="s1">nr=</span><span class="s2">None,</span>
            <span class="s1">by_label=</span><span class="s2">False,</span>
            <span class="s1">label=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Toggle selected state of named list item.&quot;&quot;&quot;</span>
        <span class="s1">self._find_list_control(name</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">label</span><span class="s2">, </span><span class="s1">nr).toggle(</span>
            <span class="s1">item_name</span><span class="s2">, </span><span class="s1">by_label)</span>

    <span class="s2">def </span><span class="s1">set_single(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">selected</span><span class="s2">,  </span><span class="s0"># deprecated</span>
            <span class="s1">name=</span><span class="s2">None,</span>
            <span class="s1">type=</span><span class="s2">None,</span>
            <span class="s1">kind=</span><span class="s2">None,</span>
            <span class="s1">id=</span><span class="s2">None,</span>
            <span class="s1">nr=</span><span class="s2">None,</span>
            <span class="s1">by_label=</span><span class="s2">None,</span>
            <span class="s1">label=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Select / deselect list item in a control having only one item. 
 
        If the control has multiple list items, ItemCountError is raised. 
 
        This is just a convenience method, so you don't need to know the item's 
        name -- the item name in these single-item controls is usually 
        something meaningless like &quot;1&quot; or &quot;on&quot;. 
 
        For example, if a checkbox has a single item named &quot;on&quot;, the following 
        two calls are equivalent: 
 
        .. code-block:: python 
 
            control.toggle(&quot;on&quot;) 
            control.toggle_single() 
 
        &quot;&quot;&quot;  </span><span class="s0"># by_label ignored and deprecated</span>
        <span class="s1">self._find_list_control(name</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">label</span><span class="s2">,</span>
                                <span class="s1">nr).set_single(selected)</span>

    <span class="s2">def </span><span class="s1">toggle_single(self</span><span class="s2">,</span>
                      <span class="s1">name=</span><span class="s2">None,</span>
                      <span class="s1">type=</span><span class="s2">None,</span>
                      <span class="s1">kind=</span><span class="s2">None,</span>
                      <span class="s1">id=</span><span class="s2">None,</span>
                      <span class="s1">nr=</span><span class="s2">None,</span>
                      <span class="s1">by_label=</span><span class="s2">None,</span>
                      <span class="s1">label=</span><span class="s2">None</span><span class="s1">):  </span><span class="s0"># deprecated</span>
        <span class="s3">&quot;&quot;&quot;Toggle selected state of list item in control having only one item. 
 
        The rest is as for :meth:`mechanize.HTMLForm.set_single()` 
 
        &quot;&quot;&quot;  </span><span class="s0"># by_label ignored and deprecated</span>
        <span class="s1">self._find_list_control(name</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">label</span><span class="s2">,</span>
                                <span class="s1">nr).toggle_single()</span>

<span class="s0"># ---------------------------------------------------</span>
<span class="s0"># Form-filling method applying only to FileControls.</span>

    <span class="s2">def </span><span class="s1">add_file(self</span><span class="s2">,</span>
                 <span class="s1">file_object</span><span class="s2">,</span>
                 <span class="s1">content_type=</span><span class="s2">None,</span>
                 <span class="s1">filename=</span><span class="s2">None,</span>
                 <span class="s1">name=</span><span class="s2">None,</span>
                 <span class="s1">id=</span><span class="s2">None,</span>
                 <span class="s1">nr=</span><span class="s2">None,</span>
                 <span class="s1">label=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Add a file to be uploaded. 
 
        :arg file_object: file-like object (with read method) from which to 
            read data to upload 
        :arg content_type: MIME content type of data to upload 
        :arg filename: filename to pass to server 
 
        If filename is None, no filename is sent to the server. 
 
        If content_type is None, the content type is guessed based on the 
        filename and the data from read from the file object. 
 
        At the moment, guessed content type is always application/octet-stream. 
 
        Note the following useful HTML attributes of file upload controls (see 
        HTML 4.01 spec, section 17): 
 
          * `accept`: comma-separated list of content types 
             that the server will handle correctly; 
             you can use this to filter out non-conforming files 
          * `size`: XXX IIRC, this is indicative of whether form 
             wants multiple or single files 
          * `maxlength`: XXX hint of max content length in bytes? 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.find_control(</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s3">&quot;file&quot;</span><span class="s2">, </span><span class="s1">id=id</span><span class="s2">, </span><span class="s1">label=label</span><span class="s2">,</span>
            <span class="s1">nr=nr).add_file(file_object</span><span class="s2">, </span><span class="s1">content_type</span><span class="s2">, </span><span class="s1">filename)</span>

<span class="s0"># ---------------------------------------------------</span>
<span class="s0"># Form submission methods, applying only to clickable controls.</span>

    <span class="s2">def </span><span class="s1">click(self</span><span class="s2">,</span>
              <span class="s1">name=</span><span class="s2">None,</span>
              <span class="s1">type=</span><span class="s2">None,</span>
              <span class="s1">id=</span><span class="s2">None,</span>
              <span class="s1">nr=</span><span class="s4">0</span><span class="s2">,</span>
              <span class="s1">coord=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
              <span class="s1">request_class=_request.Request</span><span class="s2">,</span>
              <span class="s1">label=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Return request that would result from clicking on a control. 
 
        The request object is a mechanize.Request instance, which you can pass 
        to mechanize.urlopen. 
 
        Only some control types (INPUT/SUBMIT &amp; BUTTON/SUBMIT buttons and 
        IMAGEs) can be clicked. 
 
        Will click on the first clickable control, subject to the name, type 
        and nr arguments (as for find_control).  If no name, type, id or number 
        is specified and there are no clickable controls, a request will be 
        returned for the form in its current, un-clicked, state. 
 
        IndexError is raised if any of name, type, id or nr is specified but no 
        matching control is found.  ValueError is raised if the HTMLForm has an 
        enctype attribute that is not recognised. 
 
        You can optionally specify a coordinate to click at, which only makes a 
        difference if you clicked on an image. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._click(name</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">label</span><span class="s2">, </span><span class="s1">nr</span><span class="s2">, </span><span class="s1">coord</span><span class="s2">, </span><span class="s3">&quot;request&quot;</span><span class="s2">,</span>
                           <span class="s1">self._request_class)</span>

    <span class="s2">def </span><span class="s1">click_request_data(self</span><span class="s2">,</span>
                           <span class="s1">name=</span><span class="s2">None,</span>
                           <span class="s1">type=</span><span class="s2">None,</span>
                           <span class="s1">id=</span><span class="s2">None,</span>
                           <span class="s1">nr=</span><span class="s4">0</span><span class="s2">,</span>
                           <span class="s1">coord=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                           <span class="s1">request_class=_request.Request</span><span class="s2">,</span>
                           <span class="s1">label=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;As for click method, but return a tuple (url, data, headers). 
 
        You can use this data to send a request to the server.  This is useful 
        if you're using httplib or urllib rather than mechanize.  Otherwise, 
        use the click method. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._click(name</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">label</span><span class="s2">, </span><span class="s1">nr</span><span class="s2">, </span><span class="s1">coord</span><span class="s2">, </span><span class="s3">&quot;request_data&quot;</span><span class="s2">,</span>
                           <span class="s1">self._request_class)</span>

    <span class="s2">def </span><span class="s1">click_pairs(self</span><span class="s2">,</span>
                    <span class="s1">name=</span><span class="s2">None,</span>
                    <span class="s1">type=</span><span class="s2">None,</span>
                    <span class="s1">id=</span><span class="s2">None,</span>
                    <span class="s1">nr=</span><span class="s4">0</span><span class="s2">,</span>
                    <span class="s1">coord=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">label=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;As for click_request_data, but returns a list of (key, value) pairs. 
 
        You can use this list as an argument to urllib.urlencode.  This is 
        usually only useful if you're using httplib or urllib rather than 
        mechanize.  It may also be useful if you want to manually tweak the 
        keys and/or values, but this should not be necessary.  Otherwise, use 
        the click method. 
 
        Note that this method is only useful for forms of MIME type 
        x-www-form-urlencoded.  In particular, it does not return the 
        information required for file upload.  If you need file upload and are 
        not using mechanize, use click_request_data. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._click(name</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">label</span><span class="s2">, </span><span class="s1">nr</span><span class="s2">, </span><span class="s1">coord</span><span class="s2">, </span><span class="s3">&quot;pairs&quot;</span><span class="s2">,</span>
                           <span class="s1">self._request_class)</span>

<span class="s0"># ---------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">find_control(self</span><span class="s2">,</span>
                     <span class="s1">name=</span><span class="s2">None,</span>
                     <span class="s1">type=</span><span class="s2">None,</span>
                     <span class="s1">kind=</span><span class="s2">None,</span>
                     <span class="s1">id=</span><span class="s2">None,</span>
                     <span class="s1">predicate=</span><span class="s2">None,</span>
                     <span class="s1">nr=</span><span class="s2">None,</span>
                     <span class="s1">label=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Locate and return some specific control within the form. 
 
        At least one of the name, type, kind, predicate and nr arguments must 
        be supplied.  If no matching control is found, ControlNotFoundError is 
        raised. 
 
        If name is specified, then the control must have the indicated name. 
 
        If type is specified then the control must have the specified type (in 
        addition to the types possible for &lt;input&gt; HTML tags: &quot;text&quot;, 
        &quot;password&quot;, &quot;hidden&quot;, &quot;submit&quot;, &quot;image&quot;, &quot;button&quot;, &quot;radio&quot;, &quot;checkbox&quot;, 
        &quot;file&quot; we also have &quot;reset&quot;, &quot;buttonbutton&quot;, &quot;submitbutton&quot;, 
        &quot;resetbutton&quot;, &quot;textarea&quot;, &quot;select&quot;). 
 
        If kind is specified, then the control must fall into the specified 
        group, each of which satisfies a particular interface.  The types are 
        &quot;text&quot;, &quot;list&quot;, &quot;multilist&quot;, &quot;singlelist&quot;, &quot;clickable&quot; and &quot;file&quot;. 
 
        If id is specified, then the control must have the indicated id. 
 
        If predicate is specified, then the control must match that function. 
        The predicate function is passed the control as its single argument, 
        and should return a boolean value indicating whether the control 
        matched. 
 
        nr, if supplied, is the sequence number of the control (where 0 is the 
        first).  Note that control 0 is the first control matching all the 
        other arguments (if supplied); it is not necessarily the first control 
        in the form.  If no nr is supplied, AmbiguityError is raised if 
        multiple controls match the other arguments. 
 
        If label is specified, then the control must have this label.  Note 
        that radio controls and checkboxes never have labels: their items do. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">((name </span><span class="s2">is None</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(type </span><span class="s2">is None</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(kind </span><span class="s2">is None</span><span class="s1">) </span><span class="s2">and</span>
                <span class="s1">(id </span><span class="s2">is None</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(label </span><span class="s2">is None</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(predicate </span><span class="s2">is None</span><span class="s1">) </span><span class="s2">and</span>
                <span class="s1">(nr </span><span class="s2">is None</span><span class="s1">)):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;at least one argument must be supplied to specify control&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._find_control(name</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">label</span><span class="s2">, </span><span class="s1">predicate</span><span class="s2">, </span><span class="s1">nr)</span>

<span class="s0"># ---------------------------------------------------</span>
<span class="s0"># Private methods.</span>

    <span class="s2">def </span><span class="s1">_find_list_control(self</span><span class="s2">,</span>
                           <span class="s1">name=</span><span class="s2">None,</span>
                           <span class="s1">type=</span><span class="s2">None,</span>
                           <span class="s1">kind=</span><span class="s2">None,</span>
                           <span class="s1">id=</span><span class="s2">None,</span>
                           <span class="s1">label=</span><span class="s2">None,</span>
                           <span class="s1">nr=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">((name </span><span class="s2">is None</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(type </span><span class="s2">is None</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(kind </span><span class="s2">is None</span><span class="s1">) </span><span class="s2">and</span>
                <span class="s1">(id </span><span class="s2">is None</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(label </span><span class="s2">is None</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(nr </span><span class="s2">is None</span><span class="s1">)):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;at least one argument must be supplied to specify control&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">self._find_control(name</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">label</span><span class="s2">, </span><span class="s1">is_listcontrol</span><span class="s2">,</span>
                                  <span class="s1">nr)</span>

    <span class="s2">def </span><span class="s1">_find_control(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">label</span><span class="s2">, </span><span class="s1">predicate</span><span class="s2">, </span><span class="s1">nr):</span>
        <span class="s2">if </span><span class="s1">((name </span><span class="s2">is not None</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(name </span><span class="s2">is not </span><span class="s1">Missing) </span><span class="s2">and</span>
                <span class="s2">not </span><span class="s1">isstringlike(name)):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;control name must be string-like&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">(type </span><span class="s2">is not None</span><span class="s1">) </span><span class="s2">and not </span><span class="s1">isstringlike(type):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;control type must be string-like&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">(kind </span><span class="s2">is not None</span><span class="s1">) </span><span class="s2">and not </span><span class="s1">isstringlike(kind):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;control kind must be string-like&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">(id </span><span class="s2">is not None</span><span class="s1">) </span><span class="s2">and not </span><span class="s1">isstringlike(id):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;control id must be string-like&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">(label </span><span class="s2">is not None</span><span class="s1">) </span><span class="s2">and not </span><span class="s1">isstringlike(label):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;control label must be string-like&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">(predicate </span><span class="s2">is not None</span><span class="s1">) </span><span class="s2">and not </span><span class="s1">callable(predicate):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;control predicate must be callable&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">(nr </span><span class="s2">is not None</span><span class="s1">) </span><span class="s2">and </span><span class="s1">nr &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;control number must be a positive integer&quot;</span><span class="s1">)</span>

        <span class="s1">orig_nr = nr</span>
        <span class="s1">found = </span><span class="s2">None</span>
        <span class="s1">ambiguous = </span><span class="s2">False</span>

        <span class="s2">for </span><span class="s1">control </span><span class="s2">in </span><span class="s1">self.controls:</span>
            <span class="s2">if </span><span class="s1">((name </span><span class="s2">is not None and </span><span class="s1">name != control.name) </span><span class="s2">and</span>
                    <span class="s1">(name </span><span class="s2">is not </span><span class="s1">Missing </span><span class="s2">or </span><span class="s1">control.name </span><span class="s2">is not None</span><span class="s1">)):</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">type </span><span class="s2">is not None and </span><span class="s1">type != control.type:</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">kind </span><span class="s2">is not None and not </span><span class="s1">control.is_of_kind(kind):</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">id </span><span class="s2">is not None and </span><span class="s1">id != control.id:</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">predicate </span><span class="s2">and not </span><span class="s1">predicate(control):</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">label:</span>
                <span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">control.get_labels():</span>
                    <span class="s2">if </span><span class="s1">l.text.find(label) &gt; -</span><span class="s4">1</span><span class="s1">:</span>
                        <span class="s2">break</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">nr </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">nr == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">control  </span><span class="s0"># early exit: unambiguous due to nr</span>
                <span class="s1">nr -= </span><span class="s4">1</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">found:</span>
                <span class="s1">ambiguous = </span><span class="s2">True</span>
                <span class="s2">break</span>
            <span class="s1">found = control</span>

        <span class="s2">if </span><span class="s1">found </span><span class="s2">and not </span><span class="s1">ambiguous:</span>
            <span class="s2">return </span><span class="s1">found</span>

        <span class="s1">description = []</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">description.append(</span><span class="s3">&quot;name %s&quot; </span><span class="s1">% repr(name))</span>
        <span class="s2">if </span><span class="s1">type </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">description.append(</span><span class="s3">&quot;type '%s'&quot; </span><span class="s1">% type)</span>
        <span class="s2">if </span><span class="s1">kind </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">description.append(</span><span class="s3">&quot;kind '%s'&quot; </span><span class="s1">% kind)</span>
        <span class="s2">if </span><span class="s1">id </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">description.append(</span><span class="s3">&quot;id '%s'&quot; </span><span class="s1">% id)</span>
        <span class="s2">if </span><span class="s1">label </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">description.append(</span><span class="s3">&quot;label '%s'&quot; </span><span class="s1">% label)</span>
        <span class="s2">if </span><span class="s1">predicate </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">description.append(</span><span class="s3">&quot;predicate %s&quot; </span><span class="s1">% predicate)</span>
        <span class="s2">if </span><span class="s1">orig_nr:</span>
            <span class="s1">description.append(</span><span class="s3">&quot;nr %d&quot; </span><span class="s1">% orig_nr)</span>
        <span class="s1">description = </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(description)</span>

        <span class="s2">if </span><span class="s1">ambiguous:</span>
            <span class="s2">raise </span><span class="s1">AmbiguityError(</span><span class="s3">&quot;more than one control matching &quot; </span><span class="s1">+</span>
                                 <span class="s1">description)</span>
        <span class="s2">elif not </span><span class="s1">found:</span>
            <span class="s2">raise </span><span class="s1">ControlNotFoundError(</span><span class="s3">&quot;no control matching &quot; </span><span class="s1">+ description)</span>
        <span class="s2">assert False</span>

    <span class="s2">def </span><span class="s1">_click(self</span><span class="s2">,</span>
               <span class="s1">name</span><span class="s2">,</span>
               <span class="s1">type</span><span class="s2">,</span>
               <span class="s1">id</span><span class="s2">,</span>
               <span class="s1">label</span><span class="s2">,</span>
               <span class="s1">nr</span><span class="s2">,</span>
               <span class="s1">coord</span><span class="s2">,</span>
               <span class="s1">return_type</span><span class="s2">,</span>
               <span class="s1">request_class=_request.Request):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">control = self._find_control(name</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s3">&quot;clickable&quot;</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">label</span><span class="s2">,</span>
                                         <span class="s2">None, </span><span class="s1">nr)</span>
        <span class="s2">except </span><span class="s1">ControlNotFoundError:</span>
            <span class="s2">if </span><span class="s1">((name </span><span class="s2">is not None</span><span class="s1">) </span><span class="s2">or </span><span class="s1">(type </span><span class="s2">is not None</span><span class="s1">) </span><span class="s2">or </span><span class="s1">(id </span><span class="s2">is not None</span><span class="s1">) </span><span class="s2">or</span>
                    <span class="s1">(label </span><span class="s2">is not None</span><span class="s1">) </span><span class="s2">or </span><span class="s1">(nr != </span><span class="s4">0</span><span class="s1">)):</span>
                <span class="s2">raise</span>
            <span class="s0"># no clickable controls, but no control was explicitly requested,</span>
            <span class="s0"># so return state without clicking any control</span>
            <span class="s2">return </span><span class="s1">self._switch_click(return_type</span><span class="s2">, </span><span class="s1">request_class)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">originals = self.method</span><span class="s2">, </span><span class="s1">self.action</span><span class="s2">, </span><span class="s1">self.enctype</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">isinstance(control</span><span class="s2">, </span><span class="s1">ScalarControl):</span>
                    <span class="s1">self.method = control.attrs.get(</span>
                        <span class="s3">'formmethod'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">self.method</span>
                    <span class="s1">self.action = control.attrs.get(</span>
                        <span class="s3">'formaction'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">self.action</span>
                    <span class="s1">self.enctype = control.attrs.get(</span>
                        <span class="s3">'formenctype'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">self.enctype</span>
                <span class="s2">return </span><span class="s1">control._click(self</span><span class="s2">, </span><span class="s1">coord</span><span class="s2">, </span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">request_class)</span>
            <span class="s2">finally</span><span class="s1">:</span>
                <span class="s1">self.method</span><span class="s2">, </span><span class="s1">self.action</span><span class="s2">, </span><span class="s1">self.enctype = originals</span>

    <span class="s2">def </span><span class="s1">_pairs(self):</span>
        <span class="s5">&quot;&quot;&quot;Return sequence of (key, value) pairs suitable for urlencoding.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[(k</span><span class="s2">, </span><span class="s1">v) </span><span class="s2">for </span><span class="s1">(i</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">c_i) </span><span class="s2">in </span><span class="s1">self._pairs_and_controls()]</span>

    <span class="s2">def </span><span class="s1">_pairs_and_controls(self):</span>
        <span class="s5">&quot;&quot;&quot;Return sequence of (index, key, value, control_index) 
        of totally ordered pairs suitable for urlencoding. 
 
        control_index is the index of the control in self.controls 
        &quot;&quot;&quot;</span>
        <span class="s1">pairs = []</span>
        <span class="s2">for </span><span class="s1">control_index </span><span class="s2">in </span><span class="s1">range(len(self.controls)):</span>
            <span class="s1">control = self.controls[control_index]</span>
            <span class="s2">for </span><span class="s1">ii</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">control._totally_ordered_pairs():</span>
                <span class="s2">if </span><span class="s1">ii </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">ii = -</span><span class="s4">1</span>
                <span class="s1">pairs.append((ii</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">control_index))</span>

        <span class="s0"># stable sort by ONLY first item in tuple</span>
        <span class="s1">pairs.sort()</span>

        <span class="s2">return </span><span class="s1">pairs</span>

    <span class="s2">def </span><span class="s1">_request_data(self):</span>
        <span class="s5">&quot;&quot;&quot;Return a tuple (url, data, headers).&quot;&quot;&quot;</span>
        <span class="s1">method = self.method.upper()</span>
        <span class="s1">parts = self._urlparse(self.action)</span>
        <span class="s1">rest</span><span class="s2">, </span><span class="s1">(query</span><span class="s2">, </span><span class="s1">frag) = parts[:-</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">parts[-</span><span class="s4">2</span><span class="s1">:]</span>
        <span class="s1">frag</span>

        <span class="s2">def </span><span class="s1">encode_data(x):</span>
            <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">unicode_type):</span>
                <span class="s1">x = x.encode(self.form_encoding)</span>
            <span class="s2">return </span><span class="s1">x</span>

        <span class="s2">def </span><span class="s1">encode_query():</span>
            <span class="s1">p = [(encode_data(k)</span><span class="s2">, </span><span class="s1">encode_data(v)) </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self._pairs()]</span>
            <span class="s2">return </span><span class="s1">urlencode(p)</span>

        <span class="s2">if </span><span class="s1">method == </span><span class="s3">&quot;GET&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.enctype != </span><span class="s3">&quot;application/x-www-form-urlencoded&quot;</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;unknown GET form encoding type '%s'&quot; </span><span class="s1">%</span>
                                 <span class="s1">self.enctype)</span>
            <span class="s1">parts = rest + (encode_query()</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s1">uri = self._urlunparse(parts)</span>
            <span class="s2">return </span><span class="s1">uri</span><span class="s2">, None, </span><span class="s1">[]</span>
        <span class="s2">elif </span><span class="s1">method == </span><span class="s3">&quot;POST&quot;</span><span class="s1">:</span>
            <span class="s1">parts = rest + (query</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s1">uri = self._urlunparse(parts)</span>
            <span class="s2">if </span><span class="s1">self.enctype == </span><span class="s3">&quot;application/x-www-form-urlencoded&quot;</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">(uri</span><span class="s2">, </span><span class="s1">encode_query()</span><span class="s2">,</span>
                        <span class="s1">[(</span><span class="s3">&quot;Content-Type&quot;</span><span class="s2">, </span><span class="s1">self.enctype)])</span>
            <span class="s2">elif </span><span class="s1">self.enctype == </span><span class="s3">&quot;multipart/form-data&quot;</span><span class="s1">:</span>
                <span class="s1">data = StringIO()</span>
                <span class="s1">http_hdrs = []</span>
                <span class="s1">mw = MimeWriter(data</span><span class="s2">, </span><span class="s1">http_hdrs)</span>
                <span class="s1">mw.startmultipartbody(</span>
                    <span class="s3">&quot;form-data&quot;</span><span class="s2">, </span><span class="s1">add_to_http_hdrs=</span><span class="s2">True, </span><span class="s1">prefix=</span><span class="s4">0</span><span class="s1">)</span>
                <span class="s2">for </span><span class="s1">ii</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">control_index </span><span class="s2">in </span><span class="s1">self._pairs_and_controls():</span>
                    <span class="s1">self.controls[control_index]._write_mime_data(</span>
                            <span class="s1">mw</span><span class="s2">, </span><span class="s1">encode_data(k)</span><span class="s2">, </span><span class="s1">encode_data(v))</span>
                <span class="s1">mw.lastpart()</span>
                <span class="s2">return </span><span class="s1">uri</span><span class="s2">, </span><span class="s1">data.getvalue()</span><span class="s2">, </span><span class="s1">http_hdrs</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;unknown POST form encoding type '%s'&quot; </span><span class="s1">%</span>
                                 <span class="s1">self.enctype)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unknown method '%s'&quot; </span><span class="s1">% method)</span>

    <span class="s2">def </span><span class="s1">_switch_click(self</span><span class="s2">, </span><span class="s1">return_type</span><span class="s2">, </span><span class="s1">request_class=_request.Request):</span>
        <span class="s0"># This is called by HTMLForm and clickable Controls to hide switching</span>
        <span class="s0"># on return_type.</span>
        <span class="s2">if </span><span class="s1">return_type == </span><span class="s3">&quot;pairs&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._pairs()</span>
        <span class="s2">elif </span><span class="s1">return_type == </span><span class="s3">&quot;request_data&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._request_data()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">req_data = self._request_data()</span>
            <span class="s1">req = request_class(req_data[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">req_data[</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">req_data[</span><span class="s4">2</span><span class="s1">]:</span>
                <span class="s1">add_hdr = req.add_header</span>
                <span class="s2">if </span><span class="s1">key.lower() == </span><span class="s3">&quot;content-type&quot;</span><span class="s1">:</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">add_hdr = req.add_unredirected_header</span>
                    <span class="s2">except </span><span class="s1">AttributeError:</span>
                        <span class="s0"># pre-2.4 and not using ClientCookie</span>
                        <span class="s2">pass</span>
                <span class="s1">add_hdr(key</span><span class="s2">, </span><span class="s1">val)</span>
            <span class="s2">return </span><span class="s1">req</span>
</pre>
</body>
</html>