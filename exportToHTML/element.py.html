<html>
<head>
<title>element.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
element.py</font>
</center></td></tr></table>
<pre><span class="s0"># Use of this source code is governed by the MIT license.</span>
<span class="s1">__license__ = </span><span class="s2">&quot;MIT&quot;</span>

<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">from </span><span class="s1">collections.abc </span><span class="s3">import </span><span class="s1">Callable </span><span class="s0"># Python 3.6</span>
<span class="s3">except </span><span class="s1">ImportError </span><span class="s3">as </span><span class="s1">e:</span>
    <span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">Callable</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">import </span><span class="s1">soupsieve</span>
<span class="s3">except </span><span class="s1">ImportError </span><span class="s3">as </span><span class="s1">e:</span>
    <span class="s1">soupsieve = </span><span class="s3">None</span>
    <span class="s1">warnings.warn(</span>
        <span class="s2">'The soupsieve package is not installed. CSS selectors cannot be used.'</span>
    <span class="s1">)</span>

<span class="s3">from </span><span class="s1">bs4.formatter </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">Formatter</span><span class="s3">,</span>
    <span class="s1">HTMLFormatter</span><span class="s3">,</span>
    <span class="s1">XMLFormatter</span><span class="s3">,</span>
<span class="s1">)</span>

<span class="s1">DEFAULT_OUTPUT_ENCODING = </span><span class="s2">&quot;utf-8&quot;</span>
<span class="s1">PY3K = (sys.version_info[</span><span class="s4">0</span><span class="s1">] &gt; </span><span class="s4">2</span><span class="s1">)</span>

<span class="s1">nonwhitespace_re = re.compile(</span><span class="s2">r&quot;\S+&quot;</span><span class="s1">)</span>

<span class="s0"># NOTE: This isn't used as of 4.7.0. I'm leaving it for a little bit on</span>
<span class="s0"># the off chance someone imported it for their own use.</span>
<span class="s1">whitespace_re = re.compile(</span><span class="s2">r&quot;\s+&quot;</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">_alias(attr):</span>
    <span class="s5">&quot;&quot;&quot;Alias one attribute name to another for backward compatibility&quot;&quot;&quot;</span>
    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">alias(self):</span>
        <span class="s3">return </span><span class="s1">getattr(self</span><span class="s3">, </span><span class="s1">attr)</span>

    <span class="s1">@alias.setter</span>
    <span class="s3">def </span><span class="s1">alias(self):</span>
        <span class="s3">return </span><span class="s1">setattr(self</span><span class="s3">, </span><span class="s1">attr)</span>
    <span class="s3">return </span><span class="s1">alias</span>


<span class="s0"># These encodings are recognized by Python (so PageElement.encode</span>
<span class="s0"># could theoretically support them) but XML and HTML don't recognize</span>
<span class="s0"># them (so they should not show up in an XML or HTML document as that</span>
<span class="s0"># document's encoding).</span>
<span class="s0">#</span>
<span class="s0"># If an XML document is encoded in one of these encodings, no encoding</span>
<span class="s0"># will be mentioned in the XML declaration. If an HTML document is</span>
<span class="s0"># encoded in one of these encodings, and the HTML document has a</span>
<span class="s0"># &lt;meta&gt; tag that mentions an encoding, the encoding will be given as</span>
<span class="s0"># the empty string.</span>
<span class="s0">#</span>
<span class="s0"># Source:</span>
<span class="s0"># https://docs.python.org/3/library/codecs.html#python-specific-encodings</span>
<span class="s1">PYTHON_SPECIFIC_ENCODINGS = set([</span>
    <span class="s2">&quot;idna&quot;</span><span class="s3">,</span>
    <span class="s2">&quot;mbcs&quot;</span><span class="s3">,</span>
    <span class="s2">&quot;oem&quot;</span><span class="s3">,</span>
    <span class="s2">&quot;palmos&quot;</span><span class="s3">,</span>
    <span class="s2">&quot;punycode&quot;</span><span class="s3">,</span>
    <span class="s2">&quot;raw_unicode_escape&quot;</span><span class="s3">,</span>
    <span class="s2">&quot;undefined&quot;</span><span class="s3">,</span>
    <span class="s2">&quot;unicode_escape&quot;</span><span class="s3">,</span>
    <span class="s2">&quot;raw-unicode-escape&quot;</span><span class="s3">,</span>
    <span class="s2">&quot;unicode-escape&quot;</span><span class="s3">,</span>
    <span class="s2">&quot;string-escape&quot;</span><span class="s3">,</span>
    <span class="s2">&quot;string_escape&quot;</span><span class="s3">,</span>
<span class="s1">])</span>
    

<span class="s3">class </span><span class="s1">NamespacedAttribute(str):</span>
    <span class="s5">&quot;&quot;&quot;A namespaced string (e.g. 'xml:lang') that remembers the namespace 
    ('xml') and the name ('lang') that were used to create it. 
    &quot;&quot;&quot;</span>
    
    <span class="s3">def </span><span class="s1">__new__(cls</span><span class="s3">, </span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name=</span><span class="s3">None, </span><span class="s1">namespace=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">if not </span><span class="s1">name:</span>
            <span class="s0"># This is the default namespace. Its name &quot;has no value&quot;</span>
            <span class="s0"># per https://www.w3.org/TR/xml-names/#defaulting</span>
            <span class="s1">name = </span><span class="s3">None</span>

        <span class="s3">if </span><span class="s1">name </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">obj = str.__new__(cls</span><span class="s3">, </span><span class="s1">prefix)</span>
        <span class="s3">elif </span><span class="s1">prefix </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s0"># Not really namespaced.</span>
            <span class="s1">obj = str.__new__(cls</span><span class="s3">, </span><span class="s1">name)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">obj = str.__new__(cls</span><span class="s3">, </span><span class="s1">prefix + </span><span class="s2">&quot;:&quot; </span><span class="s1">+ name)</span>
        <span class="s1">obj.prefix = prefix</span>
        <span class="s1">obj.name = name</span>
        <span class="s1">obj.namespace = namespace</span>
        <span class="s3">return </span><span class="s1">obj</span>

<span class="s3">class </span><span class="s1">AttributeValueWithCharsetSubstitution(str):</span>
    <span class="s5">&quot;&quot;&quot;A stand-in object for a character encoding specified in HTML.&quot;&quot;&quot;</span>

<span class="s3">class </span><span class="s1">CharsetMetaAttributeValue(AttributeValueWithCharsetSubstitution):</span>
    <span class="s5">&quot;&quot;&quot;A generic stand-in for the value of a meta tag's 'charset' attribute. 
 
    When Beautiful Soup parses the markup '&lt;meta charset=&quot;utf8&quot;&gt;', the 
    value of the 'charset' attribute will be one of these objects. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__new__(cls</span><span class="s3">, </span><span class="s1">original_value):</span>
        <span class="s1">obj = str.__new__(cls</span><span class="s3">, </span><span class="s1">original_value)</span>
        <span class="s1">obj.original_value = original_value</span>
        <span class="s3">return </span><span class="s1">obj</span>

    <span class="s3">def </span><span class="s1">encode(self</span><span class="s3">, </span><span class="s1">encoding):</span>
        <span class="s5">&quot;&quot;&quot;When an HTML document is being encoded to a given encoding, the 
        value of a meta tag's 'charset' is the name of the encoding. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">encoding </span><span class="s3">in </span><span class="s1">PYTHON_SPECIFIC_ENCODINGS:</span>
            <span class="s3">return </span><span class="s2">''</span>
        <span class="s3">return </span><span class="s1">encoding</span>


<span class="s3">class </span><span class="s1">ContentMetaAttributeValue(AttributeValueWithCharsetSubstitution):</span>
    <span class="s5">&quot;&quot;&quot;A generic stand-in for the value of a meta tag's 'content' attribute. 
 
    When Beautiful Soup parses the markup: 
     &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf8&quot;&gt; 
 
    The value of the 'content' attribute will be one of these objects. 
    &quot;&quot;&quot;</span>

    <span class="s1">CHARSET_RE = re.compile(</span><span class="s2">r&quot;((^|;)\s*charset=)([^;]*)&quot;</span><span class="s3">, </span><span class="s1">re.M)</span>

    <span class="s3">def </span><span class="s1">__new__(cls</span><span class="s3">, </span><span class="s1">original_value):</span>
        <span class="s1">match = cls.CHARSET_RE.search(original_value)</span>
        <span class="s3">if </span><span class="s1">match </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s0"># No substitution necessary.</span>
            <span class="s3">return </span><span class="s1">str.__new__(str</span><span class="s3">, </span><span class="s1">original_value)</span>

        <span class="s1">obj = str.__new__(cls</span><span class="s3">, </span><span class="s1">original_value)</span>
        <span class="s1">obj.original_value = original_value</span>
        <span class="s3">return </span><span class="s1">obj</span>

    <span class="s3">def </span><span class="s1">encode(self</span><span class="s3">, </span><span class="s1">encoding):</span>
        <span class="s3">if </span><span class="s1">encoding </span><span class="s3">in </span><span class="s1">PYTHON_SPECIFIC_ENCODINGS:</span>
            <span class="s3">return </span><span class="s2">''</span>
        <span class="s3">def </span><span class="s1">rewrite(match):</span>
            <span class="s3">return </span><span class="s1">match.group(</span><span class="s4">1</span><span class="s1">) + encoding</span>
        <span class="s3">return </span><span class="s1">self.CHARSET_RE.sub(rewrite</span><span class="s3">, </span><span class="s1">self.original_value)</span>

    
<span class="s3">class </span><span class="s1">PageElement(object):</span>
    <span class="s5">&quot;&quot;&quot;Contains the navigational information for some part of the page: 
    that is, its current location in the parse tree. 
 
    NavigableString, Tag, etc. are all subclasses of PageElement. 
    &quot;&quot;&quot;</span>
   
    <span class="s3">def </span><span class="s1">setup(self</span><span class="s3">, </span><span class="s1">parent=</span><span class="s3">None, </span><span class="s1">previous_element=</span><span class="s3">None, </span><span class="s1">next_element=</span><span class="s3">None,</span>
              <span class="s1">previous_sibling=</span><span class="s3">None, </span><span class="s1">next_sibling=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Sets up the initial relations between this element and 
        other elements. 
 
        :param parent: The parent of this element. 
 
        :param previous_element: The element parsed immediately before 
            this one. 
         
        :param next_element: The element parsed immediately before 
            this one. 
 
        :param previous_sibling: The most recently encountered element 
            on the same level of the parse tree as this one. 
 
        :param previous_sibling: The next element to be encountered 
            on the same level of the parse tree as this one. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.parent = parent</span>

        <span class="s1">self.previous_element = previous_element</span>
        <span class="s3">if </span><span class="s1">previous_element </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.previous_element.next_element = self</span>

        <span class="s1">self.next_element = next_element</span>
        <span class="s3">if </span><span class="s1">self.next_element </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.next_element.previous_element = self</span>

        <span class="s1">self.next_sibling = next_sibling</span>
        <span class="s3">if </span><span class="s1">self.next_sibling </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.next_sibling.previous_sibling = self</span>

        <span class="s3">if </span><span class="s1">(previous_sibling </span><span class="s3">is None</span>
            <span class="s3">and </span><span class="s1">self.parent </span><span class="s3">is not None and </span><span class="s1">self.parent.contents):</span>
            <span class="s1">previous_sibling = self.parent.contents[-</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s1">self.previous_sibling = previous_sibling</span>
        <span class="s3">if </span><span class="s1">previous_sibling </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.previous_sibling.next_sibling = self</span>

    <span class="s3">def </span><span class="s1">format_string(self</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">formatter):</span>
        <span class="s5">&quot;&quot;&quot;Format the given string using the given formatter. 
 
        :param s: A string. 
        :param formatter: A Formatter object, or a string naming one of the standard formatters. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">formatter </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">s</span>
        <span class="s3">if not </span><span class="s1">isinstance(formatter</span><span class="s3">, </span><span class="s1">Formatter):</span>
            <span class="s1">formatter = self.formatter_for_name(formatter)</span>
        <span class="s1">output = formatter.substitute(s)</span>
        <span class="s3">return </span><span class="s1">output</span>

    <span class="s3">def </span><span class="s1">formatter_for_name(self</span><span class="s3">, </span><span class="s1">formatter):</span>
        <span class="s5">&quot;&quot;&quot;Look up or create a Formatter for the given identifier, 
        if necessary. 
 
        :param formatter: Can be a Formatter object (used as-is), a 
            function (used as the entity substitution hook for an 
            XMLFormatter or HTMLFormatter), or a string (used to look 
            up an XMLFormatter or HTMLFormatter in the appropriate 
            registry. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance(formatter</span><span class="s3">, </span><span class="s1">Formatter):</span>
            <span class="s3">return </span><span class="s1">formatter</span>
        <span class="s3">if </span><span class="s1">self._is_xml:</span>
            <span class="s1">c = XMLFormatter</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">c = HTMLFormatter</span>
        <span class="s3">if </span><span class="s1">isinstance(formatter</span><span class="s3">, </span><span class="s1">Callable):</span>
            <span class="s3">return </span><span class="s1">c(entity_substitution=formatter)</span>
        <span class="s3">return </span><span class="s1">c.REGISTRY[formatter]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">_is_xml(self):</span>
        <span class="s5">&quot;&quot;&quot;Is this element part of an XML tree or an HTML tree? 
 
        This is used in formatter_for_name, when deciding whether an 
        XMLFormatter or HTMLFormatter is more appropriate. It can be 
        inefficient, but it should be called very rarely. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.known_xml </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s0"># Most of the time we will have determined this when the</span>
            <span class="s0"># document is parsed.</span>
            <span class="s3">return </span><span class="s1">self.known_xml</span>

        <span class="s0"># Otherwise, it's likely that this element was created by</span>
        <span class="s0"># direct invocation of the constructor from within the user's</span>
        <span class="s0"># Python code.</span>
        <span class="s3">if </span><span class="s1">self.parent </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s0"># This is the top-level object. It should have .known_xml set</span>
            <span class="s0"># from tree creation. If not, take a guess--BS is usually</span>
            <span class="s0"># used on HTML markup.</span>
            <span class="s3">return </span><span class="s1">getattr(self</span><span class="s3">, </span><span class="s2">'is_xml'</span><span class="s3">, False</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self.parent._is_xml</span>

    <span class="s1">nextSibling = _alias(</span><span class="s2">&quot;next_sibling&quot;</span><span class="s1">)  </span><span class="s0"># BS3</span>
    <span class="s1">previousSibling = _alias(</span><span class="s2">&quot;previous_sibling&quot;</span><span class="s1">)  </span><span class="s0"># BS3</span>

    <span class="s3">def </span><span class="s1">replace_with(self</span><span class="s3">, </span><span class="s1">replace_with):</span>
        <span class="s5">&quot;&quot;&quot;Replace this PageElement with another one, keeping the rest of the 
        tree the same. 
         
        :param replace_with: A PageElement. 
        :return: `self`, no longer part of the tree. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.parent </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;Cannot replace one element with another when the &quot;</span>
                <span class="s2">&quot;element to be replaced is not part of a tree.&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">replace_with </span><span class="s3">is </span><span class="s1">self:</span>
            <span class="s3">return</span>
        <span class="s3">if </span><span class="s1">replace_with </span><span class="s3">is </span><span class="s1">self.parent:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Cannot replace a Tag with its parent.&quot;</span><span class="s1">)</span>
        <span class="s1">old_parent = self.parent</span>
        <span class="s1">my_index = self.parent.index(self)</span>
        <span class="s1">self.extract(_self_index=my_index)</span>
        <span class="s1">old_parent.insert(my_index</span><span class="s3">, </span><span class="s1">replace_with)</span>
        <span class="s3">return </span><span class="s1">self</span>
    <span class="s1">replaceWith = replace_with  </span><span class="s0"># BS3</span>

    <span class="s3">def </span><span class="s1">unwrap(self):</span>
        <span class="s5">&quot;&quot;&quot;Replace this PageElement with its contents. 
 
        :return: `self`, no longer part of the tree. 
        &quot;&quot;&quot;</span>
        <span class="s1">my_parent = self.parent</span>
        <span class="s3">if </span><span class="s1">self.parent </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;Cannot replace an element with its contents when that&quot;</span>
                <span class="s2">&quot;element is not part of a tree.&quot;</span><span class="s1">)</span>
        <span class="s1">my_index = self.parent.index(self)</span>
        <span class="s1">self.extract(_self_index=my_index)</span>
        <span class="s3">for </span><span class="s1">child </span><span class="s3">in </span><span class="s1">reversed(self.contents[:]):</span>
            <span class="s1">my_parent.insert(my_index</span><span class="s3">, </span><span class="s1">child)</span>
        <span class="s3">return </span><span class="s1">self</span>
    <span class="s1">replace_with_children = unwrap</span>
    <span class="s1">replaceWithChildren = unwrap  </span><span class="s0"># BS3</span>

    <span class="s3">def </span><span class="s1">wrap(self</span><span class="s3">, </span><span class="s1">wrap_inside):</span>
        <span class="s5">&quot;&quot;&quot;Wrap this PageElement inside another one. 
 
        :param wrap_inside: A PageElement. 
        :return: `wrap_inside`, occupying the position in the tree that used 
           to be occupied by `self`, and with `self` inside it. 
        &quot;&quot;&quot;</span>
        <span class="s1">me = self.replace_with(wrap_inside)</span>
        <span class="s1">wrap_inside.append(me)</span>
        <span class="s3">return </span><span class="s1">wrap_inside</span>

    <span class="s3">def </span><span class="s1">extract(self</span><span class="s3">, </span><span class="s1">_self_index=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Destructively rips this element out of the tree. 
 
        :param _self_index: The location of this element in its parent's 
           .contents, if known. Passing this in allows for a performance 
           optimization. 
 
        :return: `self`, no longer part of the tree. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.parent </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">_self_index </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">_self_index = self.parent.index(self)</span>
            <span class="s3">del </span><span class="s1">self.parent.contents[_self_index]</span>

        <span class="s0">#Find the two elements that would be next to each other if</span>
        <span class="s0">#this element (and any children) hadn't been parsed. Connect</span>
        <span class="s0">#the two.</span>
        <span class="s1">last_child = self._last_descendant()</span>
        <span class="s1">next_element = last_child.next_element</span>

        <span class="s3">if </span><span class="s1">(self.previous_element </span><span class="s3">is not None and</span>
            <span class="s1">self.previous_element </span><span class="s3">is not </span><span class="s1">next_element):</span>
            <span class="s1">self.previous_element.next_element = next_element</span>
        <span class="s3">if </span><span class="s1">next_element </span><span class="s3">is not None and </span><span class="s1">next_element </span><span class="s3">is not </span><span class="s1">self.previous_element:</span>
            <span class="s1">next_element.previous_element = self.previous_element</span>
        <span class="s1">self.previous_element = </span><span class="s3">None</span>
        <span class="s1">last_child.next_element = </span><span class="s3">None</span>

        <span class="s1">self.parent = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">(self.previous_sibling </span><span class="s3">is not None</span>
            <span class="s3">and </span><span class="s1">self.previous_sibling </span><span class="s3">is not </span><span class="s1">self.next_sibling):</span>
            <span class="s1">self.previous_sibling.next_sibling = self.next_sibling</span>
        <span class="s3">if </span><span class="s1">(self.next_sibling </span><span class="s3">is not None</span>
            <span class="s3">and </span><span class="s1">self.next_sibling </span><span class="s3">is not </span><span class="s1">self.previous_sibling):</span>
            <span class="s1">self.next_sibling.previous_sibling = self.previous_sibling</span>
        <span class="s1">self.previous_sibling = self.next_sibling = </span><span class="s3">None</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_last_descendant(self</span><span class="s3">, </span><span class="s1">is_initialized=</span><span class="s3">True, </span><span class="s1">accept_self=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Finds the last element beneath this object to be parsed. 
 
        :param is_initialized: Has `setup` been called on this PageElement 
            yet? 
        :param accept_self: Is `self` an acceptable answer to the question? 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">is_initialized </span><span class="s3">and </span><span class="s1">self.next_sibling </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">last_child = self.next_sibling.previous_element</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">last_child = self</span>
            <span class="s3">while </span><span class="s1">isinstance(last_child</span><span class="s3">, </span><span class="s1">Tag) </span><span class="s3">and </span><span class="s1">last_child.contents:</span>
                <span class="s1">last_child = last_child.contents[-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s3">if not </span><span class="s1">accept_self </span><span class="s3">and </span><span class="s1">last_child </span><span class="s3">is </span><span class="s1">self:</span>
            <span class="s1">last_child = </span><span class="s3">None</span>
        <span class="s3">return </span><span class="s1">last_child</span>
    <span class="s0"># BS3: Not part of the API!</span>
    <span class="s1">_lastRecursiveChild = _last_descendant</span>

    <span class="s3">def </span><span class="s1">insert(self</span><span class="s3">, </span><span class="s1">position</span><span class="s3">, </span><span class="s1">new_child):</span>
        <span class="s5">&quot;&quot;&quot;Insert a new PageElement in the list of this PageElement's children. 
 
        This works the same way as `list.insert`. 
 
        :param position: The numeric position that should be occupied 
           in `self.children` by the new PageElement.  
        :param new_child: A PageElement. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">new_child </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Cannot insert None into a tag.&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">new_child </span><span class="s3">is </span><span class="s1">self:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Cannot insert a tag into itself.&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">(isinstance(new_child</span><span class="s3">, </span><span class="s1">str)</span>
            <span class="s3">and not </span><span class="s1">isinstance(new_child</span><span class="s3">, </span><span class="s1">NavigableString)):</span>
            <span class="s1">new_child = NavigableString(new_child)</span>

        <span class="s3">from </span><span class="s1">bs4 </span><span class="s3">import </span><span class="s1">BeautifulSoup</span>
        <span class="s3">if </span><span class="s1">isinstance(new_child</span><span class="s3">, </span><span class="s1">BeautifulSoup):</span>
            <span class="s0"># We don't want to end up with a situation where one BeautifulSoup</span>
            <span class="s0"># object contains another. Insert the children one at a time.</span>
            <span class="s3">for </span><span class="s1">subchild </span><span class="s3">in </span><span class="s1">list(new_child.contents):</span>
                <span class="s1">self.insert(position</span><span class="s3">, </span><span class="s1">subchild)</span>
                <span class="s1">position += </span><span class="s4">1</span>
            <span class="s3">return</span>
        <span class="s1">position = min(position</span><span class="s3">, </span><span class="s1">len(self.contents))</span>
        <span class="s3">if </span><span class="s1">hasattr(new_child</span><span class="s3">, </span><span class="s2">'parent'</span><span class="s1">) </span><span class="s3">and </span><span class="s1">new_child.parent </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s0"># We're 'inserting' an element that's already one</span>
            <span class="s0"># of this object's children.</span>
            <span class="s3">if </span><span class="s1">new_child.parent </span><span class="s3">is </span><span class="s1">self:</span>
                <span class="s1">current_index = self.index(new_child)</span>
                <span class="s3">if </span><span class="s1">current_index &lt; position:</span>
                    <span class="s0"># We're moving this element further down the list</span>
                    <span class="s0"># of this object's children. That means that when</span>
                    <span class="s0"># we extract this element, our target index will</span>
                    <span class="s0"># jump down one.</span>
                    <span class="s1">position -= </span><span class="s4">1</span>
            <span class="s1">new_child.extract()</span>

        <span class="s1">new_child.parent = self</span>
        <span class="s1">previous_child = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">position == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">new_child.previous_sibling = </span><span class="s3">None</span>
            <span class="s1">new_child.previous_element = self</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">previous_child = self.contents[position - </span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">new_child.previous_sibling = previous_child</span>
            <span class="s1">new_child.previous_sibling.next_sibling = new_child</span>
            <span class="s1">new_child.previous_element = previous_child._last_descendant(</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">new_child.previous_element </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">new_child.previous_element.next_element = new_child</span>

        <span class="s1">new_childs_last_element = new_child._last_descendant(</span><span class="s3">False</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">position &gt;= len(self.contents):</span>
            <span class="s1">new_child.next_sibling = </span><span class="s3">None</span>

            <span class="s1">parent = self</span>
            <span class="s1">parents_next_sibling = </span><span class="s3">None</span>
            <span class="s3">while </span><span class="s1">parents_next_sibling </span><span class="s3">is None and </span><span class="s1">parent </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">parents_next_sibling = parent.next_sibling</span>
                <span class="s1">parent = parent.parent</span>
                <span class="s3">if </span><span class="s1">parents_next_sibling </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s0"># We found the element that comes next in the document.</span>
                    <span class="s3">break</span>
            <span class="s3">if </span><span class="s1">parents_next_sibling </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">new_childs_last_element.next_element = parents_next_sibling</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># The last element of this tag is the last element in</span>
                <span class="s0"># the document.</span>
                <span class="s1">new_childs_last_element.next_element = </span><span class="s3">None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">next_child = self.contents[position]</span>
            <span class="s1">new_child.next_sibling = next_child</span>
            <span class="s3">if </span><span class="s1">new_child.next_sibling </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">new_child.next_sibling.previous_sibling = new_child</span>
            <span class="s1">new_childs_last_element.next_element = next_child</span>

        <span class="s3">if </span><span class="s1">new_childs_last_element.next_element </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">new_childs_last_element.next_element.previous_element = new_childs_last_element</span>
        <span class="s1">self.contents.insert(position</span><span class="s3">, </span><span class="s1">new_child)</span>

    <span class="s3">def </span><span class="s1">append(self</span><span class="s3">, </span><span class="s1">tag):</span>
        <span class="s5">&quot;&quot;&quot;Appends the given PageElement to the contents of this one. 
 
        :param tag: A PageElement. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.insert(len(self.contents)</span><span class="s3">, </span><span class="s1">tag)</span>

    <span class="s3">def </span><span class="s1">extend(self</span><span class="s3">, </span><span class="s1">tags):</span>
        <span class="s5">&quot;&quot;&quot;Appends the given PageElements to this one's contents. 
 
        :param tags: A list of PageElements. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance(tags</span><span class="s3">, </span><span class="s1">Tag):</span>
            <span class="s0"># Calling self.append() on another tag's contents will change</span>
            <span class="s0"># the list we're iterating over. Make a list that won't</span>
            <span class="s0"># change.</span>
            <span class="s1">tags = list(tags.contents)</span>
        <span class="s3">for </span><span class="s1">tag </span><span class="s3">in </span><span class="s1">tags:</span>
            <span class="s1">self.append(tag)</span>

    <span class="s3">def </span><span class="s1">insert_before(self</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s5">&quot;&quot;&quot;Makes the given element(s) the immediate predecessor of this one. 
 
        All the elements will have the same parent, and the given elements 
        will be immediately before this one. 
 
        :param args: One or more PageElements. 
        &quot;&quot;&quot;</span>
        <span class="s1">parent = self.parent</span>
        <span class="s3">if </span><span class="s1">parent </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;Element has no parent, so 'before' has no meaning.&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">any(x </span><span class="s3">is </span><span class="s1">self </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">args):</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Can't insert an element before itself.&quot;</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">predecessor </span><span class="s3">in </span><span class="s1">args:</span>
            <span class="s0"># Extract first so that the index won't be screwed up if they</span>
            <span class="s0"># are siblings.</span>
            <span class="s3">if </span><span class="s1">isinstance(predecessor</span><span class="s3">, </span><span class="s1">PageElement):</span>
                <span class="s1">predecessor.extract()</span>
            <span class="s1">index = parent.index(self)</span>
            <span class="s1">parent.insert(index</span><span class="s3">, </span><span class="s1">predecessor)</span>

    <span class="s3">def </span><span class="s1">insert_after(self</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s5">&quot;&quot;&quot;Makes the given element(s) the immediate successor of this one. 
 
        The elements will have the same parent, and the given elements 
        will be immediately after this one. 
 
        :param args: One or more PageElements. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Do all error checking before modifying the tree.</span>
        <span class="s1">parent = self.parent</span>
        <span class="s3">if </span><span class="s1">parent </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;Element has no parent, so 'after' has no meaning.&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">any(x </span><span class="s3">is </span><span class="s1">self </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">args):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Can't insert an element after itself.&quot;</span><span class="s1">)</span>
        
        <span class="s1">offset = </span><span class="s4">0</span>
        <span class="s3">for </span><span class="s1">successor </span><span class="s3">in </span><span class="s1">args:</span>
            <span class="s0"># Extract first so that the index won't be screwed up if they</span>
            <span class="s0"># are siblings.</span>
            <span class="s3">if </span><span class="s1">isinstance(successor</span><span class="s3">, </span><span class="s1">PageElement):</span>
                <span class="s1">successor.extract()</span>
            <span class="s1">index = parent.index(self)</span>
            <span class="s1">parent.insert(index+</span><span class="s4">1</span><span class="s1">+offset</span><span class="s3">, </span><span class="s1">successor)</span>
            <span class="s1">offset += </span><span class="s4">1</span>

    <span class="s3">def </span><span class="s1">find_next(self</span><span class="s3">, </span><span class="s1">name=</span><span class="s3">None, </span><span class="s1">attrs={}</span><span class="s3">, </span><span class="s1">text=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot;Find the first PageElement that matches the given criteria and 
        appears later in the document than this PageElement. 
 
        All find_* methods take a common set of arguments. See the online 
        documentation for detailed explanations. 
 
        :param name: A filter on tag name. 
        :param attrs: A dictionary of filters on attribute values. 
        :param text: A filter for a NavigableString with specific text. 
        :kwargs: A dictionary of filters on attribute values. 
        :return: A PageElement. 
        :rtype: bs4.element.Tag | bs4.element.NavigableString 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._find_one(self.find_all_next</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">text</span><span class="s3">, </span><span class="s1">**kwargs)</span>
    <span class="s1">findNext = find_next  </span><span class="s0"># BS3</span>

    <span class="s3">def </span><span class="s1">find_all_next(self</span><span class="s3">, </span><span class="s1">name=</span><span class="s3">None, </span><span class="s1">attrs={}</span><span class="s3">, </span><span class="s1">text=</span><span class="s3">None, </span><span class="s1">limit=</span><span class="s3">None,</span>
                    <span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot;Find all PageElements that match the given criteria and appear 
        later in the document than this PageElement. 
 
        All find_* methods take a common set of arguments. See the online 
        documentation for detailed explanations. 
 
        :param name: A filter on tag name. 
        :param attrs: A dictionary of filters on attribute values. 
        :param text: A filter for a NavigableString with specific text. 
        :param limit: Stop looking after finding this many results. 
        :kwargs: A dictionary of filters on attribute values. 
        :return: A ResultSet containing PageElements. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._find_all(name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">text</span><span class="s3">, </span><span class="s1">limit</span><span class="s3">, </span><span class="s1">self.next_elements</span><span class="s3">,</span>
                             <span class="s1">**kwargs)</span>
    <span class="s1">findAllNext = find_all_next  </span><span class="s0"># BS3</span>

    <span class="s3">def </span><span class="s1">find_next_sibling(self</span><span class="s3">, </span><span class="s1">name=</span><span class="s3">None, </span><span class="s1">attrs={}</span><span class="s3">, </span><span class="s1">text=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot;Find the closest sibling to this PageElement that matches the 
        given criteria and appears later in the document. 
 
        All find_* methods take a common set of arguments. See the 
        online documentation for detailed explanations. 
 
        :param name: A filter on tag name. 
        :param attrs: A dictionary of filters on attribute values. 
        :param text: A filter for a NavigableString with specific text. 
        :kwargs: A dictionary of filters on attribute values. 
        :return: A PageElement. 
        :rtype: bs4.element.Tag | bs4.element.NavigableString 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._find_one(self.find_next_siblings</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">text</span><span class="s3">,</span>
                             <span class="s1">**kwargs)</span>
    <span class="s1">findNextSibling = find_next_sibling  </span><span class="s0"># BS3</span>

    <span class="s3">def </span><span class="s1">find_next_siblings(self</span><span class="s3">, </span><span class="s1">name=</span><span class="s3">None, </span><span class="s1">attrs={}</span><span class="s3">, </span><span class="s1">text=</span><span class="s3">None, </span><span class="s1">limit=</span><span class="s3">None,</span>
                           <span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot;Find all siblings of this PageElement that match the given criteria 
        and appear later in the document. 
 
        All find_* methods take a common set of arguments. See the online 
        documentation for detailed explanations. 
 
        :param name: A filter on tag name. 
        :param attrs: A dictionary of filters on attribute values. 
        :param text: A filter for a NavigableString with specific text. 
        :param limit: Stop looking after finding this many results. 
        :kwargs: A dictionary of filters on attribute values. 
        :return: A ResultSet of PageElements. 
        :rtype: bs4.element.ResultSet 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._find_all(name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">text</span><span class="s3">, </span><span class="s1">limit</span><span class="s3">,</span>
                              <span class="s1">self.next_siblings</span><span class="s3">, </span><span class="s1">**kwargs)</span>
    <span class="s1">findNextSiblings = find_next_siblings   </span><span class="s0"># BS3</span>
    <span class="s1">fetchNextSiblings = find_next_siblings  </span><span class="s0"># BS2</span>

    <span class="s3">def </span><span class="s1">find_previous(self</span><span class="s3">, </span><span class="s1">name=</span><span class="s3">None, </span><span class="s1">attrs={}</span><span class="s3">, </span><span class="s1">text=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot;Look backwards in the document from this PageElement and find the 
        first PageElement that matches the given criteria. 
 
        All find_* methods take a common set of arguments. See the online 
        documentation for detailed explanations. 
 
        :param name: A filter on tag name. 
        :param attrs: A dictionary of filters on attribute values. 
        :param text: A filter for a NavigableString with specific text. 
        :kwargs: A dictionary of filters on attribute values. 
        :return: A PageElement. 
        :rtype: bs4.element.Tag | bs4.element.NavigableString 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._find_one(</span>
            <span class="s1">self.find_all_previous</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">text</span><span class="s3">, </span><span class="s1">**kwargs)</span>
    <span class="s1">findPrevious = find_previous  </span><span class="s0"># BS3</span>

    <span class="s3">def </span><span class="s1">find_all_previous(self</span><span class="s3">, </span><span class="s1">name=</span><span class="s3">None, </span><span class="s1">attrs={}</span><span class="s3">, </span><span class="s1">text=</span><span class="s3">None, </span><span class="s1">limit=</span><span class="s3">None,</span>
                        <span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot;Look backwards in the document from this PageElement and find all 
        PageElements that match the given criteria. 
 
        All find_* methods take a common set of arguments. See the online 
        documentation for detailed explanations. 
 
        :param name: A filter on tag name. 
        :param attrs: A dictionary of filters on attribute values. 
        :param text: A filter for a NavigableString with specific text. 
        :param limit: Stop looking after finding this many results. 
        :kwargs: A dictionary of filters on attribute values. 
        :return: A ResultSet of PageElements. 
        :rtype: bs4.element.ResultSet 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._find_all(name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">text</span><span class="s3">, </span><span class="s1">limit</span><span class="s3">, </span><span class="s1">self.previous_elements</span><span class="s3">,</span>
                           <span class="s1">**kwargs)</span>
    <span class="s1">findAllPrevious = find_all_previous  </span><span class="s0"># BS3</span>
    <span class="s1">fetchPrevious = find_all_previous    </span><span class="s0"># BS2</span>

    <span class="s3">def </span><span class="s1">find_previous_sibling(self</span><span class="s3">, </span><span class="s1">name=</span><span class="s3">None, </span><span class="s1">attrs={}</span><span class="s3">, </span><span class="s1">text=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot;Returns the closest sibling to this PageElement that matches the 
        given criteria and appears earlier in the document. 
 
        All find_* methods take a common set of arguments. See the online 
        documentation for detailed explanations. 
 
        :param name: A filter on tag name. 
        :param attrs: A dictionary of filters on attribute values. 
        :param text: A filter for a NavigableString with specific text. 
        :kwargs: A dictionary of filters on attribute values. 
        :return: A PageElement. 
        :rtype: bs4.element.Tag | bs4.element.NavigableString 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._find_one(self.find_previous_siblings</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">text</span><span class="s3">,</span>
                             <span class="s1">**kwargs)</span>
    <span class="s1">findPreviousSibling = find_previous_sibling  </span><span class="s0"># BS3</span>

    <span class="s3">def </span><span class="s1">find_previous_siblings(self</span><span class="s3">, </span><span class="s1">name=</span><span class="s3">None, </span><span class="s1">attrs={}</span><span class="s3">, </span><span class="s1">text=</span><span class="s3">None,</span>
                               <span class="s1">limit=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot;Returns all siblings to this PageElement that match the 
        given criteria and appear earlier in the document. 
 
        All find_* methods take a common set of arguments. See the online 
        documentation for detailed explanations. 
 
        :param name: A filter on tag name. 
        :param attrs: A dictionary of filters on attribute values. 
        :param text: A filter for a NavigableString with specific text. 
        :param limit: Stop looking after finding this many results. 
        :kwargs: A dictionary of filters on attribute values. 
        :return: A ResultSet of PageElements. 
        :rtype: bs4.element.ResultSet 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._find_all(name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">text</span><span class="s3">, </span><span class="s1">limit</span><span class="s3">,</span>
                              <span class="s1">self.previous_siblings</span><span class="s3">, </span><span class="s1">**kwargs)</span>
    <span class="s1">findPreviousSiblings = find_previous_siblings   </span><span class="s0"># BS3</span>
    <span class="s1">fetchPreviousSiblings = find_previous_siblings  </span><span class="s0"># BS2</span>

    <span class="s3">def </span><span class="s1">find_parent(self</span><span class="s3">, </span><span class="s1">name=</span><span class="s3">None, </span><span class="s1">attrs={}</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot;Find the closest parent of this PageElement that matches the given 
        criteria. 
 
        All find_* methods take a common set of arguments. See the online 
        documentation for detailed explanations. 
 
        :param name: A filter on tag name. 
        :param attrs: A dictionary of filters on attribute values. 
        :kwargs: A dictionary of filters on attribute values. 
 
        :return: A PageElement. 
        :rtype: bs4.element.Tag | bs4.element.NavigableString 
        &quot;&quot;&quot;</span>
        <span class="s0"># NOTE: We can't use _find_one because findParents takes a different</span>
        <span class="s0"># set of arguments.</span>
        <span class="s1">r = </span><span class="s3">None</span>
        <span class="s1">l = self.find_parents(name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s3">if </span><span class="s1">l:</span>
            <span class="s1">r = l[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s3">return </span><span class="s1">r</span>
    <span class="s1">findParent = find_parent  </span><span class="s0"># BS3</span>

    <span class="s3">def </span><span class="s1">find_parents(self</span><span class="s3">, </span><span class="s1">name=</span><span class="s3">None, </span><span class="s1">attrs={}</span><span class="s3">, </span><span class="s1">limit=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot;Find all parents of this PageElement that match the given criteria. 
 
        All find_* methods take a common set of arguments. See the online 
        documentation for detailed explanations. 
 
        :param name: A filter on tag name. 
        :param attrs: A dictionary of filters on attribute values. 
        :param limit: Stop looking after finding this many results. 
        :kwargs: A dictionary of filters on attribute values. 
 
        :return: A PageElement. 
        :rtype: bs4.element.Tag | bs4.element.NavigableString 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._find_all(name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, None, </span><span class="s1">limit</span><span class="s3">, </span><span class="s1">self.parents</span><span class="s3">,</span>
                             <span class="s1">**kwargs)</span>
    <span class="s1">findParents = find_parents   </span><span class="s0"># BS3</span>
    <span class="s1">fetchParents = find_parents  </span><span class="s0"># BS2</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">next(self):</span>
        <span class="s5">&quot;&quot;&quot;The PageElement, if any, that was parsed just after this one. 
 
        :return: A PageElement. 
        :rtype: bs4.element.Tag | bs4.element.NavigableString 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.next_element</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">previous(self):</span>
        <span class="s5">&quot;&quot;&quot;The PageElement, if any, that was parsed just before this one. 
 
        :return: A PageElement. 
        :rtype: bs4.element.Tag | bs4.element.NavigableString 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.previous_element</span>

    <span class="s0">#These methods do the real heavy lifting.</span>

    <span class="s3">def </span><span class="s1">_find_one(self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">text</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s1">r = </span><span class="s3">None</span>
        <span class="s1">l = method(name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">text</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s3">if </span><span class="s1">l:</span>
            <span class="s1">r = l[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s3">return </span><span class="s1">r</span>

    <span class="s3">def </span><span class="s1">_find_all(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">text</span><span class="s3">, </span><span class="s1">limit</span><span class="s3">, </span><span class="s1">generator</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s5">&quot;Iterates over a generator looking for things that match.&quot;</span>

        <span class="s3">if </span><span class="s1">text </span><span class="s3">is None and </span><span class="s2">'string' </span><span class="s3">in </span><span class="s1">kwargs:</span>
            <span class="s1">text = kwargs[</span><span class="s2">'string'</span><span class="s1">]</span>
            <span class="s3">del </span><span class="s1">kwargs[</span><span class="s2">'string'</span><span class="s1">]</span>

        <span class="s3">if </span><span class="s1">isinstance(name</span><span class="s3">, </span><span class="s1">SoupStrainer):</span>
            <span class="s1">strainer = name</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">strainer = SoupStrainer(name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">text</span><span class="s3">, </span><span class="s1">**kwargs)</span>

        <span class="s3">if </span><span class="s1">text </span><span class="s3">is None and not </span><span class="s1">limit </span><span class="s3">and not </span><span class="s1">attrs </span><span class="s3">and not </span><span class="s1">kwargs:</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">is True or </span><span class="s1">name </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s0"># Optimization to find all tags.</span>
                <span class="s1">result = (element </span><span class="s3">for </span><span class="s1">element </span><span class="s3">in </span><span class="s1">generator</span>
                          <span class="s3">if </span><span class="s1">isinstance(element</span><span class="s3">, </span><span class="s1">Tag))</span>
                <span class="s3">return </span><span class="s1">ResultSet(strainer</span><span class="s3">, </span><span class="s1">result)</span>
            <span class="s3">elif </span><span class="s1">isinstance(name</span><span class="s3">, </span><span class="s1">str):</span>
                <span class="s0"># Optimization to find all tags with a given name.</span>
                <span class="s3">if </span><span class="s1">name.count(</span><span class="s2">':'</span><span class="s1">) == </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s0"># This is a name with a prefix. If this is a namespace-aware document,</span>
                    <span class="s0"># we need to match the local name against tag.name. If not,</span>
                    <span class="s0"># we need to match the fully-qualified name against tag.name.</span>
                    <span class="s1">prefix</span><span class="s3">, </span><span class="s1">local_name = name.split(</span><span class="s2">':'</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">prefix = </span><span class="s3">None</span>
                    <span class="s1">local_name = name</span>
                <span class="s1">result = (element </span><span class="s3">for </span><span class="s1">element </span><span class="s3">in </span><span class="s1">generator</span>
                          <span class="s3">if </span><span class="s1">isinstance(element</span><span class="s3">, </span><span class="s1">Tag)</span>
                          <span class="s3">and </span><span class="s1">(</span>
                              <span class="s1">element.name == name</span>
                          <span class="s1">) </span><span class="s3">or </span><span class="s1">(</span>
                              <span class="s1">element.name == local_name</span>
                              <span class="s3">and </span><span class="s1">(prefix </span><span class="s3">is None or </span><span class="s1">element.prefix == prefix)</span>
                          <span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s3">return </span><span class="s1">ResultSet(strainer</span><span class="s3">, </span><span class="s1">result)</span>
        <span class="s1">results = ResultSet(strainer)</span>
        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">i = next(generator)</span>
            <span class="s3">except </span><span class="s1">StopIteration:</span>
                <span class="s3">break</span>
            <span class="s3">if </span><span class="s1">i:</span>
                <span class="s1">found = strainer.search(i)</span>
                <span class="s3">if </span><span class="s1">found:</span>
                    <span class="s1">results.append(found)</span>
                    <span class="s3">if </span><span class="s1">limit </span><span class="s3">and </span><span class="s1">len(results) &gt;= limit:</span>
                        <span class="s3">break</span>
        <span class="s3">return </span><span class="s1">results</span>

    <span class="s0">#These generators can be used to navigate starting from both</span>
    <span class="s0">#NavigableStrings and Tags.</span>
    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">next_elements(self):</span>
        <span class="s5">&quot;&quot;&quot;All PageElements that were parsed after this one. 
 
        :yield: A sequence of PageElements. 
        &quot;&quot;&quot;</span>
        <span class="s1">i = self.next_element</span>
        <span class="s3">while </span><span class="s1">i </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">yield </span><span class="s1">i</span>
            <span class="s1">i = i.next_element</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">next_siblings(self):</span>
        <span class="s5">&quot;&quot;&quot;All PageElements that are siblings of this one but were parsed 
        later. 
 
        :yield: A sequence of PageElements. 
        &quot;&quot;&quot;</span>
        <span class="s1">i = self.next_sibling</span>
        <span class="s3">while </span><span class="s1">i </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">yield </span><span class="s1">i</span>
            <span class="s1">i = i.next_sibling</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">previous_elements(self):</span>
        <span class="s5">&quot;&quot;&quot;All PageElements that were parsed before this one. 
 
        :yield: A sequence of PageElements. 
        &quot;&quot;&quot;</span>
        <span class="s1">i = self.previous_element</span>
        <span class="s3">while </span><span class="s1">i </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">yield </span><span class="s1">i</span>
            <span class="s1">i = i.previous_element</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">previous_siblings(self):</span>
        <span class="s5">&quot;&quot;&quot;All PageElements that are siblings of this one but were parsed 
        earlier. 
 
        :yield: A sequence of PageElements. 
        &quot;&quot;&quot;</span>
        <span class="s1">i = self.previous_sibling</span>
        <span class="s3">while </span><span class="s1">i </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">yield </span><span class="s1">i</span>
            <span class="s1">i = i.previous_sibling</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">parents(self):</span>
        <span class="s5">&quot;&quot;&quot;All PageElements that are parents of this PageElement. 
 
        :yield: A sequence of PageElements. 
        &quot;&quot;&quot;</span>
        <span class="s1">i = self.parent</span>
        <span class="s3">while </span><span class="s1">i </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">yield </span><span class="s1">i</span>
            <span class="s1">i = i.parent</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">decomposed(self):</span>
        <span class="s5">&quot;&quot;&quot;Check whether a PageElement has been decomposed. 
 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">getattr(self</span><span class="s3">, </span><span class="s2">'_decomposed'</span><span class="s3">, False</span><span class="s1">) </span><span class="s3">or False</span>
            
    <span class="s0"># Old non-property versions of the generators, for backwards</span>
    <span class="s0"># compatibility with BS3.</span>
    <span class="s3">def </span><span class="s1">nextGenerator(self):</span>
        <span class="s3">return </span><span class="s1">self.next_elements</span>

    <span class="s3">def </span><span class="s1">nextSiblingGenerator(self):</span>
        <span class="s3">return </span><span class="s1">self.next_siblings</span>

    <span class="s3">def </span><span class="s1">previousGenerator(self):</span>
        <span class="s3">return </span><span class="s1">self.previous_elements</span>

    <span class="s3">def </span><span class="s1">previousSiblingGenerator(self):</span>
        <span class="s3">return </span><span class="s1">self.previous_siblings</span>

    <span class="s3">def </span><span class="s1">parentGenerator(self):</span>
        <span class="s3">return </span><span class="s1">self.parents</span>


<span class="s3">class </span><span class="s1">NavigableString(str</span><span class="s3">, </span><span class="s1">PageElement):</span>
    <span class="s5">&quot;&quot;&quot;A Python Unicode string that is part of a parse tree. 
 
    When Beautiful Soup parses the markup &lt;b&gt;penguin&lt;/b&gt;, it will 
    create a NavigableString for the string &quot;penguin&quot;. 
    &quot;&quot;&quot;   </span>

    <span class="s1">PREFIX = </span><span class="s2">''</span>
    <span class="s1">SUFFIX = </span><span class="s2">''</span>

    <span class="s0"># We can't tell just by looking at a string whether it's contained</span>
    <span class="s0"># in an XML document or an HTML document.</span>

    <span class="s1">known_xml = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">__new__(cls</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s5">&quot;&quot;&quot;Create a new NavigableString. 
 
        When unpickling a NavigableString, this method is called with 
        the string in DEFAULT_OUTPUT_ENCODING. That encoding needs to be 
        passed in to the superclass's __new__ or the superclass won't know 
        how to handle non-ASCII characters. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s1">u = str.__new__(cls</span><span class="s3">, </span><span class="s1">value)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">u = str.__new__(cls</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">DEFAULT_OUTPUT_ENCODING)</span>
        <span class="s1">u.setup()</span>
        <span class="s3">return </span><span class="s1">u</span>

    <span class="s3">def </span><span class="s1">__copy__(self):</span>
        <span class="s5">&quot;&quot;&quot;A copy of a NavigableString has the same contents and class 
        as the original, but it is not connected to the parse tree. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">type(self)(self)</span>

    <span class="s3">def </span><span class="s1">__getnewargs__(self):</span>
        <span class="s3">return </span><span class="s1">(str(self)</span><span class="s3">,</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__getattr__(self</span><span class="s3">, </span><span class="s1">attr):</span>
        <span class="s5">&quot;&quot;&quot;text.string gives you text. This is for backwards 
        compatibility for Navigable*String, but for CData* it lets you 
        get the string without the CData wrapper.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">attr == </span><span class="s2">'string'</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">AttributeError(</span>
                <span class="s2">&quot;'%s' object has no attribute '%s'&quot; </span><span class="s1">% (</span>
                    <span class="s1">self.__class__.__name__</span><span class="s3">, </span><span class="s1">attr))</span>

    <span class="s3">def </span><span class="s1">output_ready(self</span><span class="s3">, </span><span class="s1">formatter=</span><span class="s2">&quot;minimal&quot;</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Run the string through the provided formatter. 
 
        :param formatter: A Formatter object, or a string naming one of the standard formatters. 
        &quot;&quot;&quot;</span>
        <span class="s1">output = self.format_string(self</span><span class="s3">, </span><span class="s1">formatter)</span>
        <span class="s3">return </span><span class="s1">self.PREFIX + output + self.SUFFIX</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">name(self):</span>
        <span class="s5">&quot;&quot;&quot;Since a NavigableString is not a Tag, it has no .name. 
 
        This property is implemented so that code like this doesn't crash 
        when run on a mixture of Tag and NavigableString objects: 
            [x.name for x in tag.children] 
        &quot;&quot;&quot;</span>
        <span class="s3">return None</span>

    <span class="s1">@name.setter</span>
    <span class="s3">def </span><span class="s1">name(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s5">&quot;&quot;&quot;Prevent NavigableString.name from ever being set.&quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">AttributeError(</span><span class="s2">&quot;A NavigableString cannot be given a name.&quot;</span><span class="s1">)</span>

    
<span class="s3">class </span><span class="s1">PreformattedString(NavigableString):</span>
    <span class="s5">&quot;&quot;&quot;A NavigableString not subject to the normal formatting rules. 
 
    This is an abstract class used for special kinds of strings such 
    as comments (the Comment class) and CDATA blocks (the CData 
    class). 
    &quot;&quot;&quot;</span>
    
    <span class="s1">PREFIX = </span><span class="s2">''</span>
    <span class="s1">SUFFIX = </span><span class="s2">''</span>
    
    <span class="s3">def </span><span class="s1">output_ready(self</span><span class="s3">, </span><span class="s1">formatter=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Make this string ready for output by adding any subclass-specific 
            prefix or suffix. 
 
        :param formatter: A Formatter object, or a string naming one 
            of the standard formatters. The string will be passed into the 
            Formatter, but only to trigger any side effects: the return 
            value is ignored. 
 
        :return: The string, with any subclass-specific prefix and 
           suffix added on. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">formatter </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">ignore = self.format_string(self</span><span class="s3">, </span><span class="s1">formatter)</span>
        <span class="s3">return </span><span class="s1">self.PREFIX + self + self.SUFFIX</span>

<span class="s3">class </span><span class="s1">CData(PreformattedString):</span>
    <span class="s5">&quot;&quot;&quot;A CDATA block.&quot;&quot;&quot;</span>
    <span class="s1">PREFIX = </span><span class="s2">'&lt;![CDATA['</span>
    <span class="s1">SUFFIX = </span><span class="s2">']]&gt;'</span>

<span class="s3">class </span><span class="s1">ProcessingInstruction(PreformattedString):</span>
    <span class="s5">&quot;&quot;&quot;A SGML processing instruction.&quot;&quot;&quot;</span>

    <span class="s1">PREFIX = </span><span class="s2">'&lt;?'</span>
    <span class="s1">SUFFIX = </span><span class="s2">'&gt;'</span>

<span class="s3">class </span><span class="s1">XMLProcessingInstruction(ProcessingInstruction):</span>
    <span class="s5">&quot;&quot;&quot;An XML processing instruction.&quot;&quot;&quot;</span>
    <span class="s1">PREFIX = </span><span class="s2">'&lt;?'</span>
    <span class="s1">SUFFIX = </span><span class="s2">'?&gt;'</span>

<span class="s3">class </span><span class="s1">Comment(PreformattedString):</span>
    <span class="s5">&quot;&quot;&quot;An HTML or XML comment.&quot;&quot;&quot;</span>
    <span class="s1">PREFIX = </span><span class="s2">'&lt;!--'</span>
    <span class="s1">SUFFIX = </span><span class="s2">'--&gt;'</span>


<span class="s3">class </span><span class="s1">Declaration(PreformattedString):</span>
    <span class="s5">&quot;&quot;&quot;An XML declaration.&quot;&quot;&quot;</span>
    <span class="s1">PREFIX = </span><span class="s2">'&lt;?'</span>
    <span class="s1">SUFFIX = </span><span class="s2">'?&gt;'</span>


<span class="s3">class </span><span class="s1">Doctype(PreformattedString):</span>
    <span class="s5">&quot;&quot;&quot;A document type declaration.&quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">for_name_and_ids(cls</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">pub_id</span><span class="s3">, </span><span class="s1">system_id):</span>
        <span class="s5">&quot;&quot;&quot;Generate an appropriate document type declaration for a given 
        public ID and system ID. 
 
        :param name: The name of the document's root element, e.g. 'html'. 
        :param pub_id: The Formal Public Identifier for this document type, 
            e.g. '-//W3C//DTD XHTML 1.1//EN' 
        :param system_id: The system identifier for this document type, 
            e.g. 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd' 
 
        :return: A Doctype. 
        &quot;&quot;&quot;</span>
        <span class="s1">value = name </span><span class="s3">or </span><span class="s2">''</span>
        <span class="s3">if </span><span class="s1">pub_id </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">value += </span><span class="s2">' PUBLIC &quot;%s&quot;' </span><span class="s1">% pub_id</span>
            <span class="s3">if </span><span class="s1">system_id </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">value += </span><span class="s2">' &quot;%s&quot;' </span><span class="s1">% system_id</span>
        <span class="s3">elif </span><span class="s1">system_id </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">value += </span><span class="s2">' SYSTEM &quot;%s&quot;' </span><span class="s1">% system_id</span>

        <span class="s3">return </span><span class="s1">Doctype(value)</span>

    <span class="s1">PREFIX = </span><span class="s2">'&lt;!DOCTYPE '</span>
    <span class="s1">SUFFIX = </span><span class="s2">'&gt;</span><span class="s3">\n</span><span class="s2">'</span>


<span class="s3">class </span><span class="s1">Stylesheet(NavigableString):</span>
    <span class="s5">&quot;&quot;&quot;A NavigableString representing an stylesheet (probably 
    CSS). 
 
    Used to distinguish embedded stylesheets from textual content. 
    &quot;&quot;&quot;</span>
    <span class="s3">pass</span>

    
<span class="s3">class </span><span class="s1">Script(NavigableString):</span>
    <span class="s5">&quot;&quot;&quot;A NavigableString representing an executable script (probably 
    Javascript). 
 
    Used to distinguish executable code from textual content. 
    &quot;&quot;&quot;</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">TemplateString(NavigableString):</span>
    <span class="s5">&quot;&quot;&quot;A NavigableString representing a string found inside an HTML 
    template embedded in a larger document. 
 
    Used to distinguish such strings from the main body of the document. 
    &quot;&quot;&quot;</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">Tag(PageElement):</span>
    <span class="s5">&quot;&quot;&quot;Represents an HTML or XML tag that is part of a parse tree, along 
    with its attributes and contents. 
 
    When Beautiful Soup parses the markup &lt;b&gt;penguin&lt;/b&gt;, it will 
    create a Tag object representing the &lt;b&gt; tag. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">parser=</span><span class="s3">None, </span><span class="s1">builder=</span><span class="s3">None, </span><span class="s1">name=</span><span class="s3">None, </span><span class="s1">namespace=</span><span class="s3">None,</span>
                 <span class="s1">prefix=</span><span class="s3">None, </span><span class="s1">attrs=</span><span class="s3">None, </span><span class="s1">parent=</span><span class="s3">None, </span><span class="s1">previous=</span><span class="s3">None,</span>
                 <span class="s1">is_xml=</span><span class="s3">None, </span><span class="s1">sourceline=</span><span class="s3">None, </span><span class="s1">sourcepos=</span><span class="s3">None,</span>
                 <span class="s1">can_be_empty_element=</span><span class="s3">None, </span><span class="s1">cdata_list_attributes=</span><span class="s3">None,</span>
                 <span class="s1">preserve_whitespace_tags=</span><span class="s3">None</span>
    <span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Basic constructor. 
 
        :param parser: A BeautifulSoup object. 
        :param builder: A TreeBuilder. 
        :param name: The name of the tag. 
        :param namespace: The URI of this Tag's XML namespace, if any. 
        :param prefix: The prefix for this Tag's XML namespace, if any. 
        :param attrs: A dictionary of this Tag's attribute values. 
        :param parent: The PageElement to use as this Tag's parent. 
        :param previous: The PageElement that was parsed immediately before 
            this tag. 
        :param is_xml: If True, this is an XML tag. Otherwise, this is an 
            HTML tag. 
        :param sourceline: The line number where this tag was found in its 
            source document. 
        :param sourcepos: The character position within `sourceline` where this 
            tag was found. 
        :param can_be_empty_element: If True, this tag should be 
            represented as &lt;tag/&gt;. If False, this tag should be represented 
            as &lt;tag&gt;&lt;/tag&gt;. 
        :param cdata_list_attributes: A list of attributes whose values should 
            be treated as CDATA if they ever show up on this tag. 
        :param preserve_whitespace_tags: A list of tag names whose contents 
            should have their whitespace preserved. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">parser </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.parser_class = </span><span class="s3">None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># We don't actually store the parser object: that lets extracted</span>
            <span class="s0"># chunks be garbage-collected.</span>
            <span class="s1">self.parser_class = parser.__class__</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;No value provided for new tag's name.&quot;</span><span class="s1">)</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.namespace = namespace</span>
        <span class="s1">self.prefix = prefix</span>
        <span class="s3">if </span><span class="s1">((</span><span class="s3">not </span><span class="s1">builder </span><span class="s3">or </span><span class="s1">builder.store_line_numbers)</span>
            <span class="s3">and </span><span class="s1">(sourceline </span><span class="s3">is not None or </span><span class="s1">sourcepos </span><span class="s3">is not None</span><span class="s1">)):</span>
            <span class="s1">self.sourceline = sourceline</span>
            <span class="s1">self.sourcepos = sourcepos        </span>
        <span class="s3">if </span><span class="s1">attrs </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">attrs = {}</span>
        <span class="s3">elif </span><span class="s1">attrs:</span>
            <span class="s3">if </span><span class="s1">builder </span><span class="s3">is not None and </span><span class="s1">builder.cdata_list_attributes:</span>
                <span class="s1">attrs = builder._replace_cdata_list_attribute_values(</span>
                    <span class="s1">self.name</span><span class="s3">, </span><span class="s1">attrs)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">attrs = dict(attrs)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">attrs = dict(attrs)</span>

        <span class="s0"># If possible, determine ahead of time whether this tag is an</span>
        <span class="s0"># XML tag.</span>
        <span class="s3">if </span><span class="s1">builder:</span>
            <span class="s1">self.known_xml = builder.is_xml</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.known_xml = is_xml</span>
        <span class="s1">self.attrs = attrs</span>
        <span class="s1">self.contents = []</span>
        <span class="s1">self.setup(parent</span><span class="s3">, </span><span class="s1">previous)</span>
        <span class="s1">self.hidden = </span><span class="s3">False</span>

        <span class="s3">if </span><span class="s1">builder </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s0"># In the absence of a TreeBuilder, use whatever values were</span>
            <span class="s0"># passed in here. They're probably None, unless this is a copy of some</span>
            <span class="s0"># other tag.</span>
            <span class="s1">self.can_be_empty_element = can_be_empty_element</span>
            <span class="s1">self.cdata_list_attributes = cdata_list_attributes</span>
            <span class="s1">self.preserve_whitespace_tags = preserve_whitespace_tags</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># Set up any substitutions for this tag, such as the charset in a META tag.</span>
            <span class="s1">builder.set_up_substitutions(self)</span>

            <span class="s0"># Ask the TreeBuilder whether this tag might be an empty-element tag.</span>
            <span class="s1">self.can_be_empty_element = builder.can_be_empty_element(name)</span>

            <span class="s0"># Keep track of the list of attributes of this tag that</span>
            <span class="s0"># might need to be treated as a list.</span>
            <span class="s0">#</span>
            <span class="s0"># For performance reasons, we store the whole data structure</span>
            <span class="s0"># rather than asking the question of every tag. Asking would</span>
            <span class="s0"># require building a new data structure every time, and</span>
            <span class="s0"># (unlike can_be_empty_element), we almost never need</span>
            <span class="s0"># to check this.</span>
            <span class="s1">self.cdata_list_attributes = builder.cdata_list_attributes</span>

            <span class="s0"># Keep track of the names that might cause this tag to be treated as a</span>
            <span class="s0"># whitespace-preserved tag.</span>
            <span class="s1">self.preserve_whitespace_tags = builder.preserve_whitespace_tags</span>
            
    <span class="s1">parserClass = _alias(</span><span class="s2">&quot;parser_class&quot;</span><span class="s1">)  </span><span class="s0"># BS3</span>

    <span class="s3">def </span><span class="s1">__copy__(self):</span>
        <span class="s5">&quot;&quot;&quot;A copy of a Tag is a new Tag, unconnected to the parse tree. 
        Its contents are a copy of the old Tag's contents. 
        &quot;&quot;&quot;</span>
        <span class="s1">clone = type(self)(</span>
            <span class="s3">None, </span><span class="s1">self.builder</span><span class="s3">, </span><span class="s1">self.name</span><span class="s3">, </span><span class="s1">self.namespace</span><span class="s3">,</span>
            <span class="s1">self.prefix</span><span class="s3">, </span><span class="s1">self.attrs</span><span class="s3">, </span><span class="s1">is_xml=self._is_xml</span><span class="s3">,</span>
            <span class="s1">sourceline=self.sourceline</span><span class="s3">, </span><span class="s1">sourcepos=self.sourcepos</span><span class="s3">,</span>
            <span class="s1">can_be_empty_element=self.can_be_empty_element</span><span class="s3">,</span>
            <span class="s1">cdata_list_attributes=self.cdata_list_attributes</span><span class="s3">,</span>
            <span class="s1">preserve_whitespace_tags=self.preserve_whitespace_tags</span>
        <span class="s1">)</span>
        <span class="s3">for </span><span class="s1">attr </span><span class="s3">in </span><span class="s1">(</span><span class="s2">'can_be_empty_element'</span><span class="s3">, </span><span class="s2">'hidden'</span><span class="s1">):</span>
            <span class="s1">setattr(clone</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">getattr(self</span><span class="s3">, </span><span class="s1">attr))</span>
        <span class="s3">for </span><span class="s1">child </span><span class="s3">in </span><span class="s1">self.contents:</span>
            <span class="s1">clone.append(child.__copy__())</span>
        <span class="s3">return </span><span class="s1">clone</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_empty_element(self):</span>
        <span class="s5">&quot;&quot;&quot;Is this tag an empty-element tag? (aka a self-closing tag) 
 
        A tag that has contents is never an empty-element tag. 
 
        A tag that has no contents may or may not be an empty-element 
        tag. It depends on the builder used to create the tag. If the 
        builder has a designated list of empty-element tags, then only 
        a tag whose name shows up in that list is considered an 
        empty-element tag. 
 
        If the builder has no designated list of empty-element tags, 
        then any tag with no contents is an empty-element tag. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">len(self.contents) == </span><span class="s4">0 </span><span class="s3">and </span><span class="s1">self.can_be_empty_element</span>
    <span class="s1">isSelfClosing = is_empty_element  </span><span class="s0"># BS3</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">string(self):</span>
        <span class="s5">&quot;&quot;&quot;Convenience property to get the single string within this 
        PageElement. 
 
        TODO It might make sense to have NavigableString.string return 
        itself. 
 
        :return: If this element has a single string child, return 
         value is that string. If this element has one child tag, 
         return value is the 'string' attribute of the child tag, 
         recursively. If this element is itself a string, has no 
         children, or has more than one child, return value is None. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">len(self.contents) != </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3">return None</span>
        <span class="s1">child = self.contents[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">isinstance(child</span><span class="s3">, </span><span class="s1">NavigableString):</span>
            <span class="s3">return </span><span class="s1">child</span>
        <span class="s3">return </span><span class="s1">child.string</span>

    <span class="s1">@string.setter</span>
    <span class="s3">def </span><span class="s1">string(self</span><span class="s3">, </span><span class="s1">string):</span>
        <span class="s5">&quot;&quot;&quot;Replace this PageElement's contents with `string`.&quot;&quot;&quot;</span>
        <span class="s1">self.clear()</span>
        <span class="s1">self.append(string.__class__(string))</span>

    <span class="s3">def </span><span class="s1">_all_strings(self</span><span class="s3">, </span><span class="s1">strip=</span><span class="s3">False, </span><span class="s1">types=(NavigableString</span><span class="s3">, </span><span class="s1">CData)):</span>
        <span class="s5">&quot;&quot;&quot;Yield all strings of certain classes, possibly stripping them. 
 
        :param strip: If True, all strings will be stripped before being 
            yielded. 
 
        :types: A tuple of NavigableString subclasses. Any strings of 
            a subclass not found in this list will be ignored. By 
            default, this means only NavigableString and CData objects 
            will be considered. So no comments, processing instructions, 
            etc. 
 
        :yield: A sequence of strings. 
        &quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">descendant </span><span class="s3">in </span><span class="s1">self.descendants:</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">(types </span><span class="s3">is None and not </span><span class="s1">isinstance(descendant</span><span class="s3">, </span><span class="s1">NavigableString))</span>
                <span class="s3">or</span>
                <span class="s1">(types </span><span class="s3">is not None and </span><span class="s1">type(descendant) </span><span class="s3">not in </span><span class="s1">types)):</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">strip:</span>
                <span class="s1">descendant = descendant.strip()</span>
                <span class="s3">if </span><span class="s1">len(descendant) == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s3">continue</span>
            <span class="s3">yield </span><span class="s1">descendant</span>

    <span class="s1">strings = property(_all_strings)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">stripped_strings(self):</span>
        <span class="s5">&quot;&quot;&quot;Yield all strings in the document, stripping them first. 
 
        :yield: A sequence of stripped strings. 
        &quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">string </span><span class="s3">in </span><span class="s1">self._all_strings(</span><span class="s3">True</span><span class="s1">):</span>
            <span class="s3">yield </span><span class="s1">string</span>

    <span class="s3">def </span><span class="s1">get_text(self</span><span class="s3">, </span><span class="s1">separator=</span><span class="s2">&quot;&quot;</span><span class="s3">, </span><span class="s1">strip=</span><span class="s3">False,</span>
                 <span class="s1">types=(NavigableString</span><span class="s3">, </span><span class="s1">CData)):</span>
        <span class="s5">&quot;&quot;&quot;Get all child strings, concatenated using the given separator. 
 
        :param separator: Strings will be concatenated using this separator. 
 
        :param strip: If True, strings will be stripped before being 
            concatenated. 
 
        :types: A tuple of NavigableString subclasses. Any strings of 
            a subclass not found in this list will be ignored. By 
            default, this means only NavigableString and CData objects 
            will be considered. So no comments, processing instructions, 
            stylesheets, etc. 
 
        :return: A string. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">separator.join([s </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">self._all_strings(</span>
                    <span class="s1">strip</span><span class="s3">, </span><span class="s1">types=types)])</span>
    <span class="s1">getText = get_text</span>
    <span class="s1">text = property(get_text)</span>

    <span class="s3">def </span><span class="s1">decompose(self):</span>
        <span class="s5">&quot;&quot;&quot;Recursively destroys this PageElement and its children. 
 
        This element will be removed from the tree and wiped out; so 
        will everything beneath it. 
 
        The behavior of a decomposed PageElement is undefined and you 
        should never use one for anything, but if you need to _check_ 
        whether an element has been decomposed, you can use the 
        `decomposed` property. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.extract()</span>
        <span class="s1">i = self</span>
        <span class="s3">while </span><span class="s1">i </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">n = i.next_element</span>
            <span class="s1">i.__dict__.clear()</span>
            <span class="s1">i.contents = []</span>
            <span class="s1">i._decomposed = </span><span class="s3">True</span>
            <span class="s1">i = n</span>
           
    <span class="s3">def </span><span class="s1">clear(self</span><span class="s3">, </span><span class="s1">decompose=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Wipe out all children of this PageElement by calling extract() 
           on them. 
 
        :param decompose: If this is True, decompose() (a more 
            destructive method) will be called instead of extract(). 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">decompose:</span>
            <span class="s3">for </span><span class="s1">element </span><span class="s3">in </span><span class="s1">self.contents[:]:</span>
                <span class="s3">if </span><span class="s1">isinstance(element</span><span class="s3">, </span><span class="s1">Tag):</span>
                    <span class="s1">element.decompose()</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">element.extract()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">for </span><span class="s1">element </span><span class="s3">in </span><span class="s1">self.contents[:]:</span>
                <span class="s1">element.extract()</span>

    <span class="s3">def </span><span class="s1">smooth(self):</span>
        <span class="s5">&quot;&quot;&quot;Smooth out this element's children by consolidating consecutive 
        strings. 
 
        This makes pretty-printed output look more natural following a 
        lot of operations that modified the tree. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Mark the first position of every pair of children that need</span>
        <span class="s0"># to be consolidated.  Do this rather than making a copy of</span>
        <span class="s0"># self.contents, since in most cases very few strings will be</span>
        <span class="s0"># affected.</span>
        <span class="s1">marked = []</span>
        <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">a </span><span class="s3">in </span><span class="s1">enumerate(self.contents):</span>
            <span class="s3">if </span><span class="s1">isinstance(a</span><span class="s3">, </span><span class="s1">Tag):</span>
                <span class="s0"># Recursively smooth children.</span>
                <span class="s1">a.smooth()</span>
            <span class="s3">if </span><span class="s1">i == len(self.contents)-</span><span class="s4">1</span><span class="s1">:</span>
                <span class="s0"># This is the last item in .contents, and it's not a</span>
                <span class="s0"># tag. There's no chance it needs any work.</span>
                <span class="s3">continue</span>
            <span class="s1">b = self.contents[i+</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">(isinstance(a</span><span class="s3">, </span><span class="s1">NavigableString)</span>
                <span class="s3">and </span><span class="s1">isinstance(b</span><span class="s3">, </span><span class="s1">NavigableString)</span>
                <span class="s3">and not </span><span class="s1">isinstance(a</span><span class="s3">, </span><span class="s1">PreformattedString)</span>
                <span class="s3">and not </span><span class="s1">isinstance(b</span><span class="s3">, </span><span class="s1">PreformattedString)</span>
            <span class="s1">):</span>
                <span class="s1">marked.append(i)</span>

        <span class="s0"># Go over the marked positions in reverse order, so that</span>
        <span class="s0"># removing items from .contents won't affect the remaining</span>
        <span class="s0"># positions.</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">reversed(marked):</span>
            <span class="s1">a = self.contents[i]</span>
            <span class="s1">b = self.contents[i+</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">b.extract()</span>
            <span class="s1">n = NavigableString(a+b)</span>
            <span class="s1">a.replace_with(n)</span>

    <span class="s3">def </span><span class="s1">index(self</span><span class="s3">, </span><span class="s1">element):</span>
        <span class="s5">&quot;&quot;&quot;Find the index of a child by identity, not value. 
 
        Avoids issues with tag.contents.index(element) getting the 
        index of equal elements. 
 
        :param element: Look for this PageElement in `self.contents`. 
        &quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">child </span><span class="s3">in </span><span class="s1">enumerate(self.contents):</span>
            <span class="s3">if </span><span class="s1">child </span><span class="s3">is </span><span class="s1">element:</span>
                <span class="s3">return </span><span class="s1">i</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Tag.index: element not in tag&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">get(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">default=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Returns the value of the 'key' attribute for the tag, or 
        the value given for 'default' if it doesn't have that 
        attribute.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.attrs.get(key</span><span class="s3">, </span><span class="s1">default)</span>

    <span class="s3">def </span><span class="s1">get_attribute_list(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">default=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;The same as get(), but always returns a list. 
 
        :param key: The attribute to look for. 
        :param default: Use this value if the attribute is not present 
            on this PageElement. 
        :return: A list of values, probably containing only a single 
            value. 
        &quot;&quot;&quot;</span>
        <span class="s1">value = self.get(key</span><span class="s3">, </span><span class="s1">default)</span>
        <span class="s3">if not </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">list):</span>
            <span class="s1">value = [value]</span>
        <span class="s3">return </span><span class="s1">value</span>
    
    <span class="s3">def </span><span class="s1">has_attr(self</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s5">&quot;&quot;&quot;Does this PageElement have an attribute with the given name?&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self.attrs</span>

    <span class="s3">def </span><span class="s1">__hash__(self):</span>
        <span class="s3">return </span><span class="s1">str(self).__hash__()</span>

    <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s5">&quot;&quot;&quot;tag[key] returns the value of the 'key' attribute for the Tag, 
        and throws an exception if it's not there.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.attrs[key]</span>

    <span class="s3">def </span><span class="s1">__iter__(self):</span>
        <span class="s5">&quot;Iterating over a Tag iterates over its contents.&quot;</span>
        <span class="s3">return </span><span class="s1">iter(self.contents)</span>

    <span class="s3">def </span><span class="s1">__len__(self):</span>
        <span class="s5">&quot;The length of a Tag is the length of its list of contents.&quot;</span>
        <span class="s3">return </span><span class="s1">len(self.contents)</span>

    <span class="s3">def </span><span class="s1">__contains__(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">return </span><span class="s1">x </span><span class="s3">in </span><span class="s1">self.contents</span>

    <span class="s3">def </span><span class="s1">__bool__(self):</span>
        <span class="s5">&quot;A tag is non-None even if it has no contents.&quot;</span>
        <span class="s3">return True</span>

    <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s5">&quot;&quot;&quot;Setting tag[key] sets the value of the 'key' attribute for the 
        tag.&quot;&quot;&quot;</span>
        <span class="s1">self.attrs[key] = value</span>

    <span class="s3">def </span><span class="s1">__delitem__(self</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s5">&quot;Deleting tag[key] deletes all 'key' attributes for the tag.&quot;</span>
        <span class="s1">self.attrs.pop(key</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot;Calling a Tag like a function is the same as calling its 
        find_all() method. Eg. tag('a') returns a list of all the A tags 
        found within this tag.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.find_all(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>

    <span class="s3">def </span><span class="s1">__getattr__(self</span><span class="s3">, </span><span class="s1">tag):</span>
        <span class="s5">&quot;&quot;&quot;Calling tag.subtag is the same as calling tag.find(name=&quot;subtag&quot;)&quot;&quot;&quot;</span>
        <span class="s0">#print(&quot;Getattr %s.%s&quot; % (self.__class__, tag))</span>
        <span class="s3">if </span><span class="s1">len(tag) &gt; </span><span class="s4">3 </span><span class="s3">and </span><span class="s1">tag.endswith(</span><span class="s2">'Tag'</span><span class="s1">):</span>
            <span class="s0"># BS3: soup.aTag -&gt; &quot;soup.find(&quot;a&quot;)</span>
            <span class="s1">tag_name = tag[:-</span><span class="s4">3</span><span class="s1">]</span>
            <span class="s1">warnings.warn(</span>
                <span class="s2">'.%(name)sTag is deprecated, use .find(&quot;%(name)s&quot;) instead. If you really were looking for a tag called %(name)sTag, use .find(&quot;%(name)sTag&quot;)' </span><span class="s1">% dict(</span>
                    <span class="s1">name=tag_name</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s3">return </span><span class="s1">self.find(tag_name)</span>
        <span class="s0"># We special case contents to avoid recursion.</span>
        <span class="s3">elif not </span><span class="s1">tag.startswith(</span><span class="s2">&quot;__&quot;</span><span class="s1">) </span><span class="s3">and not </span><span class="s1">tag == </span><span class="s2">&quot;contents&quot;</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.find(tag)</span>
        <span class="s3">raise </span><span class="s1">AttributeError(</span>
            <span class="s2">&quot;'%s' object has no attribute '%s'&quot; </span><span class="s1">% (self.__class__</span><span class="s3">, </span><span class="s1">tag))</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s5">&quot;&quot;&quot;Returns true iff this Tag has the same name, the same attributes, 
        and the same contents (recursively) as `other`.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self </span><span class="s3">is </span><span class="s1">other:</span>
            <span class="s3">return True</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">not </span><span class="s1">hasattr(other</span><span class="s3">, </span><span class="s2">'name'</span><span class="s1">) </span><span class="s3">or</span>
            <span class="s3">not </span><span class="s1">hasattr(other</span><span class="s3">, </span><span class="s2">'attrs'</span><span class="s1">) </span><span class="s3">or</span>
            <span class="s3">not </span><span class="s1">hasattr(other</span><span class="s3">, </span><span class="s2">'contents'</span><span class="s1">) </span><span class="s3">or</span>
            <span class="s1">self.name != other.name </span><span class="s3">or</span>
            <span class="s1">self.attrs != other.attrs </span><span class="s3">or</span>
            <span class="s1">len(self) != len(other)):</span>
            <span class="s3">return False</span>
        <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">my_child </span><span class="s3">in </span><span class="s1">enumerate(self.contents):</span>
            <span class="s3">if </span><span class="s1">my_child != other.contents[i]:</span>
                <span class="s3">return False</span>
        <span class="s3">return True</span>

    <span class="s3">def </span><span class="s1">__ne__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s5">&quot;&quot;&quot;Returns true iff this Tag is not identical to `other`, 
        as defined in __eq__.&quot;&quot;&quot;</span>
        <span class="s3">return not </span><span class="s1">self == other</span>

    <span class="s3">def </span><span class="s1">__repr__(self</span><span class="s3">, </span><span class="s1">encoding=</span><span class="s2">&quot;unicode-escape&quot;</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Renders this PageElement as a string. 
 
        :param encoding: The encoding to use (Python 2 only). 
        :return: Under Python 2, a bytestring; under Python 3, 
            a Unicode string. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">PY3K:</span>
            <span class="s0"># &quot;The return value must be a string object&quot;, i.e. Unicode</span>
            <span class="s3">return </span><span class="s1">self.decode()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># &quot;The return value must be a string object&quot;, i.e. a bytestring.</span>
            <span class="s0"># By convention, the return value of __repr__ should also be</span>
            <span class="s0"># an ASCII string.</span>
            <span class="s3">return </span><span class="s1">self.encode(encoding)</span>

    <span class="s3">def </span><span class="s1">__unicode__(self):</span>
        <span class="s5">&quot;&quot;&quot;Renders this PageElement as a Unicode string.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.decode()</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s5">&quot;&quot;&quot;Renders this PageElement as a generic string. 
 
        :return: Under Python 2, a UTF-8 bytestring; under Python 3, 
            a Unicode string.         
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">PY3K:</span>
            <span class="s3">return </span><span class="s1">self.decode()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.encode()</span>

    <span class="s3">if </span><span class="s1">PY3K:</span>
        <span class="s1">__str__ = __repr__ = __unicode__</span>

    <span class="s3">def </span><span class="s1">encode(self</span><span class="s3">, </span><span class="s1">encoding=DEFAULT_OUTPUT_ENCODING</span><span class="s3">,</span>
               <span class="s1">indent_level=</span><span class="s3">None, </span><span class="s1">formatter=</span><span class="s2">&quot;minimal&quot;</span><span class="s3">,</span>
               <span class="s1">errors=</span><span class="s2">&quot;xmlcharrefreplace&quot;</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Render a bytestring representation of this PageElement and its 
        contents. 
 
        :param encoding: The destination encoding. 
        :param indent_level: Each line of the rendering will be 
            indented this many spaces. Used internally in 
            recursive calls while pretty-printing. 
        :param formatter: A Formatter object, or a string naming one of 
            the standard formatters. 
        :param errors: An error handling strategy such as 
            'xmlcharrefreplace'. This value is passed along into 
            encode() and its value should be one of the constants 
            defined by Python. 
        :return: A bytestring. 
 
        &quot;&quot;&quot;</span>
        <span class="s0"># Turn the data structure into Unicode, then encode the</span>
        <span class="s0"># Unicode.</span>
        <span class="s1">u = self.decode(indent_level</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">, </span><span class="s1">formatter)</span>
        <span class="s3">return </span><span class="s1">u.encode(encoding</span><span class="s3">, </span><span class="s1">errors)</span>

    <span class="s3">def </span><span class="s1">decode(self</span><span class="s3">, </span><span class="s1">indent_level=</span><span class="s3">None,</span>
               <span class="s1">eventual_encoding=DEFAULT_OUTPUT_ENCODING</span><span class="s3">,</span>
               <span class="s1">formatter=</span><span class="s2">&quot;minimal&quot;</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Render a Unicode representation of this PageElement and its 
        contents. 
 
        :param indent_level: Each line of the rendering will be 
             indented this many spaces. Used internally in 
             recursive calls while pretty-printing. 
        :param eventual_encoding: The tag is destined to be 
            encoded into this encoding. This method is _not_ 
            responsible for performing that encoding. This information 
            is passed in so that it can be substituted in if the 
            document contains a &lt;META&gt; tag that mentions the document's 
            encoding. 
        :param formatter: A Formatter object, or a string naming one of 
            the standard formatters. 
        &quot;&quot;&quot;</span>

        <span class="s0"># First off, turn a non-Formatter `formatter` into a Formatter</span>
        <span class="s0"># object. This will stop the lookup from happening over and</span>
        <span class="s0"># over again.</span>
        <span class="s3">if not </span><span class="s1">isinstance(formatter</span><span class="s3">, </span><span class="s1">Formatter):</span>
            <span class="s1">formatter = self.formatter_for_name(formatter)</span>
        <span class="s1">attributes = formatter.attributes(self)</span>
        <span class="s1">attrs = []</span>
        <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">val </span><span class="s3">in </span><span class="s1">attributes:</span>
            <span class="s3">if </span><span class="s1">val </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">decoded = key</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">isinstance(val</span><span class="s3">, </span><span class="s1">list) </span><span class="s3">or </span><span class="s1">isinstance(val</span><span class="s3">, </span><span class="s1">tuple):</span>
                    <span class="s1">val = </span><span class="s2">' '</span><span class="s1">.join(val)</span>
                <span class="s3">elif not </span><span class="s1">isinstance(val</span><span class="s3">, </span><span class="s1">str):</span>
                    <span class="s1">val = str(val)</span>
                <span class="s3">elif </span><span class="s1">(</span>
                        <span class="s1">isinstance(val</span><span class="s3">, </span><span class="s1">AttributeValueWithCharsetSubstitution)</span>
                        <span class="s3">and </span><span class="s1">eventual_encoding </span><span class="s3">is not None</span>
                <span class="s1">):</span>
                    <span class="s1">val = val.encode(eventual_encoding)</span>

                <span class="s1">text = formatter.attribute_value(val)</span>
                <span class="s1">decoded = (</span>
                    <span class="s1">str(key) + </span><span class="s2">'='</span>
                    <span class="s1">+ formatter.quoted_attribute_value(text))</span>
            <span class="s1">attrs.append(decoded)</span>
        <span class="s1">close = </span><span class="s2">''</span>
        <span class="s1">closeTag = </span><span class="s2">''</span>

        <span class="s1">prefix = </span><span class="s2">''</span>
        <span class="s3">if </span><span class="s1">self.prefix:</span>
            <span class="s1">prefix = self.prefix + </span><span class="s2">&quot;:&quot;</span>

        <span class="s3">if </span><span class="s1">self.is_empty_element:</span>
            <span class="s1">close = formatter.void_element_close_prefix </span><span class="s3">or </span><span class="s2">''</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">closeTag = </span><span class="s2">'&lt;/%s%s&gt;' </span><span class="s1">% (prefix</span><span class="s3">, </span><span class="s1">self.name)</span>

        <span class="s1">pretty_print = self._should_pretty_print(indent_level)</span>
        <span class="s1">space = </span><span class="s2">''</span>
        <span class="s1">indent_space = </span><span class="s2">''</span>
        <span class="s3">if </span><span class="s1">indent_level </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">indent_space = (</span><span class="s2">' ' </span><span class="s1">* (indent_level - </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s3">if </span><span class="s1">pretty_print:</span>
            <span class="s1">space = indent_space</span>
            <span class="s1">indent_contents = indent_level + </span><span class="s4">1</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">indent_contents = </span><span class="s3">None</span>
        <span class="s1">contents = self.decode_contents(</span>
            <span class="s1">indent_contents</span><span class="s3">, </span><span class="s1">eventual_encoding</span><span class="s3">, </span><span class="s1">formatter</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">self.hidden:</span>
            <span class="s0"># This is the 'document root' object.</span>
            <span class="s1">s = contents</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">s = []</span>
            <span class="s1">attribute_string = </span><span class="s2">''</span>
            <span class="s3">if </span><span class="s1">attrs:</span>
                <span class="s1">attribute_string = </span><span class="s2">' ' </span><span class="s1">+ </span><span class="s2">' '</span><span class="s1">.join(attrs)</span>
            <span class="s3">if </span><span class="s1">indent_level </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s0"># Even if this particular tag is not pretty-printed,</span>
                <span class="s0"># we should indent up to the start of the tag.</span>
                <span class="s1">s.append(indent_space)</span>
            <span class="s1">s.append(</span><span class="s2">'&lt;%s%s%s%s&gt;' </span><span class="s1">% (</span>
                    <span class="s1">prefix</span><span class="s3">, </span><span class="s1">self.name</span><span class="s3">, </span><span class="s1">attribute_string</span><span class="s3">, </span><span class="s1">close))</span>
            <span class="s3">if </span><span class="s1">pretty_print:</span>
                <span class="s1">s.append(</span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">&quot;</span><span class="s1">)</span>
            <span class="s1">s.append(contents)</span>
            <span class="s3">if </span><span class="s1">pretty_print </span><span class="s3">and </span><span class="s1">contents </span><span class="s3">and </span><span class="s1">contents[-</span><span class="s4">1</span><span class="s1">] != </span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">&quot;</span><span class="s1">:</span>
                <span class="s1">s.append(</span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">pretty_print </span><span class="s3">and </span><span class="s1">closeTag:</span>
                <span class="s1">s.append(space)</span>
            <span class="s1">s.append(closeTag)</span>
            <span class="s3">if </span><span class="s1">indent_level </span><span class="s3">is not None and </span><span class="s1">closeTag </span><span class="s3">and </span><span class="s1">self.next_sibling:</span>
                <span class="s0"># Even if this particular tag is not pretty-printed,</span>
                <span class="s0"># we're now done with the tag, and we should add a</span>
                <span class="s0"># newline if appropriate.</span>
                <span class="s1">s.append(</span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">&quot;</span><span class="s1">)</span>
            <span class="s1">s = </span><span class="s2">''</span><span class="s1">.join(s)</span>
        <span class="s3">return </span><span class="s1">s</span>

    <span class="s3">def </span><span class="s1">_should_pretty_print(self</span><span class="s3">, </span><span class="s1">indent_level):</span>
        <span class="s5">&quot;&quot;&quot;Should this tag be pretty-printed? 
 
        Most of them should, but some (such as &lt;pre&gt; in HTML 
        documents) should not. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">indent_level </span><span class="s3">is not None</span>
            <span class="s3">and </span><span class="s1">(</span>
                <span class="s3">not </span><span class="s1">self.preserve_whitespace_tags</span>
                <span class="s3">or </span><span class="s1">self.name </span><span class="s3">not in </span><span class="s1">self.preserve_whitespace_tags</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">prettify(self</span><span class="s3">, </span><span class="s1">encoding=</span><span class="s3">None, </span><span class="s1">formatter=</span><span class="s2">&quot;minimal&quot;</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Pretty-print this PageElement as a string. 
 
        :param encoding: The eventual encoding of the string. If this is None, 
            a Unicode string will be returned. 
        :param formatter: A Formatter object, or a string naming one of 
            the standard formatters. 
        :return: A Unicode string (if encoding==None) or a bytestring  
            (otherwise). 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">encoding </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.decode(</span><span class="s3">True, </span><span class="s1">formatter=formatter)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.encode(encoding</span><span class="s3">, True, </span><span class="s1">formatter=formatter)</span>

    <span class="s3">def </span><span class="s1">decode_contents(self</span><span class="s3">, </span><span class="s1">indent_level=</span><span class="s3">None,</span>
                       <span class="s1">eventual_encoding=DEFAULT_OUTPUT_ENCODING</span><span class="s3">,</span>
                       <span class="s1">formatter=</span><span class="s2">&quot;minimal&quot;</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Renders the contents of this tag as a Unicode string. 
 
        :param indent_level: Each line of the rendering will be 
           indented this many spaces. Used internally in 
           recursive calls while pretty-printing. 
 
        :param eventual_encoding: The tag is destined to be 
           encoded into this encoding. decode_contents() is _not_ 
           responsible for performing that encoding. This information 
           is passed in so that it can be substituted in if the 
           document contains a &lt;META&gt; tag that mentions the document's 
           encoding. 
 
        :param formatter: A Formatter object, or a string naming one of 
            the standard Formatters. 
        &quot;&quot;&quot;</span>
        <span class="s0"># First off, turn a string formatter into a Formatter object. This</span>
        <span class="s0"># will stop the lookup from happening over and over again.</span>
        <span class="s3">if not </span><span class="s1">isinstance(formatter</span><span class="s3">, </span><span class="s1">Formatter):</span>
            <span class="s1">formatter = self.formatter_for_name(formatter)</span>

        <span class="s1">pretty_print = (indent_level </span><span class="s3">is not None</span><span class="s1">)</span>
        <span class="s1">s = []</span>
        <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self:</span>
            <span class="s1">text = </span><span class="s3">None</span>
            <span class="s3">if </span><span class="s1">isinstance(c</span><span class="s3">, </span><span class="s1">NavigableString):</span>
                <span class="s1">text = c.output_ready(formatter)</span>
            <span class="s3">elif </span><span class="s1">isinstance(c</span><span class="s3">, </span><span class="s1">Tag):</span>
                <span class="s1">s.append(c.decode(indent_level</span><span class="s3">, </span><span class="s1">eventual_encoding</span><span class="s3">,</span>
                                  <span class="s1">formatter))</span>
            <span class="s1">preserve_whitespace = (</span>
                <span class="s1">self.preserve_whitespace_tags </span><span class="s3">and </span><span class="s1">self.name </span><span class="s3">in </span><span class="s1">self.preserve_whitespace_tags</span>
            <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">text </span><span class="s3">and </span><span class="s1">indent_level </span><span class="s3">and not </span><span class="s1">preserve_whitespace:</span>
                <span class="s1">text = text.strip()</span>
            <span class="s3">if </span><span class="s1">text:</span>
                <span class="s3">if </span><span class="s1">pretty_print </span><span class="s3">and not </span><span class="s1">preserve_whitespace:</span>
                    <span class="s1">s.append(</span><span class="s2">&quot; &quot; </span><span class="s1">* (indent_level - </span><span class="s4">1</span><span class="s1">))</span>
                <span class="s1">s.append(text)</span>
                <span class="s3">if </span><span class="s1">pretty_print </span><span class="s3">and not </span><span class="s1">preserve_whitespace:</span>
                    <span class="s1">s.append(</span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">&quot;</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s2">''</span><span class="s1">.join(s)</span>
       
    <span class="s3">def </span><span class="s1">encode_contents(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">indent_level=</span><span class="s3">None, </span><span class="s1">encoding=DEFAULT_OUTPUT_ENCODING</span><span class="s3">,</span>
        <span class="s1">formatter=</span><span class="s2">&quot;minimal&quot;</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Renders the contents of this PageElement as a bytestring. 
 
        :param indent_level: Each line of the rendering will be 
           indented this many spaces. Used internally in 
           recursive calls while pretty-printing. 
 
        :param eventual_encoding: The bytestring will be in this encoding. 
 
        :param formatter: A Formatter object, or a string naming one of 
            the standard Formatters. 
 
        :return: A bytestring. 
        &quot;&quot;&quot;</span>
        <span class="s1">contents = self.decode_contents(indent_level</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">, </span><span class="s1">formatter)</span>
        <span class="s3">return </span><span class="s1">contents.encode(encoding)</span>

    <span class="s0"># Old method for BS3 compatibility</span>
    <span class="s3">def </span><span class="s1">renderContents(self</span><span class="s3">, </span><span class="s1">encoding=DEFAULT_OUTPUT_ENCODING</span><span class="s3">,</span>
                       <span class="s1">prettyPrint=</span><span class="s3">False, </span><span class="s1">indentLevel=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Deprecated method for BS3 compatibility.&quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">prettyPrint:</span>
            <span class="s1">indentLevel = </span><span class="s3">None</span>
        <span class="s3">return </span><span class="s1">self.encode_contents(</span>
            <span class="s1">indent_level=indentLevel</span><span class="s3">, </span><span class="s1">encoding=encoding)</span>

    <span class="s0">#Soup methods</span>

    <span class="s3">def </span><span class="s1">find(self</span><span class="s3">, </span><span class="s1">name=</span><span class="s3">None, </span><span class="s1">attrs={}</span><span class="s3">, </span><span class="s1">recursive=</span><span class="s3">True, </span><span class="s1">text=</span><span class="s3">None,</span>
             <span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot;Look in the children of this PageElement and find the first 
        PageElement that matches the given criteria. 
 
        All find_* methods take a common set of arguments. See the online 
        documentation for detailed explanations. 
 
        :param name: A filter on tag name. 
        :param attrs: A dictionary of filters on attribute values. 
        :param recursive: If this is True, find() will perform a 
            recursive search of this PageElement's children. Otherwise, 
            only the direct children will be considered. 
        :param limit: Stop looking after finding this many results. 
        :kwargs: A dictionary of filters on attribute values. 
        :return: A PageElement. 
        :rtype: bs4.element.Tag | bs4.element.NavigableString 
        &quot;&quot;&quot;</span>
        <span class="s1">r = </span><span class="s3">None</span>
        <span class="s1">l = self.find_all(name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">recursive</span><span class="s3">, </span><span class="s1">text</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s3">if </span><span class="s1">l:</span>
            <span class="s1">r = l[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s3">return </span><span class="s1">r</span>
    <span class="s1">findChild = find </span><span class="s0">#BS2</span>

    <span class="s3">def </span><span class="s1">find_all(self</span><span class="s3">, </span><span class="s1">name=</span><span class="s3">None, </span><span class="s1">attrs={}</span><span class="s3">, </span><span class="s1">recursive=</span><span class="s3">True, </span><span class="s1">text=</span><span class="s3">None,</span>
                 <span class="s1">limit=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot;Look in the children of this PageElement and find all 
        PageElements that match the given criteria. 
 
        All find_* methods take a common set of arguments. See the online 
        documentation for detailed explanations. 
 
        :param name: A filter on tag name. 
        :param attrs: A dictionary of filters on attribute values. 
        :param recursive: If this is True, find_all() will perform a 
            recursive search of this PageElement's children. Otherwise, 
            only the direct children will be considered. 
        :param limit: Stop looking after finding this many results. 
        :kwargs: A dictionary of filters on attribute values. 
        :return: A ResultSet of PageElements. 
        :rtype: bs4.element.ResultSet 
        &quot;&quot;&quot;</span>
        <span class="s1">generator = self.descendants</span>
        <span class="s3">if not </span><span class="s1">recursive:</span>
            <span class="s1">generator = self.children</span>
        <span class="s3">return </span><span class="s1">self._find_all(name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">text</span><span class="s3">, </span><span class="s1">limit</span><span class="s3">, </span><span class="s1">generator</span><span class="s3">, </span><span class="s1">**kwargs)</span>
    <span class="s1">findAll = find_all       </span><span class="s0"># BS3</span>
    <span class="s1">findChildren = find_all  </span><span class="s0"># BS2</span>

    <span class="s0">#Generator methods</span>
    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">children(self):</span>
        <span class="s5">&quot;&quot;&quot;Iterate over all direct children of this PageElement. 
 
        :yield: A sequence of PageElements. 
        &quot;&quot;&quot;</span>
        <span class="s0"># return iter() to make the purpose of the method clear</span>
        <span class="s3">return </span><span class="s1">iter(self.contents)  </span><span class="s0"># XXX This seems to be untested.</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">descendants(self):</span>
        <span class="s5">&quot;&quot;&quot;Iterate over all children of this PageElement in a 
        breadth-first sequence. 
 
        :yield: A sequence of PageElements. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">len(self.contents):</span>
            <span class="s3">return</span>
        <span class="s1">stopNode = self._last_descendant().next_element</span>
        <span class="s1">current = self.contents[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s3">while </span><span class="s1">current </span><span class="s3">is not </span><span class="s1">stopNode:</span>
            <span class="s3">yield </span><span class="s1">current</span>
            <span class="s1">current = current.next_element</span>

    <span class="s0"># CSS selector code</span>
    <span class="s3">def </span><span class="s1">select_one(self</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">namespaces=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot;Perform a CSS selection operation on the current element. 
 
        :param selector: A CSS selector. 
 
        :param namespaces: A dictionary mapping namespace prefixes 
           used in the CSS selector to namespace URIs. By default, 
           Beautiful Soup will use the prefixes it encountered while 
           parsing the document. 
 
        :param kwargs: Keyword arguments to be passed into SoupSieve's  
           soupsieve.select() method. 
 
        :return: A Tag. 
        :rtype: bs4.element.Tag 
        &quot;&quot;&quot;</span>
        <span class="s1">value = self.select(selector</span><span class="s3">, </span><span class="s1">namespaces</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s3">if </span><span class="s1">value:</span>
            <span class="s3">return </span><span class="s1">value[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">select(self</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">namespaces=</span><span class="s3">None, </span><span class="s1">limit=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot;Perform a CSS selection operation on the current element. 
 
        This uses the SoupSieve library. 
 
        :param selector: A string containing a CSS selector. 
 
        :param namespaces: A dictionary mapping namespace prefixes 
           used in the CSS selector to namespace URIs. By default, 
           Beautiful Soup will use the prefixes it encountered while 
           parsing the document. 
 
        :param limit: After finding this number of results, stop looking. 
 
        :param kwargs: Keyword arguments to be passed into SoupSieve's  
           soupsieve.select() method. 
 
        :return: A ResultSet of Tags. 
        :rtype: bs4.element.ResultSet 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">namespaces </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">namespaces = self._namespaces</span>
        
        <span class="s3">if </span><span class="s1">limit </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">limit = </span><span class="s4">0</span>
        <span class="s3">if </span><span class="s1">soupsieve </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s2">&quot;Cannot execute CSS selectors because the soupsieve package is not installed.&quot;</span>
            <span class="s1">)</span>
            
        <span class="s1">results = soupsieve.select(selector</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">namespaces</span><span class="s3">, </span><span class="s1">limit</span><span class="s3">, </span><span class="s1">**kwargs)</span>

        <span class="s0"># We do this because it's more consistent and because</span>
        <span class="s0"># ResultSet.__getattr__ has a helpful error message.</span>
        <span class="s3">return </span><span class="s1">ResultSet(</span><span class="s3">None, </span><span class="s1">results)</span>

    <span class="s0"># Old names for backwards compatibility</span>
    <span class="s3">def </span><span class="s1">childGenerator(self):</span>
        <span class="s5">&quot;&quot;&quot;Deprecated generator.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.children</span>

    <span class="s3">def </span><span class="s1">recursiveChildGenerator(self):</span>
        <span class="s5">&quot;&quot;&quot;Deprecated generator.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.descendants</span>

    <span class="s3">def </span><span class="s1">has_key(self</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s5">&quot;&quot;&quot;Deprecated method. This was kind of misleading because has_key() 
        (attributes) was different from __in__ (contents). 
 
        has_key() is gone in Python 3, anyway. 
        &quot;&quot;&quot;</span>
        <span class="s1">warnings.warn(</span><span class="s2">'has_key is deprecated. Use has_attr(&quot;%s&quot;) instead.' </span><span class="s1">% (</span>
                <span class="s1">key))</span>
        <span class="s3">return </span><span class="s1">self.has_attr(key)</span>

<span class="s0"># Next, a couple classes to represent queries and their results.</span>
<span class="s3">class </span><span class="s1">SoupStrainer(object):</span>
    <span class="s5">&quot;&quot;&quot;Encapsulates a number of ways of matching a markup element (tag or 
    string). 
 
    This is primarily used to underpin the find_* methods, but you can 
    create one yourself and pass it in as `parse_only` to the 
    `BeautifulSoup` constructor, to parse a subset of a large 
    document. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">name=</span><span class="s3">None, </span><span class="s1">attrs={}</span><span class="s3">, </span><span class="s1">text=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot;Constructor. 
 
        The SoupStrainer constructor takes the same arguments passed 
        into the find_* methods. See the online documentation for 
        detailed explanations. 
 
        :param name: A filter on tag name. 
        :param attrs: A dictionary of filters on attribute values. 
        :param text: A filter for a NavigableString with specific text. 
        :kwargs: A dictionary of filters on attribute values. 
        &quot;&quot;&quot;        </span>
        <span class="s1">self.name = self._normalize_search_value(name)</span>
        <span class="s3">if not </span><span class="s1">isinstance(attrs</span><span class="s3">, </span><span class="s1">dict):</span>
            <span class="s0"># Treat a non-dict value for attrs as a search for the 'class'</span>
            <span class="s0"># attribute.</span>
            <span class="s1">kwargs[</span><span class="s2">'class'</span><span class="s1">] = attrs</span>
            <span class="s1">attrs = </span><span class="s3">None</span>

        <span class="s3">if </span><span class="s2">'class_' </span><span class="s3">in </span><span class="s1">kwargs:</span>
            <span class="s0"># Treat class_=&quot;foo&quot; as a search for the 'class'</span>
            <span class="s0"># attribute, overriding any non-dict value for attrs.</span>
            <span class="s1">kwargs[</span><span class="s2">'class'</span><span class="s1">] = kwargs[</span><span class="s2">'class_'</span><span class="s1">]</span>
            <span class="s3">del </span><span class="s1">kwargs[</span><span class="s2">'class_'</span><span class="s1">]</span>

        <span class="s3">if </span><span class="s1">kwargs:</span>
            <span class="s3">if </span><span class="s1">attrs:</span>
                <span class="s1">attrs = attrs.copy()</span>
                <span class="s1">attrs.update(kwargs)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">attrs = kwargs</span>
        <span class="s1">normalized_attrs = {}</span>
        <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">list(attrs.items()):</span>
            <span class="s1">normalized_attrs[key] = self._normalize_search_value(value)</span>

        <span class="s1">self.attrs = normalized_attrs</span>
        <span class="s1">self.text = self._normalize_search_value(text)</span>

    <span class="s3">def </span><span class="s1">_normalize_search_value(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0"># Leave it alone if it's a Unicode string, a callable, a</span>
        <span class="s0"># regular expression, a boolean, or None.</span>
        <span class="s3">if </span><span class="s1">(isinstance(value</span><span class="s3">, </span><span class="s1">str) </span><span class="s3">or </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">Callable) </span><span class="s3">or </span><span class="s1">hasattr(value</span><span class="s3">, </span><span class="s2">'match'</span><span class="s1">)</span>
            <span class="s3">or </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">bool) </span><span class="s3">or </span><span class="s1">value </span><span class="s3">is None</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">value</span>

        <span class="s0"># If it's a bytestring, convert it to Unicode, treating it as UTF-8.</span>
        <span class="s3">if </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">bytes):</span>
            <span class="s3">return </span><span class="s1">value.decode(</span><span class="s2">&quot;utf8&quot;</span><span class="s1">)</span>

        <span class="s0"># If it's listlike, convert it into a list of strings.</span>
        <span class="s3">if </span><span class="s1">hasattr(value</span><span class="s3">, </span><span class="s2">'__iter__'</span><span class="s1">):</span>
            <span class="s1">new_value = []</span>
            <span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">value:</span>
                <span class="s3">if </span><span class="s1">(hasattr(v</span><span class="s3">, </span><span class="s2">'__iter__'</span><span class="s1">) </span><span class="s3">and not </span><span class="s1">isinstance(v</span><span class="s3">, </span><span class="s1">bytes)</span>
                    <span class="s3">and not </span><span class="s1">isinstance(v</span><span class="s3">, </span><span class="s1">str)):</span>
                    <span class="s0"># This is almost certainly the user's mistake. In the</span>
                    <span class="s0"># interests of avoiding infinite loops, we'll let</span>
                    <span class="s0"># it through as-is rather than doing a recursive call.</span>
                    <span class="s1">new_value.append(v)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">new_value.append(self._normalize_search_value(v))</span>
            <span class="s3">return </span><span class="s1">new_value</span>

        <span class="s0"># Otherwise, convert it into a Unicode string.</span>
        <span class="s0"># The unicode(str()) thing is so this will do the same thing on Python 2</span>
        <span class="s0"># and Python 3.</span>
        <span class="s3">return </span><span class="s1">str(str(value))</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s5">&quot;&quot;&quot;A human-readable representation of this SoupStrainer.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.text:</span>
            <span class="s3">return </span><span class="s1">self.text</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s2">&quot;%s|%s&quot; </span><span class="s1">% (self.name</span><span class="s3">, </span><span class="s1">self.attrs)</span>

    <span class="s3">def </span><span class="s1">search_tag(self</span><span class="s3">, </span><span class="s1">markup_name=</span><span class="s3">None, </span><span class="s1">markup_attrs={}):</span>
        <span class="s5">&quot;&quot;&quot;Check whether a Tag with the given name and attributes would 
        match this SoupStrainer. 
 
        Used prospectively to decide whether to even bother creating a Tag 
        object. 
 
        :param markup_name: A tag name as found in some markup. 
        :param markup_attrs: A dictionary of attributes as found in some markup. 
 
        :return: True if the prospective tag would match this SoupStrainer; 
            False otherwise. 
        &quot;&quot;&quot;</span>
        <span class="s1">found = </span><span class="s3">None</span>
        <span class="s1">markup = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">isinstance(markup_name</span><span class="s3">, </span><span class="s1">Tag):</span>
            <span class="s1">markup = markup_name</span>
            <span class="s1">markup_attrs = markup</span>

        <span class="s3">if </span><span class="s1">isinstance(self.name</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s0"># Optimization for a very common case where the user is</span>
            <span class="s0"># searching for a tag with one specific name, and we're</span>
            <span class="s0"># looking at a tag with a different name.</span>
            <span class="s3">if </span><span class="s1">markup </span><span class="s3">and not </span><span class="s1">markup.prefix </span><span class="s3">and </span><span class="s1">self.name != markup.name:</span>
                 <span class="s3">return False</span>
            
        <span class="s1">call_function_with_tag_data = (</span>
            <span class="s1">isinstance(self.name</span><span class="s3">, </span><span class="s1">Callable)</span>
            <span class="s3">and not </span><span class="s1">isinstance(markup_name</span><span class="s3">, </span><span class="s1">Tag))</span>

        <span class="s3">if </span><span class="s1">((</span><span class="s3">not </span><span class="s1">self.name)</span>
            <span class="s3">or </span><span class="s1">call_function_with_tag_data</span>
            <span class="s3">or </span><span class="s1">(markup </span><span class="s3">and </span><span class="s1">self._matches(markup</span><span class="s3">, </span><span class="s1">self.name))</span>
            <span class="s3">or </span><span class="s1">(</span><span class="s3">not </span><span class="s1">markup </span><span class="s3">and </span><span class="s1">self._matches(markup_name</span><span class="s3">, </span><span class="s1">self.name))):</span>
            <span class="s3">if </span><span class="s1">call_function_with_tag_data:</span>
                <span class="s1">match = self.name(markup_name</span><span class="s3">, </span><span class="s1">markup_attrs)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">match = </span><span class="s3">True</span>
                <span class="s1">markup_attr_map = </span><span class="s3">None</span>
                <span class="s3">for </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">match_against </span><span class="s3">in </span><span class="s1">list(self.attrs.items()):</span>
                    <span class="s3">if not </span><span class="s1">markup_attr_map:</span>
                        <span class="s3">if </span><span class="s1">hasattr(markup_attrs</span><span class="s3">, </span><span class="s2">'get'</span><span class="s1">):</span>
                            <span class="s1">markup_attr_map = markup_attrs</span>
                        <span class="s3">else</span><span class="s1">:</span>
                            <span class="s1">markup_attr_map = {}</span>
                            <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">markup_attrs:</span>
                                <span class="s1">markup_attr_map[k] = v</span>
                    <span class="s1">attr_value = markup_attr_map.get(attr)</span>
                    <span class="s3">if not </span><span class="s1">self._matches(attr_value</span><span class="s3">, </span><span class="s1">match_against):</span>
                        <span class="s1">match = </span><span class="s3">False</span>
                        <span class="s3">break</span>
            <span class="s3">if </span><span class="s1">match:</span>
                <span class="s3">if </span><span class="s1">markup:</span>
                    <span class="s1">found = markup</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">found = markup_name</span>
        <span class="s3">if </span><span class="s1">found </span><span class="s3">and </span><span class="s1">self.text </span><span class="s3">and not </span><span class="s1">self._matches(found.string</span><span class="s3">, </span><span class="s1">self.text):</span>
            <span class="s1">found = </span><span class="s3">None</span>
        <span class="s3">return </span><span class="s1">found</span>

    <span class="s0"># For BS3 compatibility.</span>
    <span class="s1">searchTag = search_tag</span>

    <span class="s3">def </span><span class="s1">search(self</span><span class="s3">, </span><span class="s1">markup):</span>
        <span class="s5">&quot;&quot;&quot;Find all items in `markup` that match this SoupStrainer. 
 
        Used by the core _find_all() method, which is ultimately 
        called by all find_* methods. 
 
        :param markup: A PageElement or a list of them. 
        &quot;&quot;&quot;</span>
        <span class="s0"># print('looking for %s in %s' % (self, markup))</span>
        <span class="s1">found = </span><span class="s3">None</span>
        <span class="s0"># If given a list of items, scan it for a text element that</span>
        <span class="s0"># matches.</span>
        <span class="s3">if </span><span class="s1">hasattr(markup</span><span class="s3">, </span><span class="s2">'__iter__'</span><span class="s1">) </span><span class="s3">and not </span><span class="s1">isinstance(markup</span><span class="s3">, </span><span class="s1">(Tag</span><span class="s3">, </span><span class="s1">str)):</span>
            <span class="s3">for </span><span class="s1">element </span><span class="s3">in </span><span class="s1">markup:</span>
                <span class="s3">if </span><span class="s1">isinstance(element</span><span class="s3">, </span><span class="s1">NavigableString) \</span>
                       <span class="s3">and </span><span class="s1">self.search(element):</span>
                    <span class="s1">found = element</span>
                    <span class="s3">break</span>
        <span class="s0"># If it's a Tag, make sure its name or attributes match.</span>
        <span class="s0"># Don't bother with Tags if we're searching for text.</span>
        <span class="s3">elif </span><span class="s1">isinstance(markup</span><span class="s3">, </span><span class="s1">Tag):</span>
            <span class="s3">if not </span><span class="s1">self.text </span><span class="s3">or </span><span class="s1">self.name </span><span class="s3">or </span><span class="s1">self.attrs:</span>
                <span class="s1">found = self.search_tag(markup)</span>
        <span class="s0"># If it's text, make sure the text matches.</span>
        <span class="s3">elif </span><span class="s1">isinstance(markup</span><span class="s3">, </span><span class="s1">NavigableString) </span><span class="s3">or </span><span class="s1">\</span>
                 <span class="s1">isinstance(markup</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s3">if not </span><span class="s1">self.name </span><span class="s3">and not </span><span class="s1">self.attrs </span><span class="s3">and </span><span class="s1">self._matches(markup</span><span class="s3">, </span><span class="s1">self.text):</span>
                <span class="s1">found = markup</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">Exception(</span>
                <span class="s2">&quot;I don't know how to match against a %s&quot; </span><span class="s1">% markup.__class__)</span>
        <span class="s3">return </span><span class="s1">found</span>

    <span class="s3">def </span><span class="s1">_matches(self</span><span class="s3">, </span><span class="s1">markup</span><span class="s3">, </span><span class="s1">match_against</span><span class="s3">, </span><span class="s1">already_tried=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0"># print(u&quot;Matching %s against %s&quot; % (markup, match_against))</span>
        <span class="s1">result = </span><span class="s3">False</span>
        <span class="s3">if </span><span class="s1">isinstance(markup</span><span class="s3">, </span><span class="s1">list) </span><span class="s3">or </span><span class="s1">isinstance(markup</span><span class="s3">, </span><span class="s1">tuple):</span>
            <span class="s0"># This should only happen when searching a multi-valued attribute</span>
            <span class="s0"># like 'class'.</span>
            <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">markup:</span>
                <span class="s3">if </span><span class="s1">self._matches(item</span><span class="s3">, </span><span class="s1">match_against):</span>
                    <span class="s3">return True</span>
            <span class="s0"># We didn't match any particular value of the multivalue</span>
            <span class="s0"># attribute, but maybe we match the attribute value when</span>
            <span class="s0"># considered as a string.</span>
            <span class="s3">if </span><span class="s1">self._matches(</span><span class="s2">' '</span><span class="s1">.join(markup)</span><span class="s3">, </span><span class="s1">match_against):</span>
                <span class="s3">return True</span>
            <span class="s3">return False</span>
        
        <span class="s3">if </span><span class="s1">match_against </span><span class="s3">is True</span><span class="s1">:</span>
            <span class="s0"># True matches any non-None value.</span>
            <span class="s3">return </span><span class="s1">markup </span><span class="s3">is not None</span>

        <span class="s3">if </span><span class="s1">isinstance(match_against</span><span class="s3">, </span><span class="s1">Callable):</span>
            <span class="s3">return </span><span class="s1">match_against(markup)</span>

        <span class="s0"># Custom callables take the tag as an argument, but all</span>
        <span class="s0"># other ways of matching match the tag name as a string.</span>
        <span class="s1">original_markup = markup</span>
        <span class="s3">if </span><span class="s1">isinstance(markup</span><span class="s3">, </span><span class="s1">Tag):</span>
            <span class="s1">markup = markup.name</span>

        <span class="s0"># Ensure that `markup` is either a Unicode string, or None.</span>
        <span class="s1">markup = self._normalize_search_value(markup)</span>

        <span class="s3">if </span><span class="s1">markup </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s0"># None matches None, False, an empty string, an empty list, and so on.</span>
            <span class="s3">return not </span><span class="s1">match_against</span>

        <span class="s3">if </span><span class="s1">(hasattr(match_against</span><span class="s3">, </span><span class="s2">'__iter__'</span><span class="s1">)</span>
            <span class="s3">and not </span><span class="s1">isinstance(match_against</span><span class="s3">, </span><span class="s1">str)):</span>
            <span class="s0"># We're asked to match against an iterable of items.</span>
            <span class="s0"># The markup must be match at least one item in the</span>
            <span class="s0"># iterable. We'll try each one in turn.</span>
            <span class="s0">#</span>
            <span class="s0"># To avoid infinite recursion we need to keep track of</span>
            <span class="s0"># items we've already seen.</span>
            <span class="s3">if not </span><span class="s1">already_tried:</span>
                <span class="s1">already_tried = set()</span>
            <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">match_against:</span>
                <span class="s3">if </span><span class="s1">item.__hash__:</span>
                    <span class="s1">key = item</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">key = id(item)</span>
                <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">already_tried:</span>
                    <span class="s3">continue</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">already_tried.add(key)</span>
                    <span class="s3">if </span><span class="s1">self._matches(original_markup</span><span class="s3">, </span><span class="s1">item</span><span class="s3">, </span><span class="s1">already_tried):</span>
                        <span class="s3">return True</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return False</span>
        
        <span class="s0"># Beyond this point we might need to run the test twice: once against</span>
        <span class="s0"># the tag's name and once against its prefixed name.</span>
        <span class="s1">match = </span><span class="s3">False</span>
        
        <span class="s3">if not </span><span class="s1">match </span><span class="s3">and </span><span class="s1">isinstance(match_against</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s0"># Exact string match</span>
            <span class="s1">match = markup == match_against</span>

        <span class="s3">if not </span><span class="s1">match </span><span class="s3">and </span><span class="s1">hasattr(match_against</span><span class="s3">, </span><span class="s2">'search'</span><span class="s1">):</span>
            <span class="s0"># Regexp match</span>
            <span class="s3">return </span><span class="s1">match_against.search(markup)</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">not </span><span class="s1">match</span>
            <span class="s3">and </span><span class="s1">isinstance(original_markup</span><span class="s3">, </span><span class="s1">Tag)</span>
            <span class="s3">and </span><span class="s1">original_markup.prefix):</span>
            <span class="s0"># Try the whole thing again with the prefixed tag name.</span>
            <span class="s3">return </span><span class="s1">self._matches(</span>
                <span class="s1">original_markup.prefix + </span><span class="s2">':' </span><span class="s1">+ original_markup.name</span><span class="s3">, </span><span class="s1">match_against</span>
            <span class="s1">)</span>

        <span class="s3">return </span><span class="s1">match</span>


<span class="s3">class </span><span class="s1">ResultSet(list):</span>
    <span class="s5">&quot;&quot;&quot;A ResultSet is just a list that keeps track of the SoupStrainer 
    that created it.&quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">source</span><span class="s3">, </span><span class="s1">result=()):</span>
        <span class="s5">&quot;&quot;&quot;Constructor. 
 
        :param source: A SoupStrainer. 
        :param result: A list of PageElements. 
        &quot;&quot;&quot;</span>
        <span class="s1">super(ResultSet</span><span class="s3">, </span><span class="s1">self).__init__(result)</span>
        <span class="s1">self.source = source</span>

    <span class="s3">def </span><span class="s1">__getattr__(self</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s5">&quot;&quot;&quot;Raise a helpful exception to explain a common code fix.&quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">AttributeError(</span>
            <span class="s2">&quot;ResultSet object has no attribute '%s'. You're probably treating a list of elements like a single element. Did you call find_all() when you meant to call find()?&quot; </span><span class="s1">% key</span>
        <span class="s1">)</span>
</pre>
</body>
</html>