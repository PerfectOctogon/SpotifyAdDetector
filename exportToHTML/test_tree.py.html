<html>
<head>
<title>test_tree.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_tree.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s2">&quot;&quot;&quot;Tests for Beautiful Soup's tree traversal methods. 
 
The tree traversal methods are the main advantage of using Beautiful 
Soup over just using a parser. 
 
Different parsers will build different Beautiful Soup trees given the 
same markup, but all Beautiful Soup trees can be traversed with the 
methods tested here. 
&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">pdb </span><span class="s3">import </span><span class="s1">set_trace</span>
<span class="s3">import </span><span class="s1">copy</span>
<span class="s3">import </span><span class="s1">pickle</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">from </span><span class="s1">bs4 </span><span class="s3">import </span><span class="s1">BeautifulSoup</span>
<span class="s3">from </span><span class="s1">bs4.builder </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">builder_registry</span><span class="s3">,</span>
    <span class="s1">HTMLParserTreeBuilder</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">bs4.element </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">PY3K</span><span class="s3">,</span>
    <span class="s1">CData</span><span class="s3">,</span>
    <span class="s1">Comment</span><span class="s3">,</span>
    <span class="s1">Declaration</span><span class="s3">,</span>
    <span class="s1">Doctype</span><span class="s3">,</span>
    <span class="s1">Formatter</span><span class="s3">,</span>
    <span class="s1">NavigableString</span><span class="s3">,</span>
    <span class="s1">Script</span><span class="s3">,</span>
    <span class="s1">SoupStrainer</span><span class="s3">,</span>
    <span class="s1">Stylesheet</span><span class="s3">,</span>
    <span class="s1">Tag</span><span class="s3">,</span>
    <span class="s1">TemplateString</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">bs4.testing </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">SoupTest</span><span class="s3">,</span>
    <span class="s1">skipIf</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">soupsieve </span><span class="s3">import </span><span class="s1">SelectorSyntaxError</span>

<span class="s1">XML_BUILDER_PRESENT = (builder_registry.lookup(</span><span class="s4">&quot;xml&quot;</span><span class="s1">) </span><span class="s3">is not None</span><span class="s1">)</span>
<span class="s1">LXML_PRESENT = (builder_registry.lookup(</span><span class="s4">&quot;lxml&quot;</span><span class="s1">) </span><span class="s3">is not None</span><span class="s1">)</span>

<span class="s3">class </span><span class="s1">TreeTest(SoupTest):</span>

    <span class="s3">def </span><span class="s1">assertSelects(self</span><span class="s3">, </span><span class="s1">tags</span><span class="s3">, </span><span class="s1">should_match):</span>
        <span class="s2">&quot;&quot;&quot;Make sure that the given tags have the correct text. 
 
        This is used in tests that define a bunch of tags, each 
        containing a single string, and then select certain strings by 
        some mechanism. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.assertEqual([tag.string </span><span class="s3">for </span><span class="s1">tag </span><span class="s3">in </span><span class="s1">tags]</span><span class="s3">, </span><span class="s1">should_match)</span>

    <span class="s3">def </span><span class="s1">assertSelectsIDs(self</span><span class="s3">, </span><span class="s1">tags</span><span class="s3">, </span><span class="s1">should_match):</span>
        <span class="s2">&quot;&quot;&quot;Make sure that the given tags have the correct IDs. 
 
        This is used in tests that define a bunch of tags, each 
        containing a single string, and then select certain strings by 
        some mechanism. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.assertEqual([tag[</span><span class="s4">'id'</span><span class="s1">] </span><span class="s3">for </span><span class="s1">tag </span><span class="s3">in </span><span class="s1">tags]</span><span class="s3">, </span><span class="s1">should_match)</span>


<span class="s3">class </span><span class="s1">TestFind(TreeTest):</span>
    <span class="s2">&quot;&quot;&quot;Basic tests of the find() method. 
 
    find() just calls find_all() with limit=1, so it's not tested all 
    that thouroughly here. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">test_find_tag(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;1&lt;/a&gt;&lt;b&gt;2&lt;/b&gt;&lt;a&gt;3&lt;/a&gt;&lt;b&gt;4&lt;/b&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(soup.find(</span><span class="s4">&quot;b&quot;</span><span class="s1">).string</span><span class="s3">, </span><span class="s4">&quot;2&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_unicode_text_find(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">'&lt;h1&gt;Räksmörgås&lt;/h1&gt;'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(soup.find(string=</span><span class="s4">'Räksmörgås'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">'Räksmörgås'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_unicode_attribute_find(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">'&lt;h1 id=&quot;Räksmörgås&quot;&gt;here it is&lt;/h1&gt;'</span><span class="s1">)</span>
        <span class="s1">str(soup)</span>
        <span class="s1">self.assertEqual(</span><span class="s4">&quot;here it is&quot;</span><span class="s3">, </span><span class="s1">soup.find(id=</span><span class="s4">'Räksmörgås'</span><span class="s1">).text)</span>


    <span class="s3">def </span><span class="s1">test_find_everything(self):</span>
        <span class="s2">&quot;&quot;&quot;Test an optimization that finds all tags.&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;foo&lt;/a&gt;&lt;b&gt;bar&lt;/b&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span><span class="s5">2</span><span class="s3">, </span><span class="s1">len(soup.find_all()))</span>

    <span class="s3">def </span><span class="s1">test_find_everything_with_name(self):</span>
        <span class="s2">&quot;&quot;&quot;Test an optimization that finds all tags with a given name.&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;foo&lt;/a&gt;&lt;b&gt;bar&lt;/b&gt;&lt;a&gt;baz&lt;/a&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span><span class="s5">2</span><span class="s3">, </span><span class="s1">len(soup.find_all(</span><span class="s4">'a'</span><span class="s1">)))</span>

<span class="s3">class </span><span class="s1">TestFindAll(TreeTest):</span>
    <span class="s2">&quot;&quot;&quot;Basic tests of the find_all() method.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">test_find_all_text_nodes(self):</span>
        <span class="s2">&quot;&quot;&quot;You can search the tree for text nodes.&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;html&gt;Foo&lt;b&gt;bar&lt;/b&gt;</span><span class="s3">\xbb</span><span class="s4">&lt;/html&gt;&quot;</span><span class="s1">)</span>
        <span class="s0"># Exact match.</span>
        <span class="s1">self.assertEqual(soup.find_all(string=</span><span class="s4">&quot;bar&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;bar&quot;</span><span class="s1">])</span>
        <span class="s1">self.assertEqual(soup.find_all(text=</span><span class="s4">&quot;bar&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;bar&quot;</span><span class="s1">])</span>
        <span class="s0"># Match any of a number of strings.</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.find_all(text=[</span><span class="s4">&quot;Foo&quot;</span><span class="s3">, </span><span class="s4">&quot;bar&quot;</span><span class="s1">])</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;Foo&quot;</span><span class="s3">, </span><span class="s4">&quot;bar&quot;</span><span class="s1">])</span>
        <span class="s0"># Match a regular expression.</span>
        <span class="s1">self.assertEqual(soup.find_all(text=re.compile(</span><span class="s4">'.*'</span><span class="s1">))</span><span class="s3">,</span>
                         <span class="s1">[</span><span class="s4">&quot;Foo&quot;</span><span class="s3">, </span><span class="s4">&quot;bar&quot;</span><span class="s3">, </span><span class="s4">'</span><span class="s3">\xbb</span><span class="s4">'</span><span class="s1">])</span>
        <span class="s0"># Match anything.</span>
        <span class="s1">self.assertEqual(soup.find_all(text=</span><span class="s3">True</span><span class="s1">)</span><span class="s3">,</span>
                         <span class="s1">[</span><span class="s4">&quot;Foo&quot;</span><span class="s3">, </span><span class="s4">&quot;bar&quot;</span><span class="s3">, </span><span class="s4">'</span><span class="s3">\xbb</span><span class="s4">'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_find_all_limit(self):</span>
        <span class="s2">&quot;&quot;&quot;You can limit the number of items returned by find_all.&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;1&lt;/a&gt;&lt;a&gt;2&lt;/a&gt;&lt;a&gt;3&lt;/a&gt;&lt;a&gt;4&lt;/a&gt;&lt;a&gt;5&lt;/a&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertSelects(soup.find_all(</span><span class="s4">'a'</span><span class="s3">, </span><span class="s1">limit=</span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;1&quot;</span><span class="s3">, </span><span class="s4">&quot;2&quot;</span><span class="s3">, </span><span class="s4">&quot;3&quot;</span><span class="s1">])</span>
        <span class="s1">self.assertSelects(soup.find_all(</span><span class="s4">'a'</span><span class="s3">, </span><span class="s1">limit=</span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;1&quot;</span><span class="s1">])</span>
        <span class="s1">self.assertSelects(</span>
            <span class="s1">soup.find_all(</span><span class="s4">'a'</span><span class="s3">, </span><span class="s1">limit=</span><span class="s5">10</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;1&quot;</span><span class="s3">, </span><span class="s4">&quot;2&quot;</span><span class="s3">, </span><span class="s4">&quot;3&quot;</span><span class="s3">, </span><span class="s4">&quot;4&quot;</span><span class="s3">, </span><span class="s4">&quot;5&quot;</span><span class="s1">])</span>

        <span class="s0"># A limit of 0 means no limit.</span>
        <span class="s1">self.assertSelects(</span>
            <span class="s1">soup.find_all(</span><span class="s4">'a'</span><span class="s3">, </span><span class="s1">limit=</span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;1&quot;</span><span class="s3">, </span><span class="s4">&quot;2&quot;</span><span class="s3">, </span><span class="s4">&quot;3&quot;</span><span class="s3">, </span><span class="s4">&quot;4&quot;</span><span class="s3">, </span><span class="s4">&quot;5&quot;</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_calling_a_tag_is_calling_findall(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;1&lt;/a&gt;&lt;b&gt;2&lt;a id='foo'&gt;3&lt;/a&gt;&lt;/b&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertSelects(soup(</span><span class="s4">'a'</span><span class="s3">, </span><span class="s1">limit=</span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;1&quot;</span><span class="s1">])</span>
        <span class="s1">self.assertSelects(soup.b(id=</span><span class="s4">&quot;foo&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;3&quot;</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_find_all_with_self_referential_data_structure_does_not_cause_infinite_recursion(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;&lt;/a&gt;&quot;</span><span class="s1">)</span>
        <span class="s0"># Create a self-referential list.</span>
        <span class="s1">l = []</span>
        <span class="s1">l.append(l)</span>

        <span class="s0"># Without special code in _normalize_search_value, this would cause infinite</span>
        <span class="s0"># recursion.</span>
        <span class="s1">self.assertEqual([]</span><span class="s3">, </span><span class="s1">soup.find_all(l))</span>

    <span class="s3">def </span><span class="s1">test_find_all_resultset(self):</span>
        <span class="s2">&quot;&quot;&quot;All find_all calls return a ResultSet&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;&lt;/a&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">result = soup.find_all(</span><span class="s4">&quot;a&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(hasattr(result</span><span class="s3">, </span><span class="s4">&quot;source&quot;</span><span class="s1">))</span>

        <span class="s1">result = soup.find_all(</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(hasattr(result</span><span class="s3">, </span><span class="s4">&quot;source&quot;</span><span class="s1">))</span>

        <span class="s1">result = soup.find_all(text=</span><span class="s4">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(hasattr(result</span><span class="s3">, </span><span class="s4">&quot;source&quot;</span><span class="s1">))</span>


<span class="s3">class </span><span class="s1">TestFindAllBasicNamespaces(TreeTest):</span>

    <span class="s3">def </span><span class="s1">test_find_by_namespaced_name(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">'&lt;mathml:msqrt&gt;4&lt;/mathml:msqrt&gt;&lt;a svg:fill=&quot;red&quot;&gt;'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span><span class="s4">&quot;4&quot;</span><span class="s3">, </span><span class="s1">soup.find(</span><span class="s4">&quot;mathml:msqrt&quot;</span><span class="s1">).string)</span>
        <span class="s1">self.assertEqual(</span><span class="s4">&quot;a&quot;</span><span class="s3">, </span><span class="s1">soup.find(attrs= { </span><span class="s4">&quot;svg:fill&quot; </span><span class="s1">: </span><span class="s4">&quot;red&quot; </span><span class="s1">}).name)</span>


<span class="s3">class </span><span class="s1">TestFindAllByName(TreeTest):</span>
    <span class="s2">&quot;&quot;&quot;Test ways of finding tags by tag name.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">setUp(self):</span>
        <span class="s1">super(TreeTest</span><span class="s3">, </span><span class="s1">self).setUp()</span>
        <span class="s1">self.tree =  self.soup(</span><span class="s4">&quot;&quot;&quot;&lt;a&gt;First tag.&lt;/a&gt; 
                                  &lt;b&gt;Second tag.&lt;/b&gt; 
                                  &lt;c&gt;Third &lt;a&gt;Nested tag.&lt;/a&gt; tag.&lt;/c&gt;&quot;&quot;&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_find_all_by_tag_name(self):</span>
        <span class="s0"># Find all the &lt;a&gt; tags.</span>
        <span class="s1">self.assertSelects(</span>
            <span class="s1">self.tree.find_all(</span><span class="s4">'a'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'First tag.'</span><span class="s3">, </span><span class="s4">'Nested tag.'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_find_all_by_name_and_text(self):</span>
        <span class="s1">self.assertSelects(</span>
            <span class="s1">self.tree.find_all(</span><span class="s4">'a'</span><span class="s3">, </span><span class="s1">text=</span><span class="s4">'First tag.'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'First tag.'</span><span class="s1">])</span>

        <span class="s1">self.assertSelects(</span>
            <span class="s1">self.tree.find_all(</span><span class="s4">'a'</span><span class="s3">, </span><span class="s1">text=</span><span class="s3">True</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'First tag.'</span><span class="s3">, </span><span class="s4">'Nested tag.'</span><span class="s1">])</span>

        <span class="s1">self.assertSelects(</span>
            <span class="s1">self.tree.find_all(</span><span class="s4">'a'</span><span class="s3">, </span><span class="s1">text=re.compile(</span><span class="s4">&quot;tag&quot;</span><span class="s1">))</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">'First tag.'</span><span class="s3">, </span><span class="s4">'Nested tag.'</span><span class="s1">])</span>


    <span class="s3">def </span><span class="s1">test_find_all_on_non_root_element(self):</span>
        <span class="s0"># You can call find_all on any node, not just the root.</span>
        <span class="s1">self.assertSelects(self.tree.c.find_all(</span><span class="s4">'a'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'Nested tag.'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_calling_element_invokes_find_all(self):</span>
        <span class="s1">self.assertSelects(self.tree(</span><span class="s4">'a'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'First tag.'</span><span class="s3">, </span><span class="s4">'Nested tag.'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_find_all_by_tag_strainer(self):</span>
        <span class="s1">self.assertSelects(</span>
            <span class="s1">self.tree.find_all(SoupStrainer(</span><span class="s4">'a'</span><span class="s1">))</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">'First tag.'</span><span class="s3">, </span><span class="s4">'Nested tag.'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_find_all_by_tag_names(self):</span>
        <span class="s1">self.assertSelects(</span>
            <span class="s1">self.tree.find_all([</span><span class="s4">'a'</span><span class="s3">, </span><span class="s4">'b'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">'First tag.'</span><span class="s3">, </span><span class="s4">'Second tag.'</span><span class="s3">, </span><span class="s4">'Nested tag.'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_find_all_by_tag_dict(self):</span>
        <span class="s1">self.assertSelects(</span>
            <span class="s1">self.tree.find_all({</span><span class="s4">'a' </span><span class="s1">: </span><span class="s3">True, </span><span class="s4">'b' </span><span class="s1">: </span><span class="s3">True</span><span class="s1">})</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">'First tag.'</span><span class="s3">, </span><span class="s4">'Second tag.'</span><span class="s3">, </span><span class="s4">'Nested tag.'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_find_all_by_tag_re(self):</span>
        <span class="s1">self.assertSelects(</span>
            <span class="s1">self.tree.find_all(re.compile(</span><span class="s4">'^[ab]$'</span><span class="s1">))</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s4">'First tag.'</span><span class="s3">, </span><span class="s4">'Second tag.'</span><span class="s3">, </span><span class="s4">'Nested tag.'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_find_all_with_tags_matching_method(self):</span>
        <span class="s0"># You can define an oracle method that determines whether</span>
        <span class="s0"># a tag matches the search.</span>
        <span class="s3">def </span><span class="s1">id_matches_name(tag):</span>
            <span class="s3">return </span><span class="s1">tag.name == tag.get(</span><span class="s4">'id'</span><span class="s1">)</span>

        <span class="s1">tree = self.soup(</span><span class="s4">&quot;&quot;&quot;&lt;a id=&quot;a&quot;&gt;Match 1.&lt;/a&gt; 
                            &lt;a id=&quot;1&quot;&gt;Does not match.&lt;/a&gt; 
                            &lt;b id=&quot;b&quot;&gt;Match 2.&lt;/a&gt;&quot;&quot;&quot;</span><span class="s1">)</span>

        <span class="s1">self.assertSelects(</span>
            <span class="s1">tree.find_all(id_matches_name)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;Match 1.&quot;</span><span class="s3">, </span><span class="s4">&quot;Match 2.&quot;</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_find_with_multi_valued_attribute(self):</span>
        <span class="s1">soup = self.soup(</span>
            <span class="s4">&quot;&lt;div class='a b'&gt;1&lt;/div&gt;&lt;div class='a c'&gt;2&lt;/div&gt;&lt;div class='a d'&gt;3&lt;/div&gt;&quot;</span>
        <span class="s1">)</span>
        <span class="s1">r1 = soup.find(</span><span class="s4">'div'</span><span class="s3">, </span><span class="s4">'a d'</span><span class="s1">);</span>
        <span class="s1">r2 = soup.find(</span><span class="s4">'div'</span><span class="s3">, </span><span class="s1">re.compile(</span><span class="s4">r'a d'</span><span class="s1">));</span>
        <span class="s1">r3</span><span class="s3">, </span><span class="s1">r4 = soup.find_all(</span><span class="s4">'div'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'a b'</span><span class="s3">, </span><span class="s4">'a d'</span><span class="s1">]);</span>
        <span class="s1">self.assertEqual(</span><span class="s4">'3'</span><span class="s3">, </span><span class="s1">r1.string)</span>
        <span class="s1">self.assertEqual(</span><span class="s4">'3'</span><span class="s3">, </span><span class="s1">r2.string)</span>
        <span class="s1">self.assertEqual(</span><span class="s4">'1'</span><span class="s3">, </span><span class="s1">r3.string)</span>
        <span class="s1">self.assertEqual(</span><span class="s4">'3'</span><span class="s3">, </span><span class="s1">r4.string)</span>

        
<span class="s3">class </span><span class="s1">TestFindAllByAttribute(TreeTest):</span>

    <span class="s3">def </span><span class="s1">test_find_all_by_attribute_name(self):</span>
        <span class="s0"># You can pass in keyword arguments to find_all to search by</span>
        <span class="s0"># attribute.</span>
        <span class="s1">tree = self.soup(</span><span class="s4">&quot;&quot;&quot; 
                         &lt;a id=&quot;first&quot;&gt;Matching a.&lt;/a&gt; 
                         &lt;a id=&quot;second&quot;&gt; 
                          Non-matching &lt;b id=&quot;first&quot;&gt;Matching b.&lt;/b&gt;a. 
                         &lt;/a&gt;&quot;&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertSelects(tree.find_all(id=</span><span class="s4">'first'</span><span class="s1">)</span><span class="s3">,</span>
                           <span class="s1">[</span><span class="s4">&quot;Matching a.&quot;</span><span class="s3">, </span><span class="s4">&quot;Matching b.&quot;</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_find_all_by_utf8_attribute_value(self):</span>
        <span class="s1">peace = </span><span class="s4">&quot;םולש&quot;</span><span class="s1">.encode(</span><span class="s4">&quot;utf8&quot;</span><span class="s1">)</span>
        <span class="s1">data = </span><span class="s4">'&lt;a title=&quot;םולש&quot;&gt;&lt;/a&gt;'</span><span class="s1">.encode(</span><span class="s4">&quot;utf8&quot;</span><span class="s1">)</span>
        <span class="s1">soup = self.soup(data)</span>
        <span class="s1">self.assertEqual([soup.a]</span><span class="s3">, </span><span class="s1">soup.find_all(title=peace))</span>
        <span class="s1">self.assertEqual([soup.a]</span><span class="s3">, </span><span class="s1">soup.find_all(title=peace.decode(</span><span class="s4">&quot;utf8&quot;</span><span class="s1">)))</span>
        <span class="s1">self.assertEqual([soup.a]</span><span class="s3">, </span><span class="s1">soup.find_all(title=[peace</span><span class="s3">, </span><span class="s4">&quot;something else&quot;</span><span class="s1">]))</span>

    <span class="s3">def </span><span class="s1">test_find_all_by_attribute_dict(self):</span>
        <span class="s0"># You can pass in a dictionary as the argument 'attrs'. This</span>
        <span class="s0"># lets you search for attributes like 'name' (a fixed argument</span>
        <span class="s0"># to find_all) and 'class' (a reserved word in Python.)</span>
        <span class="s1">tree = self.soup(</span><span class="s4">&quot;&quot;&quot; 
                         &lt;a name=&quot;name1&quot; class=&quot;class1&quot;&gt;Name match.&lt;/a&gt; 
                         &lt;a name=&quot;name2&quot; class=&quot;class2&quot;&gt;Class match.&lt;/a&gt; 
                         &lt;a name=&quot;name3&quot; class=&quot;class3&quot;&gt;Non-match.&lt;/a&gt; 
                         &lt;name1&gt;A tag called 'name1'.&lt;/name1&gt; 
                         &quot;&quot;&quot;</span><span class="s1">)</span>

        <span class="s0"># This doesn't do what you want.</span>
        <span class="s1">self.assertSelects(tree.find_all(name=</span><span class="s4">'name1'</span><span class="s1">)</span><span class="s3">,</span>
                           <span class="s1">[</span><span class="s4">&quot;A tag called 'name1'.&quot;</span><span class="s1">])</span>
        <span class="s0"># This does what you want.</span>
        <span class="s1">self.assertSelects(tree.find_all(attrs={</span><span class="s4">'name' </span><span class="s1">: </span><span class="s4">'name1'</span><span class="s1">})</span><span class="s3">,</span>
                           <span class="s1">[</span><span class="s4">&quot;Name match.&quot;</span><span class="s1">])</span>

        <span class="s1">self.assertSelects(tree.find_all(attrs={</span><span class="s4">'class' </span><span class="s1">: </span><span class="s4">'class2'</span><span class="s1">})</span><span class="s3">,</span>
                           <span class="s1">[</span><span class="s4">&quot;Class match.&quot;</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_find_all_by_class(self):</span>
        <span class="s1">tree = self.soup(</span><span class="s4">&quot;&quot;&quot; 
                         &lt;a class=&quot;1&quot;&gt;Class 1.&lt;/a&gt; 
                         &lt;a class=&quot;2&quot;&gt;Class 2.&lt;/a&gt; 
                         &lt;b class=&quot;1&quot;&gt;Class 1.&lt;/b&gt; 
                         &lt;c class=&quot;3 4&quot;&gt;Class 3 and 4.&lt;/c&gt; 
                         &quot;&quot;&quot;</span><span class="s1">)</span>

        <span class="s0"># Passing in the class_ keyword argument will search against</span>
        <span class="s0"># the 'class' attribute.</span>
        <span class="s1">self.assertSelects(tree.find_all(</span><span class="s4">'a'</span><span class="s3">, </span><span class="s1">class_=</span><span class="s4">'1'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'Class 1.'</span><span class="s1">])</span>
        <span class="s1">self.assertSelects(tree.find_all(</span><span class="s4">'c'</span><span class="s3">, </span><span class="s1">class_=</span><span class="s4">'3'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'Class 3 and 4.'</span><span class="s1">])</span>
        <span class="s1">self.assertSelects(tree.find_all(</span><span class="s4">'c'</span><span class="s3">, </span><span class="s1">class_=</span><span class="s4">'4'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'Class 3 and 4.'</span><span class="s1">])</span>

        <span class="s0"># Passing in a string to 'attrs' will also search the CSS class.</span>
        <span class="s1">self.assertSelects(tree.find_all(</span><span class="s4">'a'</span><span class="s3">, </span><span class="s4">'1'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'Class 1.'</span><span class="s1">])</span>
        <span class="s1">self.assertSelects(tree.find_all(attrs=</span><span class="s4">'1'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'Class 1.'</span><span class="s3">, </span><span class="s4">'Class 1.'</span><span class="s1">])</span>
        <span class="s1">self.assertSelects(tree.find_all(</span><span class="s4">'c'</span><span class="s3">, </span><span class="s4">'3'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'Class 3 and 4.'</span><span class="s1">])</span>
        <span class="s1">self.assertSelects(tree.find_all(</span><span class="s4">'c'</span><span class="s3">, </span><span class="s4">'4'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'Class 3 and 4.'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_find_by_class_when_multiple_classes_present(self):</span>
        <span class="s1">tree = self.soup(</span><span class="s4">&quot;&lt;gar class='foo bar'&gt;Found it&lt;/gar&gt;&quot;</span><span class="s1">)</span>

        <span class="s1">f = tree.find_all(</span><span class="s4">&quot;gar&quot;</span><span class="s3">, </span><span class="s1">class_=re.compile(</span><span class="s4">&quot;o&quot;</span><span class="s1">))</span>
        <span class="s1">self.assertSelects(f</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;Found it&quot;</span><span class="s1">])</span>

        <span class="s1">f = tree.find_all(</span><span class="s4">&quot;gar&quot;</span><span class="s3">, </span><span class="s1">class_=re.compile(</span><span class="s4">&quot;a&quot;</span><span class="s1">))</span>
        <span class="s1">self.assertSelects(f</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;Found it&quot;</span><span class="s1">])</span>

        <span class="s0"># If the search fails to match the individual strings &quot;foo&quot; and &quot;bar&quot;,</span>
        <span class="s0"># it will be tried against the combined string &quot;foo bar&quot;.</span>
        <span class="s1">f = tree.find_all(</span><span class="s4">&quot;gar&quot;</span><span class="s3">, </span><span class="s1">class_=re.compile(</span><span class="s4">&quot;o b&quot;</span><span class="s1">))</span>
        <span class="s1">self.assertSelects(f</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;Found it&quot;</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_find_all_with_non_dictionary_for_attrs_finds_by_class(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a class='bar'&gt;Found it&lt;/a&gt;&quot;</span><span class="s1">)</span>

        <span class="s1">self.assertSelects(soup.find_all(</span><span class="s4">&quot;a&quot;</span><span class="s3">, </span><span class="s1">re.compile(</span><span class="s4">&quot;ba&quot;</span><span class="s1">))</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;Found it&quot;</span><span class="s1">])</span>

        <span class="s3">def </span><span class="s1">big_attribute_value(value):</span>
            <span class="s3">return </span><span class="s1">len(value) &gt; </span><span class="s5">3</span>

        <span class="s1">self.assertSelects(soup.find_all(</span><span class="s4">&quot;a&quot;</span><span class="s3">, </span><span class="s1">big_attribute_value)</span><span class="s3">, </span><span class="s1">[])</span>

        <span class="s3">def </span><span class="s1">small_attribute_value(value):</span>
            <span class="s3">return </span><span class="s1">len(value) &lt;= </span><span class="s5">3</span>

        <span class="s1">self.assertSelects(</span>
            <span class="s1">soup.find_all(</span><span class="s4">&quot;a&quot;</span><span class="s3">, </span><span class="s1">small_attribute_value)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;Found it&quot;</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_find_all_with_string_for_attrs_finds_multiple_classes(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">'&lt;a class=&quot;foo bar&quot;&gt;&lt;/a&gt;&lt;a class=&quot;foo&quot;&gt;&lt;/a&gt;'</span><span class="s1">)</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">a2 = soup.find_all(</span><span class="s4">&quot;a&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual([a</span><span class="s3">, </span><span class="s1">a2]</span><span class="s3">, </span><span class="s1">soup.find_all(</span><span class="s4">&quot;a&quot;</span><span class="s3">, </span><span class="s4">&quot;foo&quot;</span><span class="s1">))</span>
        <span class="s1">self.assertEqual([a]</span><span class="s3">, </span><span class="s1">soup.find_all(</span><span class="s4">&quot;a&quot;</span><span class="s3">, </span><span class="s4">&quot;bar&quot;</span><span class="s1">))</span>

        <span class="s0"># If you specify the class as a string that contains a</span>
        <span class="s0"># space, only that specific value will be found.</span>
        <span class="s1">self.assertEqual([a]</span><span class="s3">, </span><span class="s1">soup.find_all(</span><span class="s4">&quot;a&quot;</span><span class="s3">, </span><span class="s1">class_=</span><span class="s4">&quot;foo bar&quot;</span><span class="s1">))</span>
        <span class="s1">self.assertEqual([a]</span><span class="s3">, </span><span class="s1">soup.find_all(</span><span class="s4">&quot;a&quot;</span><span class="s3">, </span><span class="s4">&quot;foo bar&quot;</span><span class="s1">))</span>
        <span class="s1">self.assertEqual([]</span><span class="s3">, </span><span class="s1">soup.find_all(</span><span class="s4">&quot;a&quot;</span><span class="s3">, </span><span class="s4">&quot;bar foo&quot;</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_find_all_by_attribute_soupstrainer(self):</span>
        <span class="s1">tree = self.soup(</span><span class="s4">&quot;&quot;&quot; 
                         &lt;a id=&quot;first&quot;&gt;Match.&lt;/a&gt; 
                         &lt;a id=&quot;second&quot;&gt;Non-match.&lt;/a&gt;&quot;&quot;&quot;</span><span class="s1">)</span>

        <span class="s1">strainer = SoupStrainer(attrs={</span><span class="s4">'id' </span><span class="s1">: </span><span class="s4">'first'</span><span class="s1">})</span>
        <span class="s1">self.assertSelects(tree.find_all(strainer)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'Match.'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_find_all_with_missing_attribute(self):</span>
        <span class="s0"># You can pass in None as the value of an attribute to find_all.</span>
        <span class="s0"># This will match tags that do not have that attribute set.</span>
        <span class="s1">tree = self.soup(</span><span class="s4">&quot;&quot;&quot;&lt;a id=&quot;1&quot;&gt;ID present.&lt;/a&gt; 
                            &lt;a&gt;No ID present.&lt;/a&gt; 
                            &lt;a id=&quot;&quot;&gt;ID is empty.&lt;/a&gt;&quot;&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertSelects(tree.find_all(</span><span class="s4">'a'</span><span class="s3">, </span><span class="s1">id=</span><span class="s3">None</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;No ID present.&quot;</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_find_all_with_defined_attribute(self):</span>
        <span class="s0"># You can pass in None as the value of an attribute to find_all.</span>
        <span class="s0"># This will match tags that have that attribute set to any value.</span>
        <span class="s1">tree = self.soup(</span><span class="s4">&quot;&quot;&quot;&lt;a id=&quot;1&quot;&gt;ID present.&lt;/a&gt; 
                            &lt;a&gt;No ID present.&lt;/a&gt; 
                            &lt;a id=&quot;&quot;&gt;ID is empty.&lt;/a&gt;&quot;&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertSelects(</span>
            <span class="s1">tree.find_all(id=</span><span class="s3">True</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;ID present.&quot;</span><span class="s3">, </span><span class="s4">&quot;ID is empty.&quot;</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_find_all_with_numeric_attribute(self):</span>
        <span class="s0"># If you search for a number, it's treated as a string.</span>
        <span class="s1">tree = self.soup(</span><span class="s4">&quot;&quot;&quot;&lt;a id=1&gt;Unquoted attribute.&lt;/a&gt; 
                            &lt;a id=&quot;1&quot;&gt;Quoted attribute.&lt;/a&gt;&quot;&quot;&quot;</span><span class="s1">)</span>

        <span class="s1">expected = [</span><span class="s4">&quot;Unquoted attribute.&quot;</span><span class="s3">, </span><span class="s4">&quot;Quoted attribute.&quot;</span><span class="s1">]</span>
        <span class="s1">self.assertSelects(tree.find_all(id=</span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">expected)</span>
        <span class="s1">self.assertSelects(tree.find_all(id=</span><span class="s4">&quot;1&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">expected)</span>

    <span class="s3">def </span><span class="s1">test_find_all_with_list_attribute_values(self):</span>
        <span class="s0"># You can pass a list of attribute values instead of just one,</span>
        <span class="s0"># and you'll get tags that match any of the values.</span>
        <span class="s1">tree = self.soup(</span><span class="s4">&quot;&quot;&quot;&lt;a id=&quot;1&quot;&gt;1&lt;/a&gt; 
                            &lt;a id=&quot;2&quot;&gt;2&lt;/a&gt; 
                            &lt;a id=&quot;3&quot;&gt;3&lt;/a&gt; 
                            &lt;a&gt;No ID.&lt;/a&gt;&quot;&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertSelects(tree.find_all(id=[</span><span class="s4">&quot;1&quot;</span><span class="s3">, </span><span class="s4">&quot;3&quot;</span><span class="s3">, </span><span class="s4">&quot;4&quot;</span><span class="s1">])</span><span class="s3">,</span>
                           <span class="s1">[</span><span class="s4">&quot;1&quot;</span><span class="s3">, </span><span class="s4">&quot;3&quot;</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_find_all_with_regular_expression_attribute_value(self):</span>
        <span class="s0"># You can pass a regular expression as an attribute value, and</span>
        <span class="s0"># you'll get tags whose values for that attribute match the</span>
        <span class="s0"># regular expression.</span>
        <span class="s1">tree = self.soup(</span><span class="s4">&quot;&quot;&quot;&lt;a id=&quot;a&quot;&gt;One a.&lt;/a&gt; 
                            &lt;a id=&quot;aa&quot;&gt;Two as.&lt;/a&gt; 
                            &lt;a id=&quot;ab&quot;&gt;Mixed as and bs.&lt;/a&gt; 
                            &lt;a id=&quot;b&quot;&gt;One b.&lt;/a&gt; 
                            &lt;a&gt;No ID.&lt;/a&gt;&quot;&quot;&quot;</span><span class="s1">)</span>

        <span class="s1">self.assertSelects(tree.find_all(id=re.compile(</span><span class="s4">&quot;^a+$&quot;</span><span class="s1">))</span><span class="s3">,</span>
                           <span class="s1">[</span><span class="s4">&quot;One a.&quot;</span><span class="s3">, </span><span class="s4">&quot;Two as.&quot;</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_find_by_name_and_containing_string(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;b&gt;foo&lt;/b&gt;&lt;b&gt;bar&lt;/b&gt;&lt;a&gt;foo&lt;/a&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">a = soup.a</span>

        <span class="s1">self.assertEqual([a]</span><span class="s3">, </span><span class="s1">soup.find_all(</span><span class="s4">&quot;a&quot;</span><span class="s3">, </span><span class="s1">text=</span><span class="s4">&quot;foo&quot;</span><span class="s1">))</span>
        <span class="s1">self.assertEqual([]</span><span class="s3">, </span><span class="s1">soup.find_all(</span><span class="s4">&quot;a&quot;</span><span class="s3">, </span><span class="s1">text=</span><span class="s4">&quot;bar&quot;</span><span class="s1">))</span>
        <span class="s1">self.assertEqual([]</span><span class="s3">, </span><span class="s1">soup.find_all(</span><span class="s4">&quot;a&quot;</span><span class="s3">, </span><span class="s1">text=</span><span class="s4">&quot;bar&quot;</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_find_by_name_and_containing_string_when_string_is_buried(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;foo&lt;/a&gt;&lt;a&gt;&lt;b&gt;&lt;c&gt;foo&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(soup.find_all(</span><span class="s4">&quot;a&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">soup.find_all(</span><span class="s4">&quot;a&quot;</span><span class="s3">, </span><span class="s1">text=</span><span class="s4">&quot;foo&quot;</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_find_by_attribute_and_containing_string(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">'&lt;b id=&quot;1&quot;&gt;foo&lt;/b&gt;&lt;a id=&quot;2&quot;&gt;foo&lt;/a&gt;'</span><span class="s1">)</span>
        <span class="s1">a = soup.a</span>

        <span class="s1">self.assertEqual([a]</span><span class="s3">, </span><span class="s1">soup.find_all(id=</span><span class="s5">2</span><span class="s3">, </span><span class="s1">text=</span><span class="s4">&quot;foo&quot;</span><span class="s1">))</span>
        <span class="s1">self.assertEqual([]</span><span class="s3">, </span><span class="s1">soup.find_all(id=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">text=</span><span class="s4">&quot;bar&quot;</span><span class="s1">))</span>


<span class="s3">class </span><span class="s1">TestSmooth(TreeTest):</span>
    <span class="s2">&quot;&quot;&quot;Test Tag.smooth.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">test_smooth(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;div&gt;a&lt;/div&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">div = soup.div</span>
        <span class="s1">div.append(</span><span class="s4">&quot;b&quot;</span><span class="s1">)</span>
        <span class="s1">div.append(</span><span class="s4">&quot;c&quot;</span><span class="s1">)</span>
        <span class="s1">div.append(Comment(</span><span class="s4">&quot;Comment 1&quot;</span><span class="s1">))</span>
        <span class="s1">div.append(Comment(</span><span class="s4">&quot;Comment 2&quot;</span><span class="s1">))</span>
        <span class="s1">div.append(</span><span class="s4">&quot;d&quot;</span><span class="s1">)</span>
        <span class="s1">builder = self.default_builder()</span>
        <span class="s1">span = Tag(soup</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s4">'span'</span><span class="s1">)</span>
        <span class="s1">span.append(</span><span class="s4">'1'</span><span class="s1">)</span>
        <span class="s1">span.append(</span><span class="s4">'2'</span><span class="s1">)</span>
        <span class="s1">div.append(span)</span>

        <span class="s0"># At this point the tree has a bunch of adjacent</span>
        <span class="s0"># NavigableStrings. This is normal, but it has no meaning in</span>
        <span class="s0"># terms of HTML, so we may want to smooth things out for</span>
        <span class="s0"># output.</span>

        <span class="s0"># Since the &lt;span&gt; tag has two children, its .string is None.</span>
        <span class="s1">self.assertEqual(</span><span class="s3">None, </span><span class="s1">div.span.string)</span>

        <span class="s1">self.assertEqual(</span><span class="s5">7</span><span class="s3">, </span><span class="s1">len(div.contents))</span>
        <span class="s1">div.smooth()</span>
        <span class="s1">self.assertEqual(</span><span class="s5">5</span><span class="s3">, </span><span class="s1">len(div.contents))</span>

        <span class="s0"># The three strings at the beginning of div.contents have been</span>
        <span class="s0"># merged into on string.</span>
        <span class="s0">#</span>
        <span class="s1">self.assertEqual(</span><span class="s4">'abc'</span><span class="s3">, </span><span class="s1">div.contents[</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s0"># The call is recursive -- the &lt;span&gt; tag was also smoothed.</span>
        <span class="s1">self.assertEqual(</span><span class="s4">'12'</span><span class="s3">, </span><span class="s1">div.span.string)</span>

        <span class="s0"># The two comments have _not_ been merged, even though</span>
        <span class="s0"># comments are strings. Merging comments would change the</span>
        <span class="s0"># meaning of the HTML.</span>
        <span class="s1">self.assertEqual(</span><span class="s4">'Comment 1'</span><span class="s3">, </span><span class="s1">div.contents[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">self.assertEqual(</span><span class="s4">'Comment 2'</span><span class="s3">, </span><span class="s1">div.contents[</span><span class="s5">2</span><span class="s1">])</span>


<span class="s3">class </span><span class="s1">TestIndex(TreeTest):</span>
    <span class="s2">&quot;&quot;&quot;Test Tag.index&quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">test_index(self):</span>
        <span class="s1">tree = self.soup(</span><span class="s4">&quot;&quot;&quot;&lt;div&gt; 
                            &lt;a&gt;Identical&lt;/a&gt; 
                            &lt;b&gt;Not identical&lt;/b&gt; 
                            &lt;a&gt;Identical&lt;/a&gt; 
 
                            &lt;c&gt;&lt;d&gt;Identical with child&lt;/d&gt;&lt;/c&gt; 
                            &lt;b&gt;Also not identical&lt;/b&gt; 
                            &lt;c&gt;&lt;d&gt;Identical with child&lt;/d&gt;&lt;/c&gt; 
                            &lt;/div&gt;&quot;&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">div = tree.div</span>
        <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">element </span><span class="s3">in </span><span class="s1">enumerate(div.contents):</span>
            <span class="s1">self.assertEqual(i</span><span class="s3">, </span><span class="s1">div.index(element))</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s3">, </span><span class="s1">tree.index</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">TestParentOperations(TreeTest):</span>
    <span class="s2">&quot;&quot;&quot;Test navigation and searching through an element's parents.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">setUp(self):</span>
        <span class="s1">super(TestParentOperations</span><span class="s3">, </span><span class="s1">self).setUp()</span>
        <span class="s1">self.tree = self.soup(</span><span class="s4">'''&lt;ul id=&quot;empty&quot;&gt;&lt;/ul&gt; 
                                 &lt;ul id=&quot;top&quot;&gt; 
                                  &lt;ul id=&quot;middle&quot;&gt; 
                                   &lt;ul id=&quot;bottom&quot;&gt; 
                                    &lt;b&gt;Start here&lt;/b&gt; 
                                   &lt;/ul&gt; 
                                  &lt;/ul&gt;'''</span><span class="s1">)</span>
        <span class="s1">self.start = self.tree.b</span>


    <span class="s3">def </span><span class="s1">test_parent(self):</span>
        <span class="s1">self.assertEqual(self.start.parent[</span><span class="s4">'id'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'bottom'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(self.start.parent.parent[</span><span class="s4">'id'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'middle'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(self.start.parent.parent.parent[</span><span class="s4">'id'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'top'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_parent_of_top_tag_is_soup_object(self):</span>
        <span class="s1">top_tag = self.tree.contents[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">self.assertEqual(top_tag.parent</span><span class="s3">, </span><span class="s1">self.tree)</span>

    <span class="s3">def </span><span class="s1">test_soup_object_has_no_parent(self):</span>
        <span class="s1">self.assertEqual(</span><span class="s3">None, </span><span class="s1">self.tree.parent)</span>

    <span class="s3">def </span><span class="s1">test_find_parents(self):</span>
        <span class="s1">self.assertSelectsIDs(</span>
            <span class="s1">self.start.find_parents(</span><span class="s4">'ul'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'bottom'</span><span class="s3">, </span><span class="s4">'middle'</span><span class="s3">, </span><span class="s4">'top'</span><span class="s1">])</span>
        <span class="s1">self.assertSelectsIDs(</span>
            <span class="s1">self.start.find_parents(</span><span class="s4">'ul'</span><span class="s3">, </span><span class="s1">id=</span><span class="s4">&quot;middle&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'middle'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_find_parent(self):</span>
        <span class="s1">self.assertEqual(self.start.find_parent(</span><span class="s4">'ul'</span><span class="s1">)[</span><span class="s4">'id'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'bottom'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(self.start.find_parent(</span><span class="s4">'ul'</span><span class="s3">, </span><span class="s1">id=</span><span class="s4">'top'</span><span class="s1">)[</span><span class="s4">'id'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'top'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_parent_of_text_element(self):</span>
        <span class="s1">text = self.tree.find(text=</span><span class="s4">&quot;Start here&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(text.parent.name</span><span class="s3">, </span><span class="s4">'b'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_text_element_find_parent(self):</span>
        <span class="s1">text = self.tree.find(text=</span><span class="s4">&quot;Start here&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(text.find_parent(</span><span class="s4">'ul'</span><span class="s1">)[</span><span class="s4">'id'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'bottom'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_parent_generator(self):</span>
        <span class="s1">parents = [parent[</span><span class="s4">'id'</span><span class="s1">] </span><span class="s3">for </span><span class="s1">parent </span><span class="s3">in </span><span class="s1">self.start.parents</span>
                   <span class="s3">if </span><span class="s1">parent </span><span class="s3">is not None and </span><span class="s4">'id' </span><span class="s3">in </span><span class="s1">parent.attrs]</span>
        <span class="s1">self.assertEqual(parents</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'bottom'</span><span class="s3">, </span><span class="s4">'middle'</span><span class="s3">, </span><span class="s4">'top'</span><span class="s1">])</span>


<span class="s3">class </span><span class="s1">ProximityTest(TreeTest):</span>

    <span class="s3">def </span><span class="s1">setUp(self):</span>
        <span class="s1">super(TreeTest</span><span class="s3">, </span><span class="s1">self).setUp()</span>
        <span class="s1">self.tree = self.soup(</span>
            <span class="s4">'&lt;html id=&quot;start&quot;&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;b id=&quot;1&quot;&gt;One&lt;/b&gt;&lt;b id=&quot;2&quot;&gt;Two&lt;/b&gt;&lt;b id=&quot;3&quot;&gt;Three&lt;/b&gt;&lt;/body&gt;&lt;/html&gt;'</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">TestNextOperations(ProximityTest):</span>

    <span class="s3">def </span><span class="s1">setUp(self):</span>
        <span class="s1">super(TestNextOperations</span><span class="s3">, </span><span class="s1">self).setUp()</span>
        <span class="s1">self.start = self.tree.b</span>

    <span class="s3">def </span><span class="s1">test_next(self):</span>
        <span class="s1">self.assertEqual(self.start.next_element</span><span class="s3">, </span><span class="s4">&quot;One&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(self.start.next_element.next_element[</span><span class="s4">'id'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">&quot;2&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_next_of_last_item_is_none(self):</span>
        <span class="s1">last = self.tree.find(text=</span><span class="s4">&quot;Three&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(last.next_element</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_next_of_root_is_none(self):</span>
        <span class="s0"># The document root is outside the next/previous chain.</span>
        <span class="s1">self.assertEqual(self.tree.next_element</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_find_all_next(self):</span>
        <span class="s1">self.assertSelects(self.start.find_all_next(</span><span class="s4">'b'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;Two&quot;</span><span class="s3">, </span><span class="s4">&quot;Three&quot;</span><span class="s1">])</span>
        <span class="s1">self.start.find_all_next(id=</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">self.assertSelects(self.start.find_all_next(id=</span><span class="s5">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;Three&quot;</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_find_next(self):</span>
        <span class="s1">self.assertEqual(self.start.find_next(</span><span class="s4">'b'</span><span class="s1">)[</span><span class="s4">'id'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'2'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(self.start.find_next(text=</span><span class="s4">&quot;Three&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s4">&quot;Three&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_find_next_for_text_element(self):</span>
        <span class="s1">text = self.tree.find(text=</span><span class="s4">&quot;One&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(text.find_next(</span><span class="s4">&quot;b&quot;</span><span class="s1">).string</span><span class="s3">, </span><span class="s4">&quot;Two&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertSelects(text.find_all_next(</span><span class="s4">&quot;b&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;Two&quot;</span><span class="s3">, </span><span class="s4">&quot;Three&quot;</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_next_generator(self):</span>
        <span class="s1">start = self.tree.find(text=</span><span class="s4">&quot;Two&quot;</span><span class="s1">)</span>
        <span class="s1">successors = [node </span><span class="s3">for </span><span class="s1">node </span><span class="s3">in </span><span class="s1">start.next_elements]</span>
        <span class="s0"># There are two successors: the final &lt;b&gt; tag and its text contents.</span>
        <span class="s1">tag</span><span class="s3">, </span><span class="s1">contents = successors</span>
        <span class="s1">self.assertEqual(tag[</span><span class="s4">'id'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'3'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(contents</span><span class="s3">, </span><span class="s4">&quot;Three&quot;</span><span class="s1">)</span>

<span class="s3">class </span><span class="s1">TestPreviousOperations(ProximityTest):</span>

    <span class="s3">def </span><span class="s1">setUp(self):</span>
        <span class="s1">super(TestPreviousOperations</span><span class="s3">, </span><span class="s1">self).setUp()</span>
        <span class="s1">self.end = self.tree.find(text=</span><span class="s4">&quot;Three&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_previous(self):</span>
        <span class="s1">self.assertEqual(self.end.previous_element[</span><span class="s4">'id'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">&quot;3&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(self.end.previous_element.previous_element</span><span class="s3">, </span><span class="s4">&quot;Two&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_previous_of_first_item_is_none(self):</span>
        <span class="s1">first = self.tree.find(</span><span class="s4">'html'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(first.previous_element</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_previous_of_root_is_none(self):</span>
        <span class="s0"># The document root is outside the next/previous chain.</span>
        <span class="s0"># XXX This is broken!</span>
        <span class="s0">#self.assertEqual(self.tree.previous_element, None)</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">test_find_all_previous(self):</span>
        <span class="s0"># The &lt;b&gt; tag containing the &quot;Three&quot; node is the predecessor</span>
        <span class="s0"># of the &quot;Three&quot; node itself, which is why &quot;Three&quot; shows up</span>
        <span class="s0"># here.</span>
        <span class="s1">self.assertSelects(</span>
            <span class="s1">self.end.find_all_previous(</span><span class="s4">'b'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;Three&quot;</span><span class="s3">, </span><span class="s4">&quot;Two&quot;</span><span class="s3">, </span><span class="s4">&quot;One&quot;</span><span class="s1">])</span>
        <span class="s1">self.assertSelects(self.end.find_all_previous(id=</span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;One&quot;</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_find_previous(self):</span>
        <span class="s1">self.assertEqual(self.end.find_previous(</span><span class="s4">'b'</span><span class="s1">)[</span><span class="s4">'id'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'3'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(self.end.find_previous(text=</span><span class="s4">&quot;One&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s4">&quot;One&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_find_previous_for_text_element(self):</span>
        <span class="s1">text = self.tree.find(text=</span><span class="s4">&quot;Three&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(text.find_previous(</span><span class="s4">&quot;b&quot;</span><span class="s1">).string</span><span class="s3">, </span><span class="s4">&quot;Three&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertSelects(</span>
            <span class="s1">text.find_all_previous(</span><span class="s4">&quot;b&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;Three&quot;</span><span class="s3">, </span><span class="s4">&quot;Two&quot;</span><span class="s3">, </span><span class="s4">&quot;One&quot;</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_previous_generator(self):</span>
        <span class="s1">start = self.tree.find(text=</span><span class="s4">&quot;One&quot;</span><span class="s1">)</span>
        <span class="s1">predecessors = [node </span><span class="s3">for </span><span class="s1">node </span><span class="s3">in </span><span class="s1">start.previous_elements]</span>

        <span class="s0"># There are four predecessors: the &lt;b&gt; tag containing &quot;One&quot;</span>
        <span class="s0"># the &lt;body&gt; tag, the &lt;head&gt; tag, and the &lt;html&gt; tag.</span>
        <span class="s1">b</span><span class="s3">, </span><span class="s1">body</span><span class="s3">, </span><span class="s1">head</span><span class="s3">, </span><span class="s1">html = predecessors</span>
        <span class="s1">self.assertEqual(b[</span><span class="s4">'id'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'1'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(body.name</span><span class="s3">, </span><span class="s4">&quot;body&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(head.name</span><span class="s3">, </span><span class="s4">&quot;head&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(html.name</span><span class="s3">, </span><span class="s4">&quot;html&quot;</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">SiblingTest(TreeTest):</span>

    <span class="s3">def </span><span class="s1">setUp(self):</span>
        <span class="s1">super(SiblingTest</span><span class="s3">, </span><span class="s1">self).setUp()</span>
        <span class="s1">markup = </span><span class="s4">'''&lt;html&gt; 
                    &lt;span id=&quot;1&quot;&gt; 
                     &lt;span id=&quot;1.1&quot;&gt;&lt;/span&gt; 
                    &lt;/span&gt; 
                    &lt;span id=&quot;2&quot;&gt; 
                     &lt;span id=&quot;2.1&quot;&gt;&lt;/span&gt; 
                    &lt;/span&gt; 
                    &lt;span id=&quot;3&quot;&gt; 
                     &lt;span id=&quot;3.1&quot;&gt;&lt;/span&gt; 
                    &lt;/span&gt; 
                    &lt;span id=&quot;4&quot;&gt;&lt;/span&gt; 
                    &lt;/html&gt;'''</span>
        <span class="s0"># All that whitespace looks good but makes the tests more</span>
        <span class="s0"># difficult. Get rid of it.</span>
        <span class="s1">markup = re.compile(</span><span class="s4">r&quot;\n\s*&quot;</span><span class="s1">).sub(</span><span class="s4">&quot;&quot;</span><span class="s3">, </span><span class="s1">markup)</span>
        <span class="s1">self.tree = self.soup(markup)</span>


<span class="s3">class </span><span class="s1">TestNextSibling(SiblingTest):</span>

    <span class="s3">def </span><span class="s1">setUp(self):</span>
        <span class="s1">super(TestNextSibling</span><span class="s3">, </span><span class="s1">self).setUp()</span>
        <span class="s1">self.start = self.tree.find(id=</span><span class="s4">&quot;1&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_next_sibling_of_root_is_none(self):</span>
        <span class="s1">self.assertEqual(self.tree.next_sibling</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_next_sibling(self):</span>
        <span class="s1">self.assertEqual(self.start.next_sibling[</span><span class="s4">'id'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'2'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(self.start.next_sibling.next_sibling[</span><span class="s4">'id'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'3'</span><span class="s1">)</span>

        <span class="s0"># Note the difference between next_sibling and next_element.</span>
        <span class="s1">self.assertEqual(self.start.next_element[</span><span class="s4">'id'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'1.1'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_next_sibling_may_not_exist(self):</span>
        <span class="s1">self.assertEqual(self.tree.html.next_sibling</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s1">nested_span = self.tree.find(id=</span><span class="s4">&quot;1.1&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(nested_span.next_sibling</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s1">last_span = self.tree.find(id=</span><span class="s4">&quot;4&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(last_span.next_sibling</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_find_next_sibling(self):</span>
        <span class="s1">self.assertEqual(self.start.find_next_sibling(</span><span class="s4">'span'</span><span class="s1">)[</span><span class="s4">'id'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'2'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_next_siblings(self):</span>
        <span class="s1">self.assertSelectsIDs(self.start.find_next_siblings(</span><span class="s4">&quot;span&quot;</span><span class="s1">)</span><span class="s3">,</span>
                              <span class="s1">[</span><span class="s4">'2'</span><span class="s3">, </span><span class="s4">'3'</span><span class="s3">, </span><span class="s4">'4'</span><span class="s1">])</span>

        <span class="s1">self.assertSelectsIDs(self.start.find_next_siblings(id=</span><span class="s4">'3'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'3'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_next_sibling_for_text_element(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;Foo&lt;b&gt;bar&lt;/b&gt;baz&quot;</span><span class="s1">)</span>
        <span class="s1">start = soup.find(text=</span><span class="s4">&quot;Foo&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(start.next_sibling.name</span><span class="s3">, </span><span class="s4">'b'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(start.next_sibling.next_sibling</span><span class="s3">, </span><span class="s4">'baz'</span><span class="s1">)</span>

        <span class="s1">self.assertSelects(start.find_next_siblings(</span><span class="s4">'b'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'bar'</span><span class="s1">])</span>
        <span class="s1">self.assertEqual(start.find_next_sibling(text=</span><span class="s4">&quot;baz&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s4">&quot;baz&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(start.find_next_sibling(text=</span><span class="s4">&quot;nonesuch&quot;</span><span class="s1">)</span><span class="s3">, None</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">TestPreviousSibling(SiblingTest):</span>

    <span class="s3">def </span><span class="s1">setUp(self):</span>
        <span class="s1">super(TestPreviousSibling</span><span class="s3">, </span><span class="s1">self).setUp()</span>
        <span class="s1">self.end = self.tree.find(id=</span><span class="s4">&quot;4&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_previous_sibling_of_root_is_none(self):</span>
        <span class="s1">self.assertEqual(self.tree.previous_sibling</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_previous_sibling(self):</span>
        <span class="s1">self.assertEqual(self.end.previous_sibling[</span><span class="s4">'id'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'3'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(self.end.previous_sibling.previous_sibling[</span><span class="s4">'id'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'2'</span><span class="s1">)</span>

        <span class="s0"># Note the difference between previous_sibling and previous_element.</span>
        <span class="s1">self.assertEqual(self.end.previous_element[</span><span class="s4">'id'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'3.1'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_previous_sibling_may_not_exist(self):</span>
        <span class="s1">self.assertEqual(self.tree.html.previous_sibling</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s1">nested_span = self.tree.find(id=</span><span class="s4">&quot;1.1&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(nested_span.previous_sibling</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s1">first_span = self.tree.find(id=</span><span class="s4">&quot;1&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(first_span.previous_sibling</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_find_previous_sibling(self):</span>
        <span class="s1">self.assertEqual(self.end.find_previous_sibling(</span><span class="s4">'span'</span><span class="s1">)[</span><span class="s4">'id'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'3'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_previous_siblings(self):</span>
        <span class="s1">self.assertSelectsIDs(self.end.find_previous_siblings(</span><span class="s4">&quot;span&quot;</span><span class="s1">)</span><span class="s3">,</span>
                              <span class="s1">[</span><span class="s4">'3'</span><span class="s3">, </span><span class="s4">'2'</span><span class="s3">, </span><span class="s4">'1'</span><span class="s1">])</span>

        <span class="s1">self.assertSelectsIDs(self.end.find_previous_siblings(id=</span><span class="s4">'1'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'1'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_previous_sibling_for_text_element(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;Foo&lt;b&gt;bar&lt;/b&gt;baz&quot;</span><span class="s1">)</span>
        <span class="s1">start = soup.find(text=</span><span class="s4">&quot;baz&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(start.previous_sibling.name</span><span class="s3">, </span><span class="s4">'b'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(start.previous_sibling.previous_sibling</span><span class="s3">, </span><span class="s4">'Foo'</span><span class="s1">)</span>

        <span class="s1">self.assertSelects(start.find_previous_siblings(</span><span class="s4">'b'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'bar'</span><span class="s1">])</span>
        <span class="s1">self.assertEqual(start.find_previous_sibling(text=</span><span class="s4">&quot;Foo&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s4">&quot;Foo&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(start.find_previous_sibling(text=</span><span class="s4">&quot;nonesuch&quot;</span><span class="s1">)</span><span class="s3">, None</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">TestTag(SoupTest):</span>

    <span class="s0"># Test various methods of Tag.</span>

    <span class="s3">def </span><span class="s1">test__should_pretty_print(self):</span>
        <span class="s0"># Test the rules about when a tag should be pretty-printed.</span>
        <span class="s1">tag = self.soup(</span><span class="s4">&quot;&quot;</span><span class="s1">).new_tag(</span><span class="s4">&quot;a_tag&quot;</span><span class="s1">)</span>

        <span class="s0"># No list of whitespace-preserving tags -&gt; pretty-print</span>
        <span class="s1">tag._preserve_whitespace_tags = </span><span class="s3">None</span>
        <span class="s1">self.assertEqual(</span><span class="s3">True, </span><span class="s1">tag._should_pretty_print(</span><span class="s5">0</span><span class="s1">))</span>

        <span class="s0"># List exists but tag is not on the list -&gt; pretty-print</span>
        <span class="s1">tag.preserve_whitespace_tags = [</span><span class="s4">&quot;some_other_tag&quot;</span><span class="s1">]</span>
        <span class="s1">self.assertEqual(</span><span class="s3">True, </span><span class="s1">tag._should_pretty_print(</span><span class="s5">1</span><span class="s1">))</span>

        <span class="s0"># Indent level is None -&gt; don't pretty-print</span>
        <span class="s1">self.assertEqual(</span><span class="s3">False, </span><span class="s1">tag._should_pretty_print(</span><span class="s3">None</span><span class="s1">))</span>
        
        <span class="s0"># Tag is on the whitespace-preserving list -&gt; don't pretty-print</span>
        <span class="s1">tag.preserve_whitespace_tags = [</span><span class="s4">&quot;some_other_tag&quot;</span><span class="s3">, </span><span class="s4">&quot;a_tag&quot;</span><span class="s1">]</span>
        <span class="s1">self.assertEqual(</span><span class="s3">False, </span><span class="s1">tag._should_pretty_print(</span><span class="s5">1</span><span class="s1">))</span>

        
<span class="s3">class </span><span class="s1">TestTagCreation(SoupTest):</span>
    <span class="s2">&quot;&quot;&quot;Test the ability to create new tags.&quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">test_new_tag(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">new_tag = soup.new_tag(</span><span class="s4">&quot;foo&quot;</span><span class="s3">, </span><span class="s1">bar=</span><span class="s4">&quot;baz&quot;</span><span class="s3">, </span><span class="s1">attrs={</span><span class="s4">&quot;name&quot;</span><span class="s1">: </span><span class="s4">&quot;a name&quot;</span><span class="s1">})</span>
        <span class="s1">self.assertTrue(isinstance(new_tag</span><span class="s3">, </span><span class="s1">Tag))</span>
        <span class="s1">self.assertEqual(</span><span class="s4">&quot;foo&quot;</span><span class="s3">, </span><span class="s1">new_tag.name)</span>
        <span class="s1">self.assertEqual(dict(bar=</span><span class="s4">&quot;baz&quot;</span><span class="s3">, </span><span class="s1">name=</span><span class="s4">&quot;a name&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">new_tag.attrs)</span>
        <span class="s1">self.assertEqual(</span><span class="s3">None, </span><span class="s1">new_tag.parent)</span>
        
    <span class="s3">def </span><span class="s1">test_tag_inherits_self_closing_rules_from_builder(self):</span>
        <span class="s3">if </span><span class="s1">XML_BUILDER_PRESENT:</span>
            <span class="s1">xml_soup = BeautifulSoup(</span><span class="s4">&quot;&quot;</span><span class="s3">, </span><span class="s4">&quot;lxml-xml&quot;</span><span class="s1">)</span>
            <span class="s1">xml_br = xml_soup.new_tag(</span><span class="s4">&quot;br&quot;</span><span class="s1">)</span>
            <span class="s1">xml_p = xml_soup.new_tag(</span><span class="s4">&quot;p&quot;</span><span class="s1">)</span>

            <span class="s0"># Both the &lt;br&gt; and &lt;p&gt; tag are empty-element, just because</span>
            <span class="s0"># they have no contents.</span>
            <span class="s1">self.assertEqual(</span><span class="s6">b&quot;&lt;br/&gt;&quot;</span><span class="s3">, </span><span class="s1">xml_br.encode())</span>
            <span class="s1">self.assertEqual(</span><span class="s6">b&quot;&lt;p/&gt;&quot;</span><span class="s3">, </span><span class="s1">xml_p.encode())</span>

        <span class="s1">html_soup = BeautifulSoup(</span><span class="s4">&quot;&quot;</span><span class="s3">, </span><span class="s4">&quot;html.parser&quot;</span><span class="s1">)</span>
        <span class="s1">html_br = html_soup.new_tag(</span><span class="s4">&quot;br&quot;</span><span class="s1">)</span>
        <span class="s1">html_p = html_soup.new_tag(</span><span class="s4">&quot;p&quot;</span><span class="s1">)</span>

        <span class="s0"># The HTML builder users HTML's rules about which tags are</span>
        <span class="s0"># empty-element tags, and the new tags reflect these rules.</span>
        <span class="s1">self.assertEqual(</span><span class="s6">b&quot;&lt;br/&gt;&quot;</span><span class="s3">, </span><span class="s1">html_br.encode())</span>
        <span class="s1">self.assertEqual(</span><span class="s6">b&quot;&lt;p&gt;&lt;/p&gt;&quot;</span><span class="s3">, </span><span class="s1">html_p.encode())</span>

    <span class="s3">def </span><span class="s1">test_new_string_creates_navigablestring(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">s = soup.new_string(</span><span class="s4">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span><span class="s4">&quot;foo&quot;</span><span class="s3">, </span><span class="s1">s)</span>
        <span class="s1">self.assertTrue(isinstance(s</span><span class="s3">, </span><span class="s1">NavigableString))</span>

    <span class="s3">def </span><span class="s1">test_new_string_can_create_navigablestring_subclass(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">s = soup.new_string(</span><span class="s4">&quot;foo&quot;</span><span class="s3">, </span><span class="s1">Comment)</span>
        <span class="s1">self.assertEqual(</span><span class="s4">&quot;foo&quot;</span><span class="s3">, </span><span class="s1">s)</span>
        <span class="s1">self.assertTrue(isinstance(s</span><span class="s3">, </span><span class="s1">Comment))</span>

<span class="s3">class </span><span class="s1">TestTreeModification(SoupTest):</span>

    <span class="s3">def </span><span class="s1">test_attribute_modification(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">'&lt;a id=&quot;1&quot;&gt;&lt;/a&gt;'</span><span class="s1">)</span>
        <span class="s1">soup.a[</span><span class="s4">'id'</span><span class="s1">] = </span><span class="s5">2</span>
        <span class="s1">self.assertEqual(soup.decode()</span><span class="s3">, </span><span class="s1">self.document_for(</span><span class="s4">'&lt;a id=&quot;2&quot;&gt;&lt;/a&gt;'</span><span class="s1">))</span>
        <span class="s3">del</span><span class="s1">(soup.a[</span><span class="s4">'id'</span><span class="s1">])</span>
        <span class="s1">self.assertEqual(soup.decode()</span><span class="s3">, </span><span class="s1">self.document_for(</span><span class="s4">'&lt;a&gt;&lt;/a&gt;'</span><span class="s1">))</span>
        <span class="s1">soup.a[</span><span class="s4">'id2'</span><span class="s1">] = </span><span class="s4">'foo'</span>
        <span class="s1">self.assertEqual(soup.decode()</span><span class="s3">, </span><span class="s1">self.document_for(</span><span class="s4">'&lt;a id2=&quot;foo&quot;&gt;&lt;/a&gt;'</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_new_tag_creation(self):</span>
        <span class="s1">builder = builder_registry.lookup(</span><span class="s4">'html'</span><span class="s1">)()</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;body&gt;&lt;/body&gt;&quot;</span><span class="s3">, </span><span class="s1">builder=builder)</span>
        <span class="s1">a = Tag(soup</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s4">'a'</span><span class="s1">)</span>
        <span class="s1">ol = Tag(soup</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s4">'ol'</span><span class="s1">)</span>
        <span class="s1">a[</span><span class="s4">'href'</span><span class="s1">] = </span><span class="s4">'http://foo.com/'</span>
        <span class="s1">soup.body.insert(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">a)</span>
        <span class="s1">soup.body.insert(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">ol)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.body.encode()</span><span class="s3">,</span>
            <span class="s6">b'&lt;body&gt;&lt;a href=&quot;http://foo.com/&quot;&gt;&lt;/a&gt;&lt;ol&gt;&lt;/ol&gt;&lt;/body&gt;'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_append_to_contents_moves_tag(self):</span>
        <span class="s1">doc = </span><span class="s4">&quot;&quot;&quot;&lt;p id=&quot;1&quot;&gt;Don't leave me &lt;b&gt;here&lt;/b&gt;.&lt;/p&gt; 
                &lt;p id=&quot;2&quot;&gt;Don</span><span class="s3">\'</span><span class="s4">t leave!&lt;/p&gt;&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(doc)</span>
        <span class="s1">second_para = soup.find(id=</span><span class="s4">'2'</span><span class="s1">)</span>
        <span class="s1">bold = soup.b</span>

        <span class="s0"># Move the &lt;b&gt; tag to the end of the second paragraph.</span>
        <span class="s1">soup.find(id=</span><span class="s4">'2'</span><span class="s1">).append(soup.b)</span>

        <span class="s0"># The &lt;b&gt; tag is now a child of the second paragraph.</span>
        <span class="s1">self.assertEqual(bold.parent</span><span class="s3">, </span><span class="s1">second_para)</span>

        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.decode()</span><span class="s3">, </span><span class="s1">self.document_for(</span>
                <span class="s4">'&lt;p id=&quot;1&quot;&gt;Don</span><span class="s3">\'</span><span class="s4">t leave me .&lt;/p&gt;</span><span class="s3">\n</span><span class="s4">'</span>
                <span class="s4">'&lt;p id=&quot;2&quot;&gt;Don</span><span class="s3">\'</span><span class="s4">t leave!&lt;b&gt;here&lt;/b&gt;&lt;/p&gt;'</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_replace_with_returns_thing_that_was_replaced(self):</span>
        <span class="s1">text = </span><span class="s4">&quot;&lt;a&gt;&lt;/a&gt;&lt;b&gt;&lt;c&gt;&lt;/c&gt;&lt;/b&gt;&quot;</span>
        <span class="s1">soup = self.soup(text)</span>
        <span class="s1">a = soup.a</span>
        <span class="s1">new_a = a.replace_with(soup.c)</span>
        <span class="s1">self.assertEqual(a</span><span class="s3">, </span><span class="s1">new_a)</span>

    <span class="s3">def </span><span class="s1">test_unwrap_returns_thing_that_was_replaced(self):</span>
        <span class="s1">text = </span><span class="s4">&quot;&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;c&gt;&lt;/c&gt;&lt;/a&gt;&quot;</span>
        <span class="s1">soup = self.soup(text)</span>
        <span class="s1">a = soup.a</span>
        <span class="s1">new_a = a.unwrap()</span>
        <span class="s1">self.assertEqual(a</span><span class="s3">, </span><span class="s1">new_a)</span>

    <span class="s3">def </span><span class="s1">test_replace_with_and_unwrap_give_useful_exception_when_tag_has_no_parent(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;&lt;b&gt;Foo&lt;/b&gt;&lt;/a&gt;&lt;c&gt;Bar&lt;/c&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">a = soup.a</span>
        <span class="s1">a.extract()</span>
        <span class="s1">self.assertEqual(</span><span class="s3">None, </span><span class="s1">a.parent)</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s3">, </span><span class="s1">a.unwrap)</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s3">, </span><span class="s1">a.replace_with</span><span class="s3">, </span><span class="s1">soup.c)</span>

    <span class="s3">def </span><span class="s1">test_replace_tag_with_itself(self):</span>
        <span class="s1">text = </span><span class="s4">&quot;&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;c&gt;Foo&lt;d&gt;&lt;/d&gt;&lt;/c&gt;&lt;/a&gt;&lt;a&gt;&lt;e&gt;&lt;/e&gt;&lt;/a&gt;&quot;</span>
        <span class="s1">soup = self.soup(text)</span>
        <span class="s1">c = soup.c</span>
        <span class="s1">soup.c.replace_with(c)</span>
        <span class="s1">self.assertEqual(soup.decode()</span><span class="s3">, </span><span class="s1">self.document_for(text))</span>

    <span class="s3">def </span><span class="s1">test_replace_tag_with_its_parent_raises_exception(self):</span>
        <span class="s1">text = </span><span class="s4">&quot;&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;&quot;</span>
        <span class="s1">soup = self.soup(text)</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s3">, </span><span class="s1">soup.b.replace_with</span><span class="s3">, </span><span class="s1">soup.a)</span>

    <span class="s3">def </span><span class="s1">test_insert_tag_into_itself_raises_exception(self):</span>
        <span class="s1">text = </span><span class="s4">&quot;&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;&quot;</span>
        <span class="s1">soup = self.soup(text)</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s3">, </span><span class="s1">soup.a.insert</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">soup.a)</span>

    <span class="s3">def </span><span class="s1">test_insert_beautifulsoup_object_inserts_children(self):</span>
        <span class="s2">&quot;&quot;&quot;Inserting one BeautifulSoup object into another actually inserts all 
        of its children -- you'll never combine BeautifulSoup objects. 
        &quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;p&gt;And now, a word:&lt;/p&gt;&lt;p&gt;And we're back.&lt;/p&gt;&quot;</span><span class="s1">)</span>
        
        <span class="s1">text = </span><span class="s4">&quot;&lt;p&gt;p2&lt;/p&gt;&lt;p&gt;p3&lt;/p&gt;&quot;</span>
        <span class="s1">to_insert = self.soup(text)</span>
        <span class="s1">soup.insert(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">to_insert)</span>

        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">soup.descendants:</span>
            <span class="s3">assert not </span><span class="s1">isinstance(i</span><span class="s3">, </span><span class="s1">BeautifulSoup)</span>
        
        <span class="s1">p1</span><span class="s3">, </span><span class="s1">p2</span><span class="s3">, </span><span class="s1">p3</span><span class="s3">, </span><span class="s1">p4 = list(soup.children)</span>
        <span class="s1">self.assertEqual(</span><span class="s4">&quot;And now, a word:&quot;</span><span class="s3">, </span><span class="s1">p1.string)</span>
        <span class="s1">self.assertEqual(</span><span class="s4">&quot;p2&quot;</span><span class="s3">, </span><span class="s1">p2.string)</span>
        <span class="s1">self.assertEqual(</span><span class="s4">&quot;p3&quot;</span><span class="s3">, </span><span class="s1">p3.string)</span>
        <span class="s1">self.assertEqual(</span><span class="s4">&quot;And we're back.&quot;</span><span class="s3">, </span><span class="s1">p4.string)</span>
        
        
    <span class="s3">def </span><span class="s1">test_replace_with_maintains_next_element_throughout(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">'&lt;p&gt;&lt;a&gt;one&lt;/a&gt;&lt;b&gt;three&lt;/b&gt;&lt;/p&gt;'</span><span class="s1">)</span>
        <span class="s1">a = soup.a</span>
        <span class="s1">b = a.contents[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s0"># Make it so the &lt;a&gt; tag has two text children.</span>
        <span class="s1">a.insert(</span><span class="s5">1</span><span class="s3">, </span><span class="s4">&quot;two&quot;</span><span class="s1">)</span>

        <span class="s0"># Now replace each one with the empty string.</span>
        <span class="s1">left</span><span class="s3">, </span><span class="s1">right = a.contents</span>
        <span class="s1">left.replaceWith(</span><span class="s4">''</span><span class="s1">)</span>
        <span class="s1">right.replaceWith(</span><span class="s4">''</span><span class="s1">)</span>

        <span class="s0"># The &lt;b&gt; tag is still connected to the tree.</span>
        <span class="s1">self.assertEqual(</span><span class="s4">&quot;three&quot;</span><span class="s3">, </span><span class="s1">soup.b.string)</span>

    <span class="s3">def </span><span class="s1">test_replace_final_node(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;b&gt;Argh!&lt;/b&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">soup.find(text=</span><span class="s4">&quot;Argh!&quot;</span><span class="s1">).replace_with(</span><span class="s4">&quot;Hooray!&quot;</span><span class="s1">)</span>
        <span class="s1">new_text = soup.find(text=</span><span class="s4">&quot;Hooray!&quot;</span><span class="s1">)</span>
        <span class="s1">b = soup.b</span>
        <span class="s1">self.assertEqual(new_text.previous_element</span><span class="s3">, </span><span class="s1">b)</span>
        <span class="s1">self.assertEqual(new_text.parent</span><span class="s3">, </span><span class="s1">b)</span>
        <span class="s1">self.assertEqual(new_text.previous_element.next_element</span><span class="s3">, </span><span class="s1">new_text)</span>
        <span class="s1">self.assertEqual(new_text.next_element</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_consecutive_text_nodes(self):</span>
        <span class="s0"># A builder should never create two consecutive text nodes,</span>
        <span class="s0"># but if you insert one next to another, Beautiful Soup will</span>
        <span class="s0"># handle it correctly.</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;&lt;b&gt;Argh!&lt;/b&gt;&lt;c&gt;&lt;/c&gt;&lt;/a&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">soup.b.insert(</span><span class="s5">1</span><span class="s3">, </span><span class="s4">&quot;Hooray!&quot;</span><span class="s1">)</span>

        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.decode()</span><span class="s3">, </span><span class="s1">self.document_for(</span>
                <span class="s4">&quot;&lt;a&gt;&lt;b&gt;Argh!Hooray!&lt;/b&gt;&lt;c&gt;&lt;/c&gt;&lt;/a&gt;&quot;</span><span class="s1">))</span>

        <span class="s1">new_text = soup.find(text=</span><span class="s4">&quot;Hooray!&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(new_text.previous_element</span><span class="s3">, </span><span class="s4">&quot;Argh!&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(new_text.previous_element.next_element</span><span class="s3">, </span><span class="s1">new_text)</span>

        <span class="s1">self.assertEqual(new_text.previous_sibling</span><span class="s3">, </span><span class="s4">&quot;Argh!&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(new_text.previous_sibling.next_sibling</span><span class="s3">, </span><span class="s1">new_text)</span>

        <span class="s1">self.assertEqual(new_text.next_sibling</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(new_text.next_element</span><span class="s3">, </span><span class="s1">soup.c)</span>

    <span class="s3">def </span><span class="s1">test_insert_string(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;&lt;/a&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">soup.a.insert(</span><span class="s5">0</span><span class="s3">, </span><span class="s4">&quot;bar&quot;</span><span class="s1">)</span>
        <span class="s1">soup.a.insert(</span><span class="s5">0</span><span class="s3">, </span><span class="s4">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s0"># The string were added to the tag.</span>
        <span class="s1">self.assertEqual([</span><span class="s4">&quot;foo&quot;</span><span class="s3">, </span><span class="s4">&quot;bar&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">soup.a.contents)</span>
        <span class="s0"># And they were converted to NavigableStrings.</span>
        <span class="s1">self.assertEqual(soup.a.contents[</span><span class="s5">0</span><span class="s1">].next_element</span><span class="s3">, </span><span class="s4">&quot;bar&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_insert_tag(self):</span>
        <span class="s1">builder = self.default_builder()</span>
        <span class="s1">soup = self.soup(</span>
            <span class="s4">&quot;&lt;a&gt;&lt;b&gt;Find&lt;/b&gt;&lt;c&gt;lady!&lt;/c&gt;&lt;d&gt;&lt;/d&gt;&lt;/a&gt;&quot;</span><span class="s3">, </span><span class="s1">builder=builder)</span>
        <span class="s1">magic_tag = Tag(soup</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">, </span><span class="s4">'magictag'</span><span class="s1">)</span>
        <span class="s1">magic_tag.insert(</span><span class="s5">0</span><span class="s3">, </span><span class="s4">&quot;the&quot;</span><span class="s1">)</span>
        <span class="s1">soup.a.insert(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">magic_tag)</span>

        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.decode()</span><span class="s3">, </span><span class="s1">self.document_for(</span>
                <span class="s4">&quot;&lt;a&gt;&lt;b&gt;Find&lt;/b&gt;&lt;magictag&gt;the&lt;/magictag&gt;&lt;c&gt;lady!&lt;/c&gt;&lt;d&gt;&lt;/d&gt;&lt;/a&gt;&quot;</span><span class="s1">))</span>

        <span class="s0"># Make sure all the relationships are hooked up correctly.</span>
        <span class="s1">b_tag = soup.b</span>
        <span class="s1">self.assertEqual(b_tag.next_sibling</span><span class="s3">, </span><span class="s1">magic_tag)</span>
        <span class="s1">self.assertEqual(magic_tag.previous_sibling</span><span class="s3">, </span><span class="s1">b_tag)</span>

        <span class="s1">find = b_tag.find(text=</span><span class="s4">&quot;Find&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(find.next_element</span><span class="s3">, </span><span class="s1">magic_tag)</span>
        <span class="s1">self.assertEqual(magic_tag.previous_element</span><span class="s3">, </span><span class="s1">find)</span>

        <span class="s1">c_tag = soup.c</span>
        <span class="s1">self.assertEqual(magic_tag.next_sibling</span><span class="s3">, </span><span class="s1">c_tag)</span>
        <span class="s1">self.assertEqual(c_tag.previous_sibling</span><span class="s3">, </span><span class="s1">magic_tag)</span>

        <span class="s1">the = magic_tag.find(text=</span><span class="s4">&quot;the&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(the.parent</span><span class="s3">, </span><span class="s1">magic_tag)</span>
        <span class="s1">self.assertEqual(the.next_element</span><span class="s3">, </span><span class="s1">c_tag)</span>
        <span class="s1">self.assertEqual(c_tag.previous_element</span><span class="s3">, </span><span class="s1">the)</span>

    <span class="s3">def </span><span class="s1">test_append_child_thats_already_at_the_end(self):</span>
        <span class="s1">data = </span><span class="s4">&quot;&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;&quot;</span>
        <span class="s1">soup = self.soup(data)</span>
        <span class="s1">soup.a.append(soup.b)</span>
        <span class="s1">self.assertEqual(data</span><span class="s3">, </span><span class="s1">soup.decode())</span>

    <span class="s3">def </span><span class="s1">test_extend(self):</span>
        <span class="s1">data = </span><span class="s4">&quot;&lt;a&gt;&lt;b&gt;&lt;c&gt;&lt;d&gt;&lt;e&gt;&lt;f&gt;&lt;g&gt;&lt;/g&gt;&lt;/f&gt;&lt;/e&gt;&lt;/d&gt;&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&quot;</span>
        <span class="s1">soup = self.soup(data)</span>
        <span class="s1">l = [soup.g</span><span class="s3">, </span><span class="s1">soup.f</span><span class="s3">, </span><span class="s1">soup.e</span><span class="s3">, </span><span class="s1">soup.d</span><span class="s3">, </span><span class="s1">soup.c</span><span class="s3">, </span><span class="s1">soup.b]</span>
        <span class="s1">soup.a.extend(l)</span>
        <span class="s1">self.assertEqual(</span><span class="s4">&quot;&lt;a&gt;&lt;g&gt;&lt;/g&gt;&lt;f&gt;&lt;/f&gt;&lt;e&gt;&lt;/e&gt;&lt;d&gt;&lt;/d&gt;&lt;c&gt;&lt;/c&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;&quot;</span><span class="s3">, </span><span class="s1">soup.decode())</span>

    <span class="s3">def </span><span class="s1">test_extend_with_another_tags_contents(self):</span>
        <span class="s1">data = </span><span class="s4">'&lt;body&gt;&lt;div id=&quot;d1&quot;&gt;&lt;a&gt;1&lt;/a&gt;&lt;a&gt;2&lt;/a&gt;&lt;a&gt;3&lt;/a&gt;&lt;a&gt;4&lt;/a&gt;&lt;/div&gt;&lt;div id=&quot;d2&quot;&gt;&lt;/div&gt;&lt;/body&gt;'</span>
        <span class="s1">soup = self.soup(data)</span>
        <span class="s1">d1 = soup.find(</span><span class="s4">'div'</span><span class="s3">, </span><span class="s1">id=</span><span class="s4">'d1'</span><span class="s1">)</span>
        <span class="s1">d2 = soup.find(</span><span class="s4">'div'</span><span class="s3">, </span><span class="s1">id=</span><span class="s4">'d2'</span><span class="s1">)</span>
        <span class="s1">d2.extend(d1)</span>
        <span class="s1">self.assertEqual(</span><span class="s4">'&lt;div id=&quot;d1&quot;&gt;&lt;/div&gt;'</span><span class="s3">, </span><span class="s1">d1.decode())</span>
        <span class="s1">self.assertEqual(</span><span class="s4">'&lt;div id=&quot;d2&quot;&gt;&lt;a&gt;1&lt;/a&gt;&lt;a&gt;2&lt;/a&gt;&lt;a&gt;3&lt;/a&gt;&lt;a&gt;4&lt;/a&gt;&lt;/div&gt;'</span><span class="s3">, </span><span class="s1">d2.decode())</span>
        
    <span class="s3">def </span><span class="s1">test_move_tag_to_beginning_of_parent(self):</span>
        <span class="s1">data = </span><span class="s4">&quot;&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;c&gt;&lt;/c&gt;&lt;d&gt;&lt;/d&gt;&lt;/a&gt;&quot;</span>
        <span class="s1">soup = self.soup(data)</span>
        <span class="s1">soup.a.insert(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">soup.d)</span>
        <span class="s1">self.assertEqual(</span><span class="s4">&quot;&lt;a&gt;&lt;d&gt;&lt;/d&gt;&lt;b&gt;&lt;/b&gt;&lt;c&gt;&lt;/c&gt;&lt;/a&gt;&quot;</span><span class="s3">, </span><span class="s1">soup.decode())</span>

    <span class="s3">def </span><span class="s1">test_insert_works_on_empty_element_tag(self):</span>
        <span class="s0"># This is a little strange, since most HTML parsers don't allow</span>
        <span class="s0"># markup like this to come through. But in general, we don't</span>
        <span class="s0"># know what the parser would or wouldn't have allowed, so</span>
        <span class="s0"># I'm letting this succeed for now.</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;br/&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">soup.br.insert(</span><span class="s5">1</span><span class="s3">, </span><span class="s4">&quot;Contents&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(str(soup.br)</span><span class="s3">, </span><span class="s4">&quot;&lt;br&gt;Contents&lt;/br&gt;&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_insert_before(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;foo&lt;/a&gt;&lt;b&gt;bar&lt;/b&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">soup.b.insert_before(</span><span class="s4">&quot;BAZ&quot;</span><span class="s1">)</span>
        <span class="s1">soup.a.insert_before(</span><span class="s4">&quot;QUUX&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.decode()</span><span class="s3">, </span><span class="s1">self.document_for(</span><span class="s4">&quot;QUUX&lt;a&gt;foo&lt;/a&gt;BAZ&lt;b&gt;bar&lt;/b&gt;&quot;</span><span class="s1">))</span>

        <span class="s1">soup.a.insert_before(soup.b)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.decode()</span><span class="s3">, </span><span class="s1">self.document_for(</span><span class="s4">&quot;QUUX&lt;b&gt;bar&lt;/b&gt;&lt;a&gt;foo&lt;/a&gt;BAZ&quot;</span><span class="s1">))</span>

        <span class="s0"># Can't insert an element before itself.</span>
        <span class="s1">b = soup.b</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s3">, </span><span class="s1">b.insert_before</span><span class="s3">, </span><span class="s1">b)</span>

        <span class="s0"># Can't insert before if an element has no parent.</span>
        <span class="s1">b.extract()</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s3">, </span><span class="s1">b.insert_before</span><span class="s3">, </span><span class="s4">&quot;nope&quot;</span><span class="s1">)</span>

        <span class="s0"># Can insert an identical element</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">soup.a.insert_before(soup.new_tag(</span><span class="s4">&quot;a&quot;</span><span class="s1">))</span>
        
    <span class="s3">def </span><span class="s1">test_insert_multiple_before(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;foo&lt;/a&gt;&lt;b&gt;bar&lt;/b&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">soup.b.insert_before(</span><span class="s4">&quot;BAZ&quot;</span><span class="s3">, </span><span class="s4">&quot; &quot;</span><span class="s3">, </span><span class="s4">&quot;QUUX&quot;</span><span class="s1">)</span>
        <span class="s1">soup.a.insert_before(</span><span class="s4">&quot;QUUX&quot;</span><span class="s3">, </span><span class="s4">&quot; &quot;</span><span class="s3">, </span><span class="s4">&quot;BAZ&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.decode()</span><span class="s3">, </span><span class="s1">self.document_for(</span><span class="s4">&quot;QUUX BAZ&lt;a&gt;foo&lt;/a&gt;BAZ QUUX&lt;b&gt;bar&lt;/b&gt;&quot;</span><span class="s1">))</span>

        <span class="s1">soup.a.insert_before(soup.b</span><span class="s3">, </span><span class="s4">&quot;FOO&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.decode()</span><span class="s3">, </span><span class="s1">self.document_for(</span><span class="s4">&quot;QUUX BAZ&lt;b&gt;bar&lt;/b&gt;FOO&lt;a&gt;foo&lt;/a&gt;BAZ QUUX&quot;</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_insert_after(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;foo&lt;/a&gt;&lt;b&gt;bar&lt;/b&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">soup.b.insert_after(</span><span class="s4">&quot;BAZ&quot;</span><span class="s1">)</span>
        <span class="s1">soup.a.insert_after(</span><span class="s4">&quot;QUUX&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.decode()</span><span class="s3">, </span><span class="s1">self.document_for(</span><span class="s4">&quot;&lt;a&gt;foo&lt;/a&gt;QUUX&lt;b&gt;bar&lt;/b&gt;BAZ&quot;</span><span class="s1">))</span>
        <span class="s1">soup.b.insert_after(soup.a)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.decode()</span><span class="s3">, </span><span class="s1">self.document_for(</span><span class="s4">&quot;QUUX&lt;b&gt;bar&lt;/b&gt;&lt;a&gt;foo&lt;/a&gt;BAZ&quot;</span><span class="s1">))</span>

        <span class="s0"># Can't insert an element after itself.</span>
        <span class="s1">b = soup.b</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s3">, </span><span class="s1">b.insert_after</span><span class="s3">, </span><span class="s1">b)</span>

        <span class="s0"># Can't insert after if an element has no parent.</span>
        <span class="s1">b.extract()</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s3">, </span><span class="s1">b.insert_after</span><span class="s3">, </span><span class="s4">&quot;nope&quot;</span><span class="s1">)</span>

        <span class="s0"># Can insert an identical element</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">soup.a.insert_before(soup.new_tag(</span><span class="s4">&quot;a&quot;</span><span class="s1">))</span>
        
    <span class="s3">def </span><span class="s1">test_insert_multiple_after(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;foo&lt;/a&gt;&lt;b&gt;bar&lt;/b&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">soup.b.insert_after(</span><span class="s4">&quot;BAZ&quot;</span><span class="s3">, </span><span class="s4">&quot; &quot;</span><span class="s3">, </span><span class="s4">&quot;QUUX&quot;</span><span class="s1">)</span>
        <span class="s1">soup.a.insert_after(</span><span class="s4">&quot;QUUX&quot;</span><span class="s3">, </span><span class="s4">&quot; &quot;</span><span class="s3">, </span><span class="s4">&quot;BAZ&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.decode()</span><span class="s3">, </span><span class="s1">self.document_for(</span><span class="s4">&quot;&lt;a&gt;foo&lt;/a&gt;QUUX BAZ&lt;b&gt;bar&lt;/b&gt;BAZ QUUX&quot;</span><span class="s1">))</span>
        <span class="s1">soup.b.insert_after(soup.a</span><span class="s3">, </span><span class="s4">&quot;FOO &quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.decode()</span><span class="s3">, </span><span class="s1">self.document_for(</span><span class="s4">&quot;QUUX BAZ&lt;b&gt;bar&lt;/b&gt;&lt;a&gt;foo&lt;/a&gt;FOO BAZ QUUX&quot;</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_insert_after_raises_exception_if_after_has_no_meaning(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">tag = soup.new_tag(</span><span class="s4">&quot;a&quot;</span><span class="s1">)</span>
        <span class="s1">string = soup.new_string(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s3">, </span><span class="s1">string.insert_after</span><span class="s3">, </span><span class="s1">tag)</span>
        <span class="s1">self.assertRaises(NotImplementedError</span><span class="s3">, </span><span class="s1">soup.insert_after</span><span class="s3">, </span><span class="s1">tag)</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s3">, </span><span class="s1">tag.insert_after</span><span class="s3">, </span><span class="s1">tag)</span>

    <span class="s3">def </span><span class="s1">test_insert_before_raises_notimplementederror_if_before_has_no_meaning(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">tag = soup.new_tag(</span><span class="s4">&quot;a&quot;</span><span class="s1">)</span>
        <span class="s1">string = soup.new_string(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s3">, </span><span class="s1">string.insert_before</span><span class="s3">, </span><span class="s1">tag)</span>
        <span class="s1">self.assertRaises(NotImplementedError</span><span class="s3">, </span><span class="s1">soup.insert_before</span><span class="s3">, </span><span class="s1">tag)</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s3">, </span><span class="s1">tag.insert_before</span><span class="s3">, </span><span class="s1">tag)</span>

    <span class="s3">def </span><span class="s1">test_replace_with(self):</span>
        <span class="s1">soup = self.soup(</span>
                <span class="s4">&quot;&lt;p&gt;There's &lt;b&gt;no&lt;/b&gt; business like &lt;b&gt;show&lt;/b&gt; business&lt;/p&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">no</span><span class="s3">, </span><span class="s1">show = soup.find_all(</span><span class="s4">'b'</span><span class="s1">)</span>
        <span class="s1">show.replace_with(no)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.decode()</span><span class="s3">,</span>
            <span class="s1">self.document_for(</span>
                <span class="s4">&quot;&lt;p&gt;There's  business like &lt;b&gt;no&lt;/b&gt; business&lt;/p&gt;&quot;</span><span class="s1">))</span>

        <span class="s1">self.assertEqual(show.parent</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(no.parent</span><span class="s3">, </span><span class="s1">soup.p)</span>
        <span class="s1">self.assertEqual(no.next_element</span><span class="s3">, </span><span class="s4">&quot;no&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(no.next_sibling</span><span class="s3">, </span><span class="s4">&quot; business&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_replace_first_child(self):</span>
        <span class="s1">data = </span><span class="s4">&quot;&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;c&gt;&lt;/c&gt;&lt;/a&gt;&quot;</span>
        <span class="s1">soup = self.soup(data)</span>
        <span class="s1">soup.b.replace_with(soup.c)</span>
        <span class="s1">self.assertEqual(</span><span class="s4">&quot;&lt;a&gt;&lt;c&gt;&lt;/c&gt;&lt;/a&gt;&quot;</span><span class="s3">, </span><span class="s1">soup.decode())</span>

    <span class="s3">def </span><span class="s1">test_replace_last_child(self):</span>
        <span class="s1">data = </span><span class="s4">&quot;&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;c&gt;&lt;/c&gt;&lt;/a&gt;&quot;</span>
        <span class="s1">soup = self.soup(data)</span>
        <span class="s1">soup.c.replace_with(soup.b)</span>
        <span class="s1">self.assertEqual(</span><span class="s4">&quot;&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;&quot;</span><span class="s3">, </span><span class="s1">soup.decode())</span>

    <span class="s3">def </span><span class="s1">test_nested_tag_replace_with(self):</span>
        <span class="s1">soup = self.soup(</span>
            <span class="s4">&quot;&quot;&quot;&lt;a&gt;We&lt;b&gt;reserve&lt;c&gt;the&lt;/c&gt;&lt;d&gt;right&lt;/d&gt;&lt;/b&gt;&lt;/a&gt;&lt;e&gt;to&lt;f&gt;refuse&lt;/f&gt;&lt;g&gt;service&lt;/g&gt;&lt;/e&gt;&quot;&quot;&quot;</span><span class="s1">)</span>

        <span class="s0"># Replace the entire &lt;b&gt; tag and its contents (&quot;reserve the</span>
        <span class="s0"># right&quot;) with the &lt;f&gt; tag (&quot;refuse&quot;).</span>
        <span class="s1">remove_tag = soup.b</span>
        <span class="s1">move_tag = soup.f</span>
        <span class="s1">remove_tag.replace_with(move_tag)</span>

        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.decode()</span><span class="s3">, </span><span class="s1">self.document_for(</span>
                <span class="s4">&quot;&lt;a&gt;We&lt;f&gt;refuse&lt;/f&gt;&lt;/a&gt;&lt;e&gt;to&lt;g&gt;service&lt;/g&gt;&lt;/e&gt;&quot;</span><span class="s1">))</span>

        <span class="s0"># The &lt;b&gt; tag is now an orphan.</span>
        <span class="s1">self.assertEqual(remove_tag.parent</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(remove_tag.find(text=</span><span class="s4">&quot;right&quot;</span><span class="s1">).next_element</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(remove_tag.previous_element</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(remove_tag.next_sibling</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(remove_tag.previous_sibling</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s0"># The &lt;f&gt; tag is now connected to the &lt;a&gt; tag.</span>
        <span class="s1">self.assertEqual(move_tag.parent</span><span class="s3">, </span><span class="s1">soup.a)</span>
        <span class="s1">self.assertEqual(move_tag.previous_element</span><span class="s3">, </span><span class="s4">&quot;We&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(move_tag.next_element.next_element</span><span class="s3">, </span><span class="s1">soup.e)</span>
        <span class="s1">self.assertEqual(move_tag.next_sibling</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s0"># The gap where the &lt;f&gt; tag used to be has been mended, and</span>
        <span class="s0"># the word &quot;to&quot; is now connected to the &lt;g&gt; tag.</span>
        <span class="s1">to_text = soup.find(text=</span><span class="s4">&quot;to&quot;</span><span class="s1">)</span>
        <span class="s1">g_tag = soup.g</span>
        <span class="s1">self.assertEqual(to_text.next_element</span><span class="s3">, </span><span class="s1">g_tag)</span>
        <span class="s1">self.assertEqual(to_text.next_sibling</span><span class="s3">, </span><span class="s1">g_tag)</span>
        <span class="s1">self.assertEqual(g_tag.previous_element</span><span class="s3">, </span><span class="s1">to_text)</span>
        <span class="s1">self.assertEqual(g_tag.previous_sibling</span><span class="s3">, </span><span class="s1">to_text)</span>

    <span class="s3">def </span><span class="s1">test_unwrap(self):</span>
        <span class="s1">tree = self.soup(</span><span class="s4">&quot;&quot;&quot; 
            &lt;p&gt;Unneeded &lt;em&gt;formatting&lt;/em&gt; is unneeded&lt;/p&gt; 
            &quot;&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">tree.em.unwrap()</span>
        <span class="s1">self.assertEqual(tree.em</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(tree.p.text</span><span class="s3">, </span><span class="s4">&quot;Unneeded formatting is unneeded&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_wrap(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;I wish I was bold.&quot;</span><span class="s1">)</span>
        <span class="s1">value = soup.string.wrap(soup.new_tag(</span><span class="s4">&quot;b&quot;</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(value.decode()</span><span class="s3">, </span><span class="s4">&quot;&lt;b&gt;I wish I was bold.&lt;/b&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.decode()</span><span class="s3">, </span><span class="s1">self.document_for(</span><span class="s4">&quot;&lt;b&gt;I wish I was bold.&lt;/b&gt;&quot;</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_wrap_extracts_tag_from_elsewhere(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;b&gt;&lt;/b&gt;I wish I was bold.&quot;</span><span class="s1">)</span>
        <span class="s1">soup.b.next_sibling.wrap(soup.b)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.decode()</span><span class="s3">, </span><span class="s1">self.document_for(</span><span class="s4">&quot;&lt;b&gt;I wish I was bold.&lt;/b&gt;&quot;</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_wrap_puts_new_contents_at_the_end(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;b&gt;I like being bold.&lt;/b&gt;I wish I was bold.&quot;</span><span class="s1">)</span>
        <span class="s1">soup.b.next_sibling.wrap(soup.b)</span>
        <span class="s1">self.assertEqual(</span><span class="s5">2</span><span class="s3">, </span><span class="s1">len(soup.b.contents))</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.decode()</span><span class="s3">, </span><span class="s1">self.document_for(</span>
                <span class="s4">&quot;&lt;b&gt;I like being bold.I wish I was bold.&lt;/b&gt;&quot;</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_extract(self):</span>
        <span class="s1">soup = self.soup(</span>
            <span class="s4">'&lt;html&gt;&lt;body&gt;Some content. &lt;div id=&quot;nav&quot;&gt;Nav crap&lt;/div&gt; More content.&lt;/body&gt;&lt;/html&gt;'</span><span class="s1">)</span>

        <span class="s1">self.assertEqual(len(soup.body.contents)</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">extracted = soup.find(id=</span><span class="s4">&quot;nav&quot;</span><span class="s1">).extract()</span>

        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.decode()</span><span class="s3">, </span><span class="s4">&quot;&lt;html&gt;&lt;body&gt;Some content.  More content.&lt;/body&gt;&lt;/html&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(extracted.decode()</span><span class="s3">, </span><span class="s4">'&lt;div id=&quot;nav&quot;&gt;Nav crap&lt;/div&gt;'</span><span class="s1">)</span>

        <span class="s0"># The extracted tag is now an orphan.</span>
        <span class="s1">self.assertEqual(len(soup.body.contents)</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(extracted.parent</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(extracted.previous_element</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(extracted.next_element.next_element</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s0"># The gap where the extracted tag used to be has been mended.</span>
        <span class="s1">content_1 = soup.find(text=</span><span class="s4">&quot;Some content. &quot;</span><span class="s1">)</span>
        <span class="s1">content_2 = soup.find(text=</span><span class="s4">&quot; More content.&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(content_1.next_element</span><span class="s3">, </span><span class="s1">content_2)</span>
        <span class="s1">self.assertEqual(content_1.next_sibling</span><span class="s3">, </span><span class="s1">content_2)</span>
        <span class="s1">self.assertEqual(content_2.previous_element</span><span class="s3">, </span><span class="s1">content_1)</span>
        <span class="s1">self.assertEqual(content_2.previous_sibling</span><span class="s3">, </span><span class="s1">content_1)</span>

    <span class="s3">def </span><span class="s1">test_extract_distinguishes_between_identical_strings(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;foo&lt;/a&gt;&lt;b&gt;bar&lt;/b&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">foo_1 = soup.a.string</span>
        <span class="s1">bar_1 = soup.b.string</span>
        <span class="s1">foo_2 = soup.new_string(</span><span class="s4">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">bar_2 = soup.new_string(</span><span class="s4">&quot;bar&quot;</span><span class="s1">)</span>
        <span class="s1">soup.a.append(foo_2)</span>
        <span class="s1">soup.b.append(bar_2)</span>

        <span class="s0"># Now there are two identical strings in the &lt;a&gt; tag, and two</span>
        <span class="s0"># in the &lt;b&gt; tag. Let's remove the first &quot;foo&quot; and the second</span>
        <span class="s0"># &quot;bar&quot;.</span>
        <span class="s1">foo_1.extract()</span>
        <span class="s1">bar_2.extract()</span>
        <span class="s1">self.assertEqual(foo_2</span><span class="s3">, </span><span class="s1">soup.a.string)</span>
        <span class="s1">self.assertEqual(bar_2</span><span class="s3">, </span><span class="s1">soup.b.string)</span>

    <span class="s3">def </span><span class="s1">test_extract_multiples_of_same_tag(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&quot;&quot; 
&lt;html&gt; 
&lt;head&gt; 
&lt;script&gt;foo&lt;/script&gt; 
&lt;/head&gt; 
&lt;body&gt; 
 &lt;script&gt;bar&lt;/script&gt; 
 &lt;a&gt;&lt;/a&gt; 
&lt;/body&gt; 
&lt;script&gt;baz&lt;/script&gt; 
&lt;/html&gt;&quot;&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">[soup.script.extract() </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">soup.find_all(</span><span class="s4">&quot;script&quot;</span><span class="s1">)]</span>
        <span class="s1">self.assertEqual(</span><span class="s4">&quot;&lt;body&gt;</span><span class="s3">\n\n</span><span class="s4">&lt;a&gt;&lt;/a&gt;</span><span class="s3">\n</span><span class="s4">&lt;/body&gt;&quot;</span><span class="s3">, </span><span class="s1">str(soup.body))</span>


    <span class="s3">def </span><span class="s1">test_extract_works_when_element_is_surrounded_by_identical_strings(self):</span>
        <span class="s1">soup = self.soup(</span>
 <span class="s4">'&lt;html&gt;</span><span class="s3">\n</span><span class="s4">'</span>
 <span class="s4">'&lt;body&gt;hi&lt;/body&gt;</span><span class="s3">\n</span><span class="s4">'</span>
 <span class="s4">'&lt;/html&gt;'</span><span class="s1">)</span>
        <span class="s1">soup.find(</span><span class="s4">'body'</span><span class="s1">).extract()</span>
        <span class="s1">self.assertEqual(</span><span class="s3">None, </span><span class="s1">soup.find(</span><span class="s4">'body'</span><span class="s1">))</span>


    <span class="s3">def </span><span class="s1">test_clear(self):</span>
        <span class="s2">&quot;&quot;&quot;Tag.clear()&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;p&gt;&lt;a&gt;String &lt;em&gt;Italicized&lt;/em&gt;&lt;/a&gt; and another&lt;/p&gt;&quot;</span><span class="s1">)</span>
        <span class="s0"># clear using extract()</span>
        <span class="s1">a = soup.a</span>
        <span class="s1">soup.p.clear()</span>
        <span class="s1">self.assertEqual(len(soup.p.contents)</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(hasattr(a</span><span class="s3">, </span><span class="s4">&quot;contents&quot;</span><span class="s1">))</span>

        <span class="s0"># clear using decompose()</span>
        <span class="s1">em = a.em</span>
        <span class="s1">a.clear(decompose=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">len(em.contents))</span>

       
    <span class="s3">def </span><span class="s1">test_decompose(self):</span>
        <span class="s0"># Test PageElement.decompose() and PageElement.decomposed</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;p&gt;&lt;a&gt;String &lt;em&gt;Italicized&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Another para&lt;/p&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">p1</span><span class="s3">, </span><span class="s1">p2 = soup.find_all(</span><span class="s4">'p'</span><span class="s1">)</span>
        <span class="s1">a = p1.a</span>
        <span class="s1">text = p1.em.string</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">[p1</span><span class="s3">, </span><span class="s1">p2</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">text]:</span>
            <span class="s1">self.assertEqual(</span><span class="s3">False, </span><span class="s1">i.decomposed)</span>

        <span class="s0"># This sets p1 and everything beneath it to decomposed.</span>
        <span class="s1">p1.decompose()</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">[p1</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">text]:</span>
            <span class="s1">self.assertEqual(</span><span class="s3">True, </span><span class="s1">i.decomposed)</span>
        <span class="s0"># p2 is unaffected.</span>
        <span class="s1">self.assertEqual(</span><span class="s3">False, </span><span class="s1">p2.decomposed)</span>
            
    <span class="s3">def </span><span class="s1">test_string_set(self):</span>
        <span class="s2">&quot;&quot;&quot;Tag.string = 'string'&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;&lt;/a&gt; &lt;b&gt;&lt;c&gt;&lt;/c&gt;&lt;/b&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">soup.a.string = </span><span class="s4">&quot;foo&quot;</span>
        <span class="s1">self.assertEqual(soup.a.contents</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;foo&quot;</span><span class="s1">])</span>
        <span class="s1">soup.b.string = </span><span class="s4">&quot;bar&quot;</span>
        <span class="s1">self.assertEqual(soup.b.contents</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;bar&quot;</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_string_set_does_not_affect_original_string(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;&lt;b&gt;foo&lt;/b&gt;&lt;c&gt;bar&lt;/c&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">soup.b.string = soup.c.string</span>
        <span class="s1">self.assertEqual(soup.a.encode()</span><span class="s3">, </span><span class="s6">b&quot;&lt;a&gt;&lt;b&gt;bar&lt;/b&gt;&lt;c&gt;bar&lt;/c&gt;&lt;/a&gt;&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_set_string_preserves_class_of_string(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;&lt;/a&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">cdata = CData(</span><span class="s4">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">soup.a.string = cdata</span>
        <span class="s1">self.assertTrue(isinstance(soup.a.string</span><span class="s3">, </span><span class="s1">CData))</span>

<span class="s3">class </span><span class="s1">TestElementObjects(SoupTest):</span>
    <span class="s2">&quot;&quot;&quot;Test various features of element objects.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">test_len(self):</span>
        <span class="s2">&quot;&quot;&quot;The length of an element is its number of children.&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;top&gt;1&lt;b&gt;2&lt;/b&gt;3&lt;/top&gt;&quot;</span><span class="s1">)</span>

        <span class="s0"># The BeautifulSoup object itself contains one element: the</span>
        <span class="s0"># &lt;top&gt; tag.</span>
        <span class="s1">self.assertEqual(len(soup.contents)</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(soup)</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s0"># The &lt;top&gt; tag contains three elements: the text node &quot;1&quot;, the</span>
        <span class="s0"># &lt;b&gt; tag, and the text node &quot;3&quot;.</span>
        <span class="s1">self.assertEqual(len(soup.top)</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(soup.top.contents)</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_member_access_invokes_find(self):</span>
        <span class="s2">&quot;&quot;&quot;Accessing a Python member .foo invokes find('foo')&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(</span><span class="s4">'&lt;b&gt;&lt;i&gt;&lt;/i&gt;&lt;/b&gt;'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(soup.b</span><span class="s3">, </span><span class="s1">soup.find(</span><span class="s4">'b'</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(soup.b.i</span><span class="s3">, </span><span class="s1">soup.find(</span><span class="s4">'b'</span><span class="s1">).find(</span><span class="s4">'i'</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(soup.a</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_deprecated_member_access(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">'&lt;b&gt;&lt;i&gt;&lt;/i&gt;&lt;/b&gt;'</span><span class="s1">)</span>
        <span class="s3">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s3">True</span><span class="s1">) </span><span class="s3">as </span><span class="s1">w:</span>
            <span class="s1">tag = soup.bTag</span>
        <span class="s1">self.assertEqual(soup.b</span><span class="s3">, </span><span class="s1">tag)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s4">'.bTag is deprecated, use .find(&quot;b&quot;) instead. If you really were looking for a tag called bTag, use .find(&quot;bTag&quot;)'</span><span class="s3">,</span>
            <span class="s1">str(w[</span><span class="s5">0</span><span class="s1">].message))</span>

    <span class="s3">def </span><span class="s1">test_has_attr(self):</span>
        <span class="s2">&quot;&quot;&quot;has_attr() checks for the presence of an attribute. 
 
        Please note note: has_attr() is different from 
        __in__. has_attr() checks the tag's attributes and __in__ 
        checks the tag's chidlren. 
        &quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;foo attr='bar'&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(soup.foo.has_attr(</span><span class="s4">'attr'</span><span class="s1">))</span>
        <span class="s1">self.assertFalse(soup.foo.has_attr(</span><span class="s4">'attr2'</span><span class="s1">))</span>


    <span class="s3">def </span><span class="s1">test_attributes_come_out_in_alphabetical_order(self):</span>
        <span class="s1">markup = </span><span class="s4">'&lt;b a=&quot;1&quot; z=&quot;5&quot; m=&quot;3&quot; f=&quot;2&quot; y=&quot;4&quot;&gt;&lt;/b&gt;'</span>
        <span class="s1">self.assertSoupEquals(markup</span><span class="s3">, </span><span class="s4">'&lt;b a=&quot;1&quot; f=&quot;2&quot; m=&quot;3&quot; y=&quot;4&quot; z=&quot;5&quot;&gt;&lt;/b&gt;'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_string(self):</span>
        <span class="s0"># A tag that contains only a text node makes that node</span>
        <span class="s0"># available as .string.</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;b&gt;foo&lt;/b&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(soup.b.string</span><span class="s3">, </span><span class="s4">'foo'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_empty_tag_has_no_string(self):</span>
        <span class="s0"># A tag with no children has no .stirng.</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;b&gt;&lt;/b&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(soup.b.string</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_tag_with_multiple_children_has_no_string(self):</span>
        <span class="s0"># A tag with no children has no .string.</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;foo&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;/b&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(soup.b.string</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;foo&lt;b&gt;&lt;/b&gt;bar&lt;/b&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(soup.b.string</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s0"># Even if all the children are strings, due to trickery,</span>
        <span class="s0"># it won't work--but this would be a good optimization.</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;foo&lt;/b&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">soup.a.insert(</span><span class="s5">1</span><span class="s3">, </span><span class="s4">&quot;bar&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(soup.a.string</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_tag_with_recursive_string_has_string(self):</span>
        <span class="s0"># A tag with a single child which has a .string inherits that</span>
        <span class="s0"># .string.</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;&lt;b&gt;foo&lt;/b&gt;&lt;/a&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(soup.a.string</span><span class="s3">, </span><span class="s4">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(soup.string</span><span class="s3">, </span><span class="s4">&quot;foo&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_lack_of_string(self):</span>
        <span class="s2">&quot;&quot;&quot;Only a tag containing a single text node has a .string.&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;b&gt;f&lt;i&gt;e&lt;/i&gt;o&lt;/b&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(soup.b.string)</span>

        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;b&gt;&lt;/b&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(soup.b.string)</span>

    <span class="s3">def </span><span class="s1">test_all_text(self):</span>
        <span class="s2">&quot;&quot;&quot;Tag.text and Tag.get_text(sep=u&quot;&quot;) -&gt; all child text, concatenated&quot;&quot;&quot;</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;a&lt;b&gt;r&lt;/b&gt;   &lt;r&gt; t &lt;/r&gt;&lt;/a&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(soup.a.text</span><span class="s3">, </span><span class="s4">&quot;ar  t &quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(soup.a.get_text(strip=</span><span class="s3">True</span><span class="s1">)</span><span class="s3">, </span><span class="s4">&quot;art&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(soup.a.get_text(</span><span class="s4">&quot;,&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s4">&quot;a,r, , t &quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(soup.a.get_text(</span><span class="s4">&quot;,&quot;</span><span class="s3">, </span><span class="s1">strip=</span><span class="s3">True</span><span class="s1">)</span><span class="s3">, </span><span class="s4">&quot;a,r,t&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_get_text_ignores_special_string_containers(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;foo&lt;!--IGNORE--&gt;bar&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(soup.get_text()</span><span class="s3">, </span><span class="s4">&quot;foobar&quot;</span><span class="s1">)</span>

        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.get_text(types=(NavigableString</span><span class="s3">, </span><span class="s1">Comment))</span><span class="s3">, </span><span class="s4">&quot;fooIGNOREbar&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.get_text(types=</span><span class="s3">None</span><span class="s1">)</span><span class="s3">, </span><span class="s4">&quot;fooIGNOREbar&quot;</span><span class="s1">)</span>

        <span class="s1">soup = self.soup(</span><span class="s4">&quot;foo&lt;style&gt;CSS&lt;/style&gt;&lt;script&gt;Javascript&lt;/script&gt;bar&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(soup.get_text()</span><span class="s3">, </span><span class="s4">&quot;foobar&quot;</span><span class="s1">)</span>
        
    <span class="s3">def </span><span class="s1">test_all_strings_ignores_special_string_containers(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;foo&lt;!--IGNORE--&gt;bar&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual([</span><span class="s4">'foo'</span><span class="s3">, </span><span class="s4">'bar'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">list(soup.strings))</span>

        <span class="s1">soup = self.soup(</span><span class="s4">&quot;foo&lt;style&gt;CSS&lt;/style&gt;&lt;script&gt;Javascript&lt;/script&gt;bar&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual([</span><span class="s4">'foo'</span><span class="s3">, </span><span class="s4">'bar'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">list(soup.strings))</span>


<span class="s3">class </span><span class="s1">TestCDAtaListAttributes(SoupTest):</span>

    <span class="s2">&quot;&quot;&quot;Testing cdata-list attributes like 'class'. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">test_single_value_becomes_list(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a class='foo'&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual([</span><span class="s4">&quot;foo&quot;</span><span class="s1">]</span><span class="s3">,</span><span class="s1">soup.a[</span><span class="s4">'class'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_multiple_values_becomes_list(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a class='foo bar'&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual([</span><span class="s4">&quot;foo&quot;</span><span class="s3">, </span><span class="s4">&quot;bar&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">soup.a[</span><span class="s4">'class'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_multiple_values_separated_by_weird_whitespace(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a class='foo</span><span class="s3">\t</span><span class="s4">bar</span><span class="s3">\n</span><span class="s4">baz'&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual([</span><span class="s4">&quot;foo&quot;</span><span class="s3">, </span><span class="s4">&quot;bar&quot;</span><span class="s3">, </span><span class="s4">&quot;baz&quot;</span><span class="s1">]</span><span class="s3">,</span><span class="s1">soup.a[</span><span class="s4">'class'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_attributes_joined_into_string_on_output(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a class='foo</span><span class="s3">\t</span><span class="s4">bar'&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span><span class="s6">b'&lt;a class=&quot;foo bar&quot;&gt;&lt;/a&gt;'</span><span class="s3">, </span><span class="s1">soup.a.encode())</span>

    <span class="s3">def </span><span class="s1">test_get_attribute_list(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a id='abc def'&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual([</span><span class="s4">'abc def'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">soup.a.get_attribute_list(</span><span class="s4">'id'</span><span class="s1">))</span>
        
    <span class="s3">def </span><span class="s1">test_accept_charset(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">'&lt;form accept-charset=&quot;ISO-8859-1 UTF-8&quot;&gt;'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual([</span><span class="s4">'ISO-8859-1'</span><span class="s3">, </span><span class="s4">'UTF-8'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">soup.form[</span><span class="s4">'accept-charset'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_cdata_attribute_applying_only_to_one_tag(self):</span>
        <span class="s1">data = </span><span class="s4">'&lt;a accept-charset=&quot;ISO-8859-1 UTF-8&quot;&gt;&lt;/a&gt;'</span>
        <span class="s1">soup = self.soup(data)</span>
        <span class="s0"># We saw in another test that accept-charset is a cdata-list</span>
        <span class="s0"># attribute for the &lt;form&gt; tag. But it's not a cdata-list</span>
        <span class="s0"># attribute for any other tag.</span>
        <span class="s1">self.assertEqual(</span><span class="s4">'ISO-8859-1 UTF-8'</span><span class="s3">, </span><span class="s1">soup.a[</span><span class="s4">'accept-charset'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_string_has_immutable_name_property(self):</span>
        <span class="s1">string = self.soup(</span><span class="s4">&quot;s&quot;</span><span class="s1">).string</span>
        <span class="s1">self.assertEqual(</span><span class="s3">None, </span><span class="s1">string.name)</span>
        <span class="s3">def </span><span class="s1">t():</span>
            <span class="s1">string.name = </span><span class="s4">'foo'</span>
        <span class="s1">self.assertRaises(AttributeError</span><span class="s3">, </span><span class="s1">t)</span>

<span class="s3">class </span><span class="s1">TestPersistence(SoupTest):</span>
    <span class="s2">&quot;Testing features like pickle and deepcopy.&quot;</span>

    <span class="s3">def </span><span class="s1">setUp(self):</span>
        <span class="s1">super(TestPersistence</span><span class="s3">, </span><span class="s1">self).setUp()</span>
        <span class="s1">self.page = </span><span class="s4">&quot;&quot;&quot;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot; 
&quot;http://www.w3.org/TR/REC-html40/transitional.dtd&quot;&gt; 
&lt;html&gt; 
&lt;head&gt; 
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; 
&lt;title&gt;Beautiful Soup: We called him Tortoise because he taught us.&lt;/title&gt; 
&lt;link rev=&quot;made&quot; href=&quot;mailto:leonardr@segfault.org&quot;&gt; 
&lt;meta name=&quot;Description&quot; content=&quot;Beautiful Soup: an HTML parser optimized for screen-scraping.&quot;&gt; 
&lt;meta name=&quot;generator&quot; content=&quot;Markov Approximation 1.4 (module: leonardr)&quot;&gt; 
&lt;meta name=&quot;author&quot; content=&quot;Leonard Richardson&quot;&gt; 
&lt;/head&gt; 
&lt;body&gt; 
&lt;a href=&quot;foo&quot;&gt;foo&lt;/a&gt; 
&lt;a href=&quot;foo&quot;&gt;&lt;b&gt;bar&lt;/b&gt;&lt;/a&gt; 
&lt;/body&gt; 
&lt;/html&gt;&quot;&quot;&quot;</span>
        <span class="s1">self.tree = self.soup(self.page)</span>

    <span class="s3">def </span><span class="s1">test_pickle_and_unpickle_identity(self):</span>
        <span class="s0"># Pickling a tree, then unpickling it, yields a tree identical</span>
        <span class="s0"># to the original.</span>
        <span class="s1">dumped = pickle.dumps(self.tree</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">loaded = pickle.loads(dumped)</span>
        <span class="s1">self.assertEqual(loaded.__class__</span><span class="s3">, </span><span class="s1">BeautifulSoup)</span>
        <span class="s1">self.assertEqual(loaded.decode()</span><span class="s3">, </span><span class="s1">self.tree.decode())</span>

    <span class="s3">def </span><span class="s1">test_deepcopy_identity(self):</span>
        <span class="s0"># Making a deepcopy of a tree yields an identical tree.</span>
        <span class="s1">copied = copy.deepcopy(self.tree)</span>
        <span class="s1">self.assertEqual(copied.decode()</span><span class="s3">, </span><span class="s1">self.tree.decode())</span>

    <span class="s3">def </span><span class="s1">test_copy_preserves_encoding(self):</span>
        <span class="s1">soup = BeautifulSoup(</span><span class="s6">b'&lt;p&gt;&amp;nbsp;&lt;/p&gt;'</span><span class="s3">, </span><span class="s4">'html.parser'</span><span class="s1">)</span>
        <span class="s1">encoding = soup.original_encoding</span>
        <span class="s1">copy = soup.__copy__()</span>
        <span class="s1">self.assertEqual(</span><span class="s4">&quot;&lt;p&gt; &lt;/p&gt;&quot;</span><span class="s3">, </span><span class="s1">str(copy))</span>
        <span class="s1">self.assertEqual(encoding</span><span class="s3">, </span><span class="s1">copy.original_encoding)</span>

    <span class="s3">def </span><span class="s1">test_copy_preserves_builder_information(self):</span>

        <span class="s1">tag = self.soup(</span><span class="s4">'&lt;p&gt;&lt;/p&gt;'</span><span class="s1">).p</span>

        <span class="s0"># Simulate a tag obtained from a source file.</span>
        <span class="s1">tag.sourceline = </span><span class="s5">10</span>
        <span class="s1">tag.sourcepos = </span><span class="s5">33</span>
        
        <span class="s1">copied = tag.__copy__()</span>

        <span class="s0"># The TreeBuilder object is no longer availble, but information</span>
        <span class="s0"># obtained from it gets copied over to the new Tag object.</span>
        <span class="s1">self.assertEqual(tag.sourceline</span><span class="s3">, </span><span class="s1">copied.sourceline)</span>
        <span class="s1">self.assertEqual(tag.sourcepos</span><span class="s3">, </span><span class="s1">copied.sourcepos)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">tag.can_be_empty_element</span><span class="s3">, </span><span class="s1">copied.can_be_empty_element</span>
        <span class="s1">)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">tag.cdata_list_attributes</span><span class="s3">, </span><span class="s1">copied.cdata_list_attributes</span>
        <span class="s1">)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">tag.preserve_whitespace_tags</span><span class="s3">, </span><span class="s1">copied.preserve_whitespace_tags</span>
        <span class="s1">)</span>
        
        
    <span class="s3">def </span><span class="s1">test_unicode_pickle(self):</span>
        <span class="s0"># A tree containing Unicode characters can be pickled.</span>
        <span class="s1">html = </span><span class="s4">&quot;&lt;b&gt;</span><span class="s3">\N{SNOWMAN}</span><span class="s4">&lt;/b&gt;&quot;</span>
        <span class="s1">soup = self.soup(html)</span>
        <span class="s1">dumped = pickle.dumps(soup</span><span class="s3">, </span><span class="s1">pickle.HIGHEST_PROTOCOL)</span>
        <span class="s1">loaded = pickle.loads(dumped)</span>
        <span class="s1">self.assertEqual(loaded.decode()</span><span class="s3">, </span><span class="s1">soup.decode())</span>

    <span class="s3">def </span><span class="s1">test_copy_navigablestring_is_not_attached_to_tree(self):</span>
        <span class="s1">html = </span><span class="s4">&quot;&lt;b&gt;Foo&lt;a&gt;&lt;/a&gt;&lt;/b&gt;&lt;b&gt;Bar&lt;/b&gt;&quot;</span>
        <span class="s1">soup = self.soup(html)</span>
        <span class="s1">s1 = soup.find(string=</span><span class="s4">&quot;Foo&quot;</span><span class="s1">)</span>
        <span class="s1">s2 = copy.copy(s1)</span>
        <span class="s1">self.assertEqual(s1</span><span class="s3">, </span><span class="s1">s2)</span>
        <span class="s1">self.assertEqual(</span><span class="s3">None, </span><span class="s1">s2.parent)</span>
        <span class="s1">self.assertEqual(</span><span class="s3">None, </span><span class="s1">s2.next_element)</span>
        <span class="s1">self.assertNotEqual(</span><span class="s3">None, </span><span class="s1">s1.next_sibling)</span>
        <span class="s1">self.assertEqual(</span><span class="s3">None, </span><span class="s1">s2.next_sibling)</span>
        <span class="s1">self.assertEqual(</span><span class="s3">None, </span><span class="s1">s2.previous_element)</span>

    <span class="s3">def </span><span class="s1">test_copy_navigablestring_subclass_has_same_type(self):</span>
        <span class="s1">html = </span><span class="s4">&quot;&lt;b&gt;&lt;!--Foo--&gt;&lt;/b&gt;&quot;</span>
        <span class="s1">soup = self.soup(html)</span>
        <span class="s1">s1 = soup.string</span>
        <span class="s1">s2 = copy.copy(s1)</span>
        <span class="s1">self.assertEqual(s1</span><span class="s3">, </span><span class="s1">s2)</span>
        <span class="s1">self.assertTrue(isinstance(s2</span><span class="s3">, </span><span class="s1">Comment))</span>

    <span class="s3">def </span><span class="s1">test_copy_entire_soup(self):</span>
        <span class="s1">html = </span><span class="s4">&quot;&lt;div&gt;&lt;b&gt;Foo&lt;a&gt;&lt;/a&gt;&lt;/b&gt;&lt;b&gt;Bar&lt;/b&gt;&lt;/div&gt;end&quot;</span>
        <span class="s1">soup = self.soup(html)</span>
        <span class="s1">soup_copy = copy.copy(soup)</span>
        <span class="s1">self.assertEqual(soup</span><span class="s3">, </span><span class="s1">soup_copy)</span>

    <span class="s3">def </span><span class="s1">test_copy_tag_copies_contents(self):</span>
        <span class="s1">html = </span><span class="s4">&quot;&lt;div&gt;&lt;b&gt;Foo&lt;a&gt;&lt;/a&gt;&lt;/b&gt;&lt;b&gt;Bar&lt;/b&gt;&lt;/div&gt;end&quot;</span>
        <span class="s1">soup = self.soup(html)</span>
        <span class="s1">div = soup.div</span>
        <span class="s1">div_copy = copy.copy(div)</span>

        <span class="s0"># The two tags look the same, and evaluate to equal.</span>
        <span class="s1">self.assertEqual(str(div)</span><span class="s3">, </span><span class="s1">str(div_copy))</span>
        <span class="s1">self.assertEqual(div</span><span class="s3">, </span><span class="s1">div_copy)</span>

        <span class="s0"># But they're not the same object.</span>
        <span class="s1">self.assertFalse(div </span><span class="s3">is </span><span class="s1">div_copy)</span>

        <span class="s0"># And they don't have the same relation to the parse tree. The</span>
        <span class="s0"># copy is not associated with a parse tree at all.</span>
        <span class="s1">self.assertEqual(</span><span class="s3">None, </span><span class="s1">div_copy.parent)</span>
        <span class="s1">self.assertEqual(</span><span class="s3">None, </span><span class="s1">div_copy.previous_element)</span>
        <span class="s1">self.assertEqual(</span><span class="s3">None, </span><span class="s1">div_copy.find(string=</span><span class="s4">'Bar'</span><span class="s1">).next_element)</span>
        <span class="s1">self.assertNotEqual(</span><span class="s3">None, </span><span class="s1">div.find(string=</span><span class="s4">'Bar'</span><span class="s1">).next_element)</span>

<span class="s3">class </span><span class="s1">TestSubstitutions(SoupTest):</span>

    <span class="s3">def </span><span class="s1">test_default_formatter_is_minimal(self):</span>
        <span class="s1">markup = </span><span class="s4">&quot;&lt;b&gt;&amp;lt;&amp;lt;Sacr</span><span class="s3">\N{LATIN SMALL LETTER E WITH ACUTE} </span><span class="s4">bleu!&amp;gt;&amp;gt;&lt;/b&gt;&quot;</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">decoded = soup.decode(formatter=</span><span class="s4">&quot;minimal&quot;</span><span class="s1">)</span>
        <span class="s0"># The &lt; is converted back into &amp;lt; but the e-with-acute is left alone.</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">decoded</span><span class="s3">,</span>
            <span class="s1">self.document_for(</span>
                <span class="s4">&quot;&lt;b&gt;&amp;lt;&amp;lt;Sacr</span><span class="s3">\N{LATIN SMALL LETTER E WITH ACUTE} </span><span class="s4">bleu!&amp;gt;&amp;gt;&lt;/b&gt;&quot;</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_formatter_html(self):</span>
        <span class="s1">markup = </span><span class="s4">&quot;&lt;br&gt;&lt;b&gt;&amp;lt;&amp;lt;Sacr</span><span class="s3">\N{LATIN SMALL LETTER E WITH ACUTE} </span><span class="s4">bleu!&amp;gt;&amp;gt;&lt;/b&gt;&quot;</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">decoded = soup.decode(formatter=</span><span class="s4">&quot;html&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">decoded</span><span class="s3">,</span>
            <span class="s1">self.document_for(</span><span class="s4">&quot;&lt;br/&gt;&lt;b&gt;&amp;lt;&amp;lt;Sacr&amp;eacute; bleu!&amp;gt;&amp;gt;&lt;/b&gt;&quot;</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_formatter_html5(self):</span>
        <span class="s1">markup = </span><span class="s4">&quot;&lt;br&gt;&lt;b&gt;&amp;lt;&amp;lt;Sacr</span><span class="s3">\N{LATIN SMALL LETTER E WITH ACUTE} </span><span class="s4">bleu!&amp;gt;&amp;gt;&lt;/b&gt;&quot;</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">decoded = soup.decode(formatter=</span><span class="s4">&quot;html5&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">decoded</span><span class="s3">,</span>
            <span class="s1">self.document_for(</span><span class="s4">&quot;&lt;br&gt;&lt;b&gt;&amp;lt;&amp;lt;Sacr&amp;eacute; bleu!&amp;gt;&amp;gt;&lt;/b&gt;&quot;</span><span class="s1">))</span>
        
    <span class="s3">def </span><span class="s1">test_formatter_minimal(self):</span>
        <span class="s1">markup = </span><span class="s4">&quot;&lt;b&gt;&amp;lt;&amp;lt;Sacr</span><span class="s3">\N{LATIN SMALL LETTER E WITH ACUTE} </span><span class="s4">bleu!&amp;gt;&amp;gt;&lt;/b&gt;&quot;</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">decoded = soup.decode(formatter=</span><span class="s4">&quot;minimal&quot;</span><span class="s1">)</span>
        <span class="s0"># The &lt; is converted back into &amp;lt; but the e-with-acute is left alone.</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">decoded</span><span class="s3">,</span>
            <span class="s1">self.document_for(</span>
                <span class="s4">&quot;&lt;b&gt;&amp;lt;&amp;lt;Sacr</span><span class="s3">\N{LATIN SMALL LETTER E WITH ACUTE} </span><span class="s4">bleu!&amp;gt;&amp;gt;&lt;/b&gt;&quot;</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_formatter_null(self):</span>
        <span class="s1">markup = </span><span class="s4">&quot;&lt;b&gt;&amp;lt;&amp;lt;Sacr</span><span class="s3">\N{LATIN SMALL LETTER E WITH ACUTE} </span><span class="s4">bleu!&amp;gt;&amp;gt;&lt;/b&gt;&quot;</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">decoded = soup.decode(formatter=</span><span class="s3">None</span><span class="s1">)</span>
        <span class="s0"># Neither the angle brackets nor the e-with-acute are converted.</span>
        <span class="s0"># This is not valid HTML, but it's what the user wanted.</span>
        <span class="s1">self.assertEqual(decoded</span><span class="s3">,</span>
                          <span class="s1">self.document_for(</span><span class="s4">&quot;&lt;b&gt;&lt;&lt;Sacr</span><span class="s3">\N{LATIN SMALL LETTER E WITH ACUTE} </span><span class="s4">bleu!&gt;&gt;&lt;/b&gt;&quot;</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_formatter_custom(self):</span>
        <span class="s1">markup = </span><span class="s4">&quot;&lt;b&gt;&amp;lt;foo&amp;gt;&lt;/b&gt;&lt;b&gt;bar&lt;/b&gt;&lt;br/&gt;&quot;</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">decoded = soup.decode(formatter = </span><span class="s3">lambda </span><span class="s1">x: x.upper())</span>
        <span class="s0"># Instead of normal entity conversion code, the custom</span>
        <span class="s0"># callable is called on every string.</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">decoded</span><span class="s3">,</span>
            <span class="s1">self.document_for(</span><span class="s4">&quot;&lt;b&gt;&lt;FOO&gt;&lt;/b&gt;&lt;b&gt;BAR&lt;/b&gt;&lt;br/&gt;&quot;</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_formatter_is_run_on_attribute_values(self):</span>
        <span class="s1">markup = </span><span class="s4">'&lt;a href=&quot;http://a.com?a=b&amp;c=é&quot;&gt;e&lt;/a&gt;'</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">a = soup.a</span>

        <span class="s1">expect_minimal = </span><span class="s4">'&lt;a href=&quot;http://a.com?a=b&amp;amp;c=é&quot;&gt;e&lt;/a&gt;'</span>

        <span class="s1">self.assertEqual(expect_minimal</span><span class="s3">, </span><span class="s1">a.decode())</span>
        <span class="s1">self.assertEqual(expect_minimal</span><span class="s3">, </span><span class="s1">a.decode(formatter=</span><span class="s4">&quot;minimal&quot;</span><span class="s1">))</span>

        <span class="s1">expect_html = </span><span class="s4">'&lt;a href=&quot;http://a.com?a=b&amp;amp;c=&amp;eacute;&quot;&gt;e&lt;/a&gt;'</span>
        <span class="s1">self.assertEqual(expect_html</span><span class="s3">, </span><span class="s1">a.decode(formatter=</span><span class="s4">&quot;html&quot;</span><span class="s1">))</span>

        <span class="s1">self.assertEqual(markup</span><span class="s3">, </span><span class="s1">a.decode(formatter=</span><span class="s3">None</span><span class="s1">))</span>
        <span class="s1">expect_upper = </span><span class="s4">'&lt;a href=&quot;HTTP://A.COM?A=B&amp;C=É&quot;&gt;E&lt;/a&gt;'</span>
        <span class="s1">self.assertEqual(expect_upper</span><span class="s3">, </span><span class="s1">a.decode(formatter=</span><span class="s3">lambda </span><span class="s1">x: x.upper()))</span>

    <span class="s3">def </span><span class="s1">test_formatter_skips_script_tag_for_html_documents(self):</span>
        <span class="s1">doc = </span><span class="s4">&quot;&quot;&quot; 
  &lt;script type=&quot;text/javascript&quot;&gt; 
   console.log(&quot;&lt; &lt; hey &gt; &gt; &quot;); 
  &lt;/script&gt; 
&quot;&quot;&quot;</span>
        <span class="s1">encoded = BeautifulSoup(doc</span><span class="s3">, </span><span class="s4">'html.parser'</span><span class="s1">).encode()</span>
        <span class="s1">self.assertTrue(</span><span class="s6">b&quot;&lt; &lt; hey &gt; &gt;&quot; </span><span class="s3">in </span><span class="s1">encoded)</span>

    <span class="s3">def </span><span class="s1">test_formatter_skips_style_tag_for_html_documents(self):</span>
        <span class="s1">doc = </span><span class="s4">&quot;&quot;&quot; 
  &lt;style type=&quot;text/css&quot;&gt; 
   console.log(&quot;&lt; &lt; hey &gt; &gt; &quot;); 
  &lt;/style&gt; 
&quot;&quot;&quot;</span>
        <span class="s1">encoded = BeautifulSoup(doc</span><span class="s3">, </span><span class="s4">'html.parser'</span><span class="s1">).encode()</span>
        <span class="s1">self.assertTrue(</span><span class="s6">b&quot;&lt; &lt; hey &gt; &gt;&quot; </span><span class="s3">in </span><span class="s1">encoded)</span>

    <span class="s3">def </span><span class="s1">test_prettify_leaves_preformatted_text_alone(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;div&gt;  foo  &lt;pre&gt;  </span><span class="s3">\t</span><span class="s4">bar</span><span class="s3">\n  \n  </span><span class="s4">&lt;/pre&gt;  baz  &lt;textarea&gt; eee</span><span class="s3">\n</span><span class="s4">fff</span><span class="s3">\t</span><span class="s4">&lt;/textarea&gt;&lt;/div&gt;&quot;</span><span class="s1">)</span>
        <span class="s0"># Everything outside the &lt;pre&gt; tag is reformatted, but everything</span>
        <span class="s0"># inside is left alone.</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s4">'&lt;div&gt;</span><span class="s3">\n </span><span class="s4">foo</span><span class="s3">\n </span><span class="s4">&lt;pre&gt;  </span><span class="s3">\t</span><span class="s4">bar</span><span class="s3">\n  \n  </span><span class="s4">&lt;/pre&gt;</span><span class="s3">\n </span><span class="s4">baz</span><span class="s3">\n </span><span class="s4">&lt;textarea&gt; eee</span><span class="s3">\n</span><span class="s4">fff</span><span class="s3">\t</span><span class="s4">&lt;/textarea&gt;</span><span class="s3">\n</span><span class="s4">&lt;/div&gt;'</span><span class="s3">,</span>
            <span class="s1">soup.div.prettify())</span>

    <span class="s3">def </span><span class="s1">test_prettify_accepts_formatter_function(self):</span>
        <span class="s1">soup = BeautifulSoup(</span><span class="s4">&quot;&lt;html&gt;&lt;body&gt;foo&lt;/body&gt;&lt;/html&gt;&quot;</span><span class="s3">, </span><span class="s4">'html.parser'</span><span class="s1">)</span>
        <span class="s1">pretty = soup.prettify(formatter = </span><span class="s3">lambda </span><span class="s1">x: x.upper())</span>
        <span class="s1">self.assertTrue(</span><span class="s4">&quot;FOO&quot; </span><span class="s3">in </span><span class="s1">pretty)</span>

    <span class="s3">def </span><span class="s1">test_prettify_outputs_unicode_by_default(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;&lt;/a&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(str</span><span class="s3">, </span><span class="s1">type(soup.prettify()))</span>

    <span class="s3">def </span><span class="s1">test_prettify_can_encode_data(self):</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&lt;a&gt;&lt;/a&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(bytes</span><span class="s3">, </span><span class="s1">type(soup.prettify(</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">)))</span>

    <span class="s3">def </span><span class="s1">test_html_entity_substitution_off_by_default(self):</span>
        <span class="s1">markup = </span><span class="s4">&quot;&lt;b&gt;Sacr</span><span class="s3">\N{LATIN SMALL LETTER E WITH ACUTE} </span><span class="s4">bleu!&lt;/b&gt;&quot;</span>
        <span class="s1">soup = self.soup(markup)</span>
        <span class="s1">encoded = soup.b.encode(</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(encoded</span><span class="s3">, </span><span class="s1">markup.encode(</span><span class="s4">'utf-8'</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_encoding_substitution(self):</span>
        <span class="s0"># Here's the &lt;meta&gt; tag saying that a document is</span>
        <span class="s0"># encoded in Shift-JIS.</span>
        <span class="s1">meta_tag = (</span><span class="s4">'&lt;meta content=&quot;text/html; charset=x-sjis&quot; '</span>
                    <span class="s4">'http-equiv=&quot;Content-type&quot;/&gt;'</span><span class="s1">)</span>
        <span class="s1">soup = self.soup(meta_tag)</span>

        <span class="s0"># Parse the document, and the charset apprears unchanged.</span>
        <span class="s1">self.assertEqual(soup.meta[</span><span class="s4">'content'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'text/html; charset=x-sjis'</span><span class="s1">)</span>

        <span class="s0"># Encode the document into some encoding, and the encoding is</span>
        <span class="s0"># substituted into the meta tag.</span>
        <span class="s1">utf_8 = soup.encode(</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(</span><span class="s6">b&quot;charset=utf-8&quot; </span><span class="s3">in </span><span class="s1">utf_8)</span>

        <span class="s1">euc_jp = soup.encode(</span><span class="s4">&quot;euc_jp&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(</span><span class="s6">b&quot;charset=euc_jp&quot; </span><span class="s3">in </span><span class="s1">euc_jp)</span>

        <span class="s1">shift_jis = soup.encode(</span><span class="s4">&quot;shift-jis&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(</span><span class="s6">b&quot;charset=shift-jis&quot; </span><span class="s3">in </span><span class="s1">shift_jis)</span>

        <span class="s1">utf_16_u = soup.encode(</span><span class="s4">&quot;utf-16&quot;</span><span class="s1">).decode(</span><span class="s4">&quot;utf-16&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(</span><span class="s4">&quot;charset=utf-16&quot; </span><span class="s3">in </span><span class="s1">utf_16_u)</span>

    <span class="s3">def </span><span class="s1">test_encoding_substitution_doesnt_happen_if_tag_is_strained(self):</span>
        <span class="s1">markup = (</span><span class="s4">'&lt;head&gt;&lt;meta content=&quot;text/html; charset=x-sjis&quot; '</span>
                    <span class="s4">'http-equiv=&quot;Content-type&quot;/&gt;&lt;/head&gt;&lt;pre&gt;foo&lt;/pre&gt;'</span><span class="s1">)</span>

        <span class="s0"># Beautiful Soup used to try to rewrite the meta tag even if the</span>
        <span class="s0"># meta tag got filtered out by the strainer. This test makes</span>
        <span class="s0"># sure that doesn't happen.</span>
        <span class="s1">strainer = SoupStrainer(</span><span class="s4">'pre'</span><span class="s1">)</span>
        <span class="s1">soup = self.soup(markup</span><span class="s3">, </span><span class="s1">parse_only=strainer)</span>
        <span class="s1">self.assertEqual(soup.contents[</span><span class="s5">0</span><span class="s1">].name</span><span class="s3">, </span><span class="s4">'pre'</span><span class="s1">)</span>

<span class="s3">class </span><span class="s1">TestEncoding(SoupTest):</span>
    <span class="s2">&quot;&quot;&quot;Test the ability to encode objects into strings.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">test_unicode_string_can_be_encoded(self):</span>
        <span class="s1">html = </span><span class="s4">&quot;&lt;b&gt;</span><span class="s3">\N{SNOWMAN}</span><span class="s4">&lt;/b&gt;&quot;</span>
        <span class="s1">soup = self.soup(html)</span>
        <span class="s1">self.assertEqual(soup.b.string.encode(</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">)</span><span class="s3">,</span>
                          <span class="s4">&quot;</span><span class="s3">\N{SNOWMAN}</span><span class="s4">&quot;</span><span class="s1">.encode(</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_tag_containing_unicode_string_can_be_encoded(self):</span>
        <span class="s1">html = </span><span class="s4">&quot;&lt;b&gt;</span><span class="s3">\N{SNOWMAN}</span><span class="s4">&lt;/b&gt;&quot;</span>
        <span class="s1">soup = self.soup(html)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">soup.b.encode(</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">html.encode(</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_encoding_substitutes_unrecognized_characters_by_default(self):</span>
        <span class="s1">html = </span><span class="s4">&quot;&lt;b&gt;</span><span class="s3">\N{SNOWMAN}</span><span class="s4">&lt;/b&gt;&quot;</span>
        <span class="s1">soup = self.soup(html)</span>
        <span class="s1">self.assertEqual(soup.b.encode(</span><span class="s4">&quot;ascii&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s6">b&quot;&lt;b&gt;&amp;#9731;&lt;/b&gt;&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_encoding_can_be_made_strict(self):</span>
        <span class="s1">html = </span><span class="s4">&quot;&lt;b&gt;</span><span class="s3">\N{SNOWMAN}</span><span class="s4">&lt;/b&gt;&quot;</span>
        <span class="s1">soup = self.soup(html)</span>
        <span class="s1">self.assertRaises(</span>
            <span class="s1">UnicodeEncodeError</span><span class="s3">, </span><span class="s1">soup.encode</span><span class="s3">, </span><span class="s4">&quot;ascii&quot;</span><span class="s3">, </span><span class="s1">errors=</span><span class="s4">&quot;strict&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_decode_contents(self):</span>
        <span class="s1">html = </span><span class="s4">&quot;&lt;b&gt;</span><span class="s3">\N{SNOWMAN}</span><span class="s4">&lt;/b&gt;&quot;</span>
        <span class="s1">soup = self.soup(html)</span>
        <span class="s1">self.assertEqual(</span><span class="s4">&quot;</span><span class="s3">\N{SNOWMAN}</span><span class="s4">&quot;</span><span class="s3">, </span><span class="s1">soup.b.decode_contents())</span>

    <span class="s3">def </span><span class="s1">test_encode_contents(self):</span>
        <span class="s1">html = </span><span class="s4">&quot;&lt;b&gt;</span><span class="s3">\N{SNOWMAN}</span><span class="s4">&lt;/b&gt;&quot;</span>
        <span class="s1">soup = self.soup(html)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s4">&quot;</span><span class="s3">\N{SNOWMAN}</span><span class="s4">&quot;</span><span class="s1">.encode(</span><span class="s4">&quot;utf8&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">soup.b.encode_contents(</span>
                <span class="s1">encoding=</span><span class="s4">&quot;utf8&quot;</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_deprecated_renderContents(self):</span>
        <span class="s1">html = </span><span class="s4">&quot;&lt;b&gt;</span><span class="s3">\N{SNOWMAN}</span><span class="s4">&lt;/b&gt;&quot;</span>
        <span class="s1">soup = self.soup(html)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s4">&quot;</span><span class="s3">\N{SNOWMAN}</span><span class="s4">&quot;</span><span class="s1">.encode(</span><span class="s4">&quot;utf8&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">soup.b.renderContents())</span>

    <span class="s3">def </span><span class="s1">test_repr(self):</span>
        <span class="s1">html = </span><span class="s4">&quot;&lt;b&gt;</span><span class="s3">\N{SNOWMAN}</span><span class="s4">&lt;/b&gt;&quot;</span>
        <span class="s1">soup = self.soup(html)</span>
        <span class="s3">if </span><span class="s1">PY3K:</span>
            <span class="s1">self.assertEqual(html</span><span class="s3">, </span><span class="s1">repr(soup))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.assertEqual(</span><span class="s6">b'&lt;b&gt;</span><span class="s3">\\</span><span class="s6">u2603&lt;/b&gt;'</span><span class="s3">, </span><span class="s1">repr(soup))</span>

<span class="s3">class </span><span class="s1">TestFormatter(SoupTest):</span>

    <span class="s3">def </span><span class="s1">test_default_attributes(self):</span>
        <span class="s0"># Test the default behavior of Formatter.attributes().</span>
        <span class="s1">formatter = Formatter()</span>
        <span class="s1">tag = Tag(name=</span><span class="s4">&quot;tag&quot;</span><span class="s1">)</span>
        <span class="s1">tag[</span><span class="s4">'b'</span><span class="s1">] = </span><span class="s5">1</span>
        <span class="s1">tag[</span><span class="s4">'a'</span><span class="s1">] = </span><span class="s5">2</span>

        <span class="s0"># Attributes come out sorted by name. In Python 3, attributes</span>
        <span class="s0"># normally come out of a dictionary in the order they were</span>
        <span class="s0"># added.</span>
        <span class="s1">self.assertEqual([(</span><span class="s4">'a'</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">'b'</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)]</span><span class="s3">, </span><span class="s1">formatter.attributes(tag))</span>

        <span class="s0"># This works even if Tag.attrs is None, though this shouldn't</span>
        <span class="s0"># normally happen.</span>
        <span class="s1">tag.attrs = </span><span class="s3">None</span>
        <span class="s1">self.assertEqual([]</span><span class="s3">, </span><span class="s1">formatter.attributes(tag))</span>
        
    <span class="s3">def </span><span class="s1">test_sort_attributes(self):</span>
        <span class="s0"># Test the ability to override Formatter.attributes() to,</span>
        <span class="s0"># e.g., disable the normal sorting of attributes.</span>
        <span class="s3">class </span><span class="s1">UnsortedFormatter(Formatter):</span>
            <span class="s3">def </span><span class="s1">attributes(self</span><span class="s3">, </span><span class="s1">tag):</span>
                <span class="s1">self.called_with = tag</span>
                <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">sorted(tag.attrs.items()):</span>
                    <span class="s3">if </span><span class="s1">k == </span><span class="s4">'ignore'</span><span class="s1">:</span>
                        <span class="s3">continue</span>
                    <span class="s3">yield </span><span class="s1">k</span><span class="s3">,</span><span class="s1">v</span>

        <span class="s1">soup = self.soup(</span><span class="s4">'&lt;p cval=&quot;1&quot; aval=&quot;2&quot; ignore=&quot;ignored&quot;&gt;&lt;/p&gt;'</span><span class="s1">)</span>
        <span class="s1">formatter = UnsortedFormatter()</span>
        <span class="s1">decoded = soup.decode(formatter=formatter)</span>

        <span class="s0"># attributes() was called on the &lt;p&gt; tag. It filtered out one</span>
        <span class="s0"># attribute and sorted the other two.</span>
        <span class="s1">self.assertEqual(formatter.called_with</span><span class="s3">, </span><span class="s1">soup.p)</span>
        <span class="s1">self.assertEqual(</span><span class="s4">'&lt;p aval=&quot;2&quot; cval=&quot;1&quot;&gt;&lt;/p&gt;'</span><span class="s3">, </span><span class="s1">decoded)</span>


<span class="s3">class </span><span class="s1">TestNavigableStringSubclasses(SoupTest):</span>

    <span class="s3">def </span><span class="s1">test_cdata(self):</span>
        <span class="s0"># None of the current builders turn CDATA sections into CData</span>
        <span class="s0"># objects, but you can create them manually.</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">cdata = CData(</span><span class="s4">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">soup.insert(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">cdata)</span>
        <span class="s1">self.assertEqual(str(soup)</span><span class="s3">, </span><span class="s4">&quot;&lt;![CDATA[foo]]&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(soup.find(text=</span><span class="s4">&quot;foo&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s4">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(soup.contents[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s4">&quot;foo&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_cdata_is_never_formatted(self):</span>
        <span class="s2">&quot;&quot;&quot;Text inside a CData object is passed into the formatter. 
 
        But the return value is ignored. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.count = </span><span class="s5">0</span>
        <span class="s3">def </span><span class="s1">increment(*args):</span>
            <span class="s1">self.count += </span><span class="s5">1</span>
            <span class="s3">return </span><span class="s4">&quot;BITTER FAILURE&quot;</span>

        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">cdata = CData(</span><span class="s4">&quot;&lt;&gt;&lt;&gt;&lt;&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">soup.insert(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">cdata)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s6">b&quot;&lt;![CDATA[&lt;&gt;&lt;&gt;&lt;&gt;]]&gt;&quot;</span><span class="s3">, </span><span class="s1">soup.encode(formatter=increment))</span>
        <span class="s1">self.assertEqual(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">self.count)</span>

    <span class="s3">def </span><span class="s1">test_doctype_ends_in_newline(self):</span>
        <span class="s0"># Unlike other NavigableString subclasses, a DOCTYPE always ends</span>
        <span class="s0"># in a newline.</span>
        <span class="s1">doctype = Doctype(</span><span class="s4">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">soup = self.soup(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">soup.insert(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">doctype)</span>
        <span class="s1">self.assertEqual(soup.encode()</span><span class="s3">, </span><span class="s6">b&quot;&lt;!DOCTYPE foo&gt;</span><span class="s3">\n</span><span class="s6">&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_declaration(self):</span>
        <span class="s1">d = Declaration(</span><span class="s4">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span><span class="s4">&quot;&lt;?foo?&gt;&quot;</span><span class="s3">, </span><span class="s1">d.output_ready())</span>

    <span class="s3">def </span><span class="s1">test_default_string_containers(self):</span>
        <span class="s0"># In some cases, we use different NavigableString subclasses for</span>
        <span class="s0"># the same text in different tags.</span>
        <span class="s1">soup = self.soup(</span>
            <span class="s4">&quot;&lt;div&gt;text&lt;/div&gt;&lt;script&gt;text&lt;/script&gt;&lt;style&gt;text&lt;/style&gt;&quot;</span>
        <span class="s1">)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">[NavigableString</span><span class="s3">, </span><span class="s1">Script</span><span class="s3">, </span><span class="s1">Stylesheet]</span><span class="s3">,</span>
            <span class="s1">[x.__class__ </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">soup.find_all(text=</span><span class="s3">True</span><span class="s1">)]</span>
        <span class="s1">)</span>

        <span class="s0"># The TemplateString is a little unusual because it's generally found</span>
        <span class="s0"># _inside_ children of a &lt;template&gt; element, not a direct child of the</span>
        <span class="s0"># &lt;template&gt; element.</span>
        <span class="s1">soup = self.soup(</span>
            <span class="s4">&quot;&lt;template&gt;Some text&lt;p&gt;In a tag&lt;/p&gt;&lt;/template&gt;Some text outside&quot;</span>
        <span class="s1">)</span>
        <span class="s3">assert </span><span class="s1">all(isinstance(x</span><span class="s3">, </span><span class="s1">TemplateString) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">soup.template.strings)</span>

        <span class="s0"># Once the &lt;template&gt; tag closed, we went back to using</span>
        <span class="s0"># NavigableString.</span>
        <span class="s1">outside = soup.template.next_sibling</span>
        <span class="s3">assert </span><span class="s1">isinstance(outside</span><span class="s3">, </span><span class="s1">NavigableString)</span>
        <span class="s3">assert not </span><span class="s1">isinstance(outside</span><span class="s3">, </span><span class="s1">TemplateString)</span>

<span class="s3">class </span><span class="s1">TestSoupSelector(TreeTest):</span>

    <span class="s1">HTML = </span><span class="s4">&quot;&quot;&quot; 
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; 
&quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; 
&lt;html&gt; 
&lt;head&gt; 
&lt;title&gt;The title&lt;/title&gt; 
&lt;link rel=&quot;stylesheet&quot; href=&quot;blah.css&quot; type=&quot;text/css&quot; id=&quot;l1&quot;&gt; 
&lt;/head&gt; 
&lt;body&gt; 
&lt;custom-dashed-tag class=&quot;dashed&quot; id=&quot;dash1&quot;&gt;Hello there.&lt;/custom-dashed-tag&gt; 
&lt;div id=&quot;main&quot; class=&quot;fancy&quot;&gt; 
&lt;div id=&quot;inner&quot;&gt; 
&lt;h1 id=&quot;header1&quot;&gt;An H1&lt;/h1&gt; 
&lt;p&gt;Some text&lt;/p&gt; 
&lt;p class=&quot;onep&quot; id=&quot;p1&quot;&gt;Some more text&lt;/p&gt; 
&lt;h2 id=&quot;header2&quot;&gt;An H2&lt;/h2&gt; 
&lt;p class=&quot;class1 class2 class3&quot; id=&quot;pmulti&quot;&gt;Another&lt;/p&gt; 
&lt;a href=&quot;http://bob.example.org/&quot; rel=&quot;friend met&quot; id=&quot;bob&quot;&gt;Bob&lt;/a&gt; 
&lt;h2 id=&quot;header3&quot;&gt;Another H2&lt;/h2&gt; 
&lt;a id=&quot;me&quot; href=&quot;http://simonwillison.net/&quot; rel=&quot;me&quot;&gt;me&lt;/a&gt; 
&lt;span class=&quot;s1&quot;&gt; 
&lt;a href=&quot;#&quot; id=&quot;s1a1&quot;&gt;span1a1&lt;/a&gt; 
&lt;a href=&quot;#&quot; id=&quot;s1a2&quot;&gt;span1a2 &lt;span id=&quot;s1a2s1&quot;&gt;test&lt;/span&gt;&lt;/a&gt; 
&lt;span class=&quot;span2&quot;&gt; 
&lt;a href=&quot;#&quot; id=&quot;s2a1&quot;&gt;span2a1&lt;/a&gt; 
&lt;/span&gt; 
&lt;span class=&quot;span3&quot;&gt;&lt;/span&gt; 
&lt;custom-dashed-tag class=&quot;dashed&quot; id=&quot;dash2&quot;/&gt; 
&lt;div data-tag=&quot;dashedvalue&quot; id=&quot;data1&quot;/&gt; 
&lt;/span&gt; 
&lt;/div&gt; 
&lt;x id=&quot;xid&quot;&gt; 
&lt;z id=&quot;zida&quot;/&gt; 
&lt;z id=&quot;zidab&quot;/&gt; 
&lt;z id=&quot;zidac&quot;/&gt; 
&lt;/x&gt; 
&lt;y id=&quot;yid&quot;&gt; 
&lt;z id=&quot;zidb&quot;/&gt; 
&lt;/y&gt; 
&lt;p lang=&quot;en&quot; id=&quot;lang-en&quot;&gt;English&lt;/p&gt; 
&lt;p lang=&quot;en-gb&quot; id=&quot;lang-en-gb&quot;&gt;English UK&lt;/p&gt; 
&lt;p lang=&quot;en-us&quot; id=&quot;lang-en-us&quot;&gt;English US&lt;/p&gt; 
&lt;p lang=&quot;fr&quot; id=&quot;lang-fr&quot;&gt;French&lt;/p&gt; 
&lt;/div&gt; 
 
&lt;div id=&quot;footer&quot;&gt; 
&lt;/div&gt; 
&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">setUp(self):</span>
        <span class="s1">self.soup = BeautifulSoup(self.HTML</span><span class="s3">, </span><span class="s4">'html.parser'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">assertSelects(self</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">expected_ids</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s1">el_ids = [el[</span><span class="s4">'id'</span><span class="s1">] </span><span class="s3">for </span><span class="s1">el </span><span class="s3">in </span><span class="s1">self.soup.select(selector</span><span class="s3">, </span><span class="s1">**kwargs)]</span>
        <span class="s1">el_ids.sort()</span>
        <span class="s1">expected_ids.sort()</span>
        <span class="s1">self.assertEqual(expected_ids</span><span class="s3">, </span><span class="s1">el_ids</span><span class="s3">,</span>
            <span class="s4">&quot;Selector %s, expected [%s], got [%s]&quot; </span><span class="s1">% (</span>
                <span class="s1">selector</span><span class="s3">, </span><span class="s4">', '</span><span class="s1">.join(expected_ids)</span><span class="s3">, </span><span class="s4">', '</span><span class="s1">.join(el_ids)</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s1">assertSelect = assertSelects</span>

    <span class="s3">def </span><span class="s1">assertSelectMultiple(self</span><span class="s3">, </span><span class="s1">*tests):</span>
        <span class="s3">for </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">expected_ids </span><span class="s3">in </span><span class="s1">tests:</span>
            <span class="s1">self.assertSelect(selector</span><span class="s3">, </span><span class="s1">expected_ids)</span>

    <span class="s3">def </span><span class="s1">test_one_tag_one(self):</span>
        <span class="s1">els = self.soup.select(</span><span class="s4">'title'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(els)</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(els[</span><span class="s5">0</span><span class="s1">].name</span><span class="s3">, </span><span class="s4">'title'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(els[</span><span class="s5">0</span><span class="s1">].contents</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'The title'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_one_tag_many(self):</span>
        <span class="s1">els = self.soup.select(</span><span class="s4">'div'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(els)</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">div </span><span class="s3">in </span><span class="s1">els:</span>
            <span class="s1">self.assertEqual(div.name</span><span class="s3">, </span><span class="s4">'div'</span><span class="s1">)</span>

        <span class="s1">el = self.soup.select_one(</span><span class="s4">'div'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span><span class="s4">'main'</span><span class="s3">, </span><span class="s1">el[</span><span class="s4">'id'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_select_one_returns_none_if_no_match(self):</span>
        <span class="s1">match = self.soup.select_one(</span><span class="s4">'nonexistenttag'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span><span class="s3">None, </span><span class="s1">match)</span>


    <span class="s3">def </span><span class="s1">test_tag_in_tag_one(self):</span>
        <span class="s1">els = self.soup.select(</span><span class="s4">'div div'</span><span class="s1">)</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'div div'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'inner'</span><span class="s3">, </span><span class="s4">'data1'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_tag_in_tag_many(self):</span>
        <span class="s3">for </span><span class="s1">selector </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'html div'</span><span class="s3">, </span><span class="s4">'html body div'</span><span class="s3">, </span><span class="s4">'body div'</span><span class="s1">):</span>
            <span class="s1">self.assertSelects(selector</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'data1'</span><span class="s3">, </span><span class="s4">'main'</span><span class="s3">, </span><span class="s4">'inner'</span><span class="s3">, </span><span class="s4">'footer'</span><span class="s1">])</span>


    <span class="s3">def </span><span class="s1">test_limit(self):</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'html div'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'main'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">limit=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'html body div'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'inner'</span><span class="s3">, </span><span class="s4">'main'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">limit=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'body div'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'data1'</span><span class="s3">, </span><span class="s4">'main'</span><span class="s3">, </span><span class="s4">'inner'</span><span class="s3">, </span><span class="s4">'footer'</span><span class="s1">]</span><span class="s3">,</span>
                           <span class="s1">limit=</span><span class="s5">10</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_tag_no_match(self):</span>
        <span class="s1">self.assertEqual(len(self.soup.select(</span><span class="s4">'del'</span><span class="s1">))</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_invalid_tag(self):</span>
        <span class="s1">self.assertRaises(SelectorSyntaxError</span><span class="s3">, </span><span class="s1">self.soup.select</span><span class="s3">, </span><span class="s4">'tag%t'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_select_dashed_tag_ids(self):</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'custom-dashed-tag'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'dash1'</span><span class="s3">, </span><span class="s4">'dash2'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_select_dashed_by_id(self):</span>
        <span class="s1">dashed = self.soup.select(</span><span class="s4">'custom-dashed-tag[id=</span><span class="s3">\&quot;</span><span class="s4">dash2</span><span class="s3">\&quot;</span><span class="s4">]'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(dashed[</span><span class="s5">0</span><span class="s1">].name</span><span class="s3">, </span><span class="s4">'custom-dashed-tag'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(dashed[</span><span class="s5">0</span><span class="s1">][</span><span class="s4">'id'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'dash2'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_dashed_tag_text(self):</span>
        <span class="s1">self.assertEqual(self.soup.select(</span><span class="s4">'body &gt; custom-dashed-tag'</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">].text</span><span class="s3">, </span><span class="s4">'Hello there.'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_select_dashed_matches_find_all(self):</span>
        <span class="s1">self.assertEqual(self.soup.select(</span><span class="s4">'custom-dashed-tag'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">self.soup.find_all(</span><span class="s4">'custom-dashed-tag'</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_header_tags(self):</span>
        <span class="s1">self.assertSelectMultiple(</span>
            <span class="s1">(</span><span class="s4">'h1'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'header1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'h2'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'header2'</span><span class="s3">, </span><span class="s4">'header3'</span><span class="s1">])</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_class_one(self):</span>
        <span class="s3">for </span><span class="s1">selector </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'.onep'</span><span class="s3">, </span><span class="s4">'p.onep'</span><span class="s3">, </span><span class="s4">'html p.onep'</span><span class="s1">):</span>
            <span class="s1">els = self.soup.select(selector)</span>
            <span class="s1">self.assertEqual(len(els)</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(els[</span><span class="s5">0</span><span class="s1">].name</span><span class="s3">, </span><span class="s4">'p'</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(els[</span><span class="s5">0</span><span class="s1">][</span><span class="s4">'class'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'onep'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_class_mismatched_tag(self):</span>
        <span class="s1">els = self.soup.select(</span><span class="s4">'div.onep'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(els)</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_one_id(self):</span>
        <span class="s3">for </span><span class="s1">selector </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'div#inner'</span><span class="s3">, </span><span class="s4">'#inner'</span><span class="s3">, </span><span class="s4">'div div#inner'</span><span class="s1">):</span>
            <span class="s1">self.assertSelects(selector</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'inner'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_bad_id(self):</span>
        <span class="s1">els = self.soup.select(</span><span class="s4">'#doesnotexist'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(els)</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_items_in_id(self):</span>
        <span class="s1">els = self.soup.select(</span><span class="s4">'div#inner p'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(els)</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">el </span><span class="s3">in </span><span class="s1">els:</span>
            <span class="s1">self.assertEqual(el.name</span><span class="s3">, </span><span class="s4">'p'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(els[</span><span class="s5">1</span><span class="s1">][</span><span class="s4">'class'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'onep'</span><span class="s1">])</span>
        <span class="s1">self.assertFalse(els[</span><span class="s5">0</span><span class="s1">].has_attr(</span><span class="s4">'class'</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_a_bunch_of_emptys(self):</span>
        <span class="s3">for </span><span class="s1">selector </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'div#main del'</span><span class="s3">, </span><span class="s4">'div#main div.oops'</span><span class="s3">, </span><span class="s4">'div div#main'</span><span class="s1">):</span>
            <span class="s1">self.assertEqual(len(self.soup.select(selector))</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_multi_class_support(self):</span>
        <span class="s3">for </span><span class="s1">selector </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'.class1'</span><span class="s3">, </span><span class="s4">'p.class1'</span><span class="s3">, </span><span class="s4">'.class2'</span><span class="s3">, </span><span class="s4">'p.class2'</span><span class="s3">,</span>
            <span class="s4">'.class3'</span><span class="s3">, </span><span class="s4">'p.class3'</span><span class="s3">, </span><span class="s4">'html p.class2'</span><span class="s3">, </span><span class="s4">'div#inner .class2'</span><span class="s1">):</span>
            <span class="s1">self.assertSelects(selector</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'pmulti'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_multi_class_selection(self):</span>
        <span class="s3">for </span><span class="s1">selector </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'.class1.class3'</span><span class="s3">, </span><span class="s4">'.class3.class2'</span><span class="s3">,</span>
                         <span class="s4">'.class1.class2.class3'</span><span class="s1">):</span>
            <span class="s1">self.assertSelects(selector</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'pmulti'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_child_selector(self):</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'.s1 &gt; a'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'s1a1'</span><span class="s3">, </span><span class="s4">'s1a2'</span><span class="s1">])</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'.s1 &gt; a span'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'s1a2s1'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_child_selector_id(self):</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'.s1 &gt; a#s1a2 span'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'s1a2s1'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_attribute_equals(self):</span>
        <span class="s1">self.assertSelectMultiple(</span>
            <span class="s1">(</span><span class="s4">'p[class=&quot;onep&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'p1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'p[id=&quot;p1&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'p1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[class=&quot;onep&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'p1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[id=&quot;p1&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'p1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'link[rel=&quot;stylesheet&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'l1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'link[type=&quot;text/css&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'l1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'link[href=&quot;blah.css&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'l1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'link[href=&quot;no-blah.css&quot;]'</span><span class="s3">, </span><span class="s1">[])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[rel=&quot;stylesheet&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'l1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[type=&quot;text/css&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'l1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[href=&quot;blah.css&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'l1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[href=&quot;no-blah.css&quot;]'</span><span class="s3">, </span><span class="s1">[])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'p[href=&quot;no-blah.css&quot;]'</span><span class="s3">, </span><span class="s1">[])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[href=&quot;no-blah.css&quot;]'</span><span class="s3">, </span><span class="s1">[])</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_attribute_tilde(self):</span>
        <span class="s1">self.assertSelectMultiple(</span>
            <span class="s1">(</span><span class="s4">'p[class~=&quot;class1&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'pmulti'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'p[class~=&quot;class2&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'pmulti'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'p[class~=&quot;class3&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'pmulti'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[class~=&quot;class1&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'pmulti'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[class~=&quot;class2&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'pmulti'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[class~=&quot;class3&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'pmulti'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'a[rel~=&quot;friend&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'bob'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'a[rel~=&quot;met&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'bob'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[rel~=&quot;friend&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'bob'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[rel~=&quot;met&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'bob'</span><span class="s1">])</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_attribute_startswith(self):</span>
        <span class="s1">self.assertSelectMultiple(</span>
            <span class="s1">(</span><span class="s4">'[rel^=&quot;style&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'l1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'link[rel^=&quot;style&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'l1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'notlink[rel^=&quot;notstyle&quot;]'</span><span class="s3">, </span><span class="s1">[])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[rel^=&quot;notstyle&quot;]'</span><span class="s3">, </span><span class="s1">[])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'link[rel^=&quot;notstyle&quot;]'</span><span class="s3">, </span><span class="s1">[])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'link[href^=&quot;bla&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'l1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'a[href^=&quot;http://&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'bob'</span><span class="s3">, </span><span class="s4">'me'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[href^=&quot;http://&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'bob'</span><span class="s3">, </span><span class="s4">'me'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[id^=&quot;p&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'pmulti'</span><span class="s3">, </span><span class="s4">'p1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[id^=&quot;m&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'me'</span><span class="s3">, </span><span class="s4">'main'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'div[id^=&quot;m&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'main'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'a[id^=&quot;m&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'me'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'div[data-tag^=&quot;dashed&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'data1'</span><span class="s1">])</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_attribute_endswith(self):</span>
        <span class="s1">self.assertSelectMultiple(</span>
            <span class="s1">(</span><span class="s4">'[href$=&quot;.css&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'l1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'link[href$=&quot;.css&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'l1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'link[id$=&quot;1&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'l1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[id$=&quot;1&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'data1'</span><span class="s3">, </span><span class="s4">'l1'</span><span class="s3">, </span><span class="s4">'p1'</span><span class="s3">, </span><span class="s4">'header1'</span><span class="s3">, </span><span class="s4">'s1a1'</span><span class="s3">, </span><span class="s4">'s2a1'</span><span class="s3">, </span><span class="s4">'s1a2s1'</span><span class="s3">, </span><span class="s4">'dash1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'div[id$=&quot;1&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'data1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[id$=&quot;noending&quot;]'</span><span class="s3">, </span><span class="s1">[])</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_attribute_contains(self):</span>
        <span class="s1">self.assertSelectMultiple(</span>
            <span class="s0"># From test_attribute_startswith</span>
            <span class="s1">(</span><span class="s4">'[rel*=&quot;style&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'l1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'link[rel*=&quot;style&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'l1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'notlink[rel*=&quot;notstyle&quot;]'</span><span class="s3">, </span><span class="s1">[])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[rel*=&quot;notstyle&quot;]'</span><span class="s3">, </span><span class="s1">[])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'link[rel*=&quot;notstyle&quot;]'</span><span class="s3">, </span><span class="s1">[])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'link[href*=&quot;bla&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'l1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[href*=&quot;http://&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'bob'</span><span class="s3">, </span><span class="s4">'me'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[id*=&quot;p&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'pmulti'</span><span class="s3">, </span><span class="s4">'p1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'div[id*=&quot;m&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'main'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'a[id*=&quot;m&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'me'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s0"># From test_attribute_endswith</span>
            <span class="s1">(</span><span class="s4">'[href*=&quot;.css&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'l1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'link[href*=&quot;.css&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'l1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'link[id*=&quot;1&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'l1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[id*=&quot;1&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'data1'</span><span class="s3">, </span><span class="s4">'l1'</span><span class="s3">, </span><span class="s4">'p1'</span><span class="s3">, </span><span class="s4">'header1'</span><span class="s3">, </span><span class="s4">'s1a1'</span><span class="s3">, </span><span class="s4">'s1a2'</span><span class="s3">, </span><span class="s4">'s2a1'</span><span class="s3">, </span><span class="s4">'s1a2s1'</span><span class="s3">, </span><span class="s4">'dash1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'div[id*=&quot;1&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'data1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[id*=&quot;noending&quot;]'</span><span class="s3">, </span><span class="s1">[])</span><span class="s3">,</span>
            <span class="s0"># New for this test</span>
            <span class="s1">(</span><span class="s4">'[href*=&quot;.&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'bob'</span><span class="s3">, </span><span class="s4">'me'</span><span class="s3">, </span><span class="s4">'l1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'a[href*=&quot;.&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'bob'</span><span class="s3">, </span><span class="s4">'me'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'link[href*=&quot;.&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'l1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'div[id*=&quot;n&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'main'</span><span class="s3">, </span><span class="s4">'inner'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'div[id*=&quot;nn&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'inner'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'div[data-tag*=&quot;edval&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'data1'</span><span class="s1">])</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_attribute_exact_or_hypen(self):</span>
        <span class="s1">self.assertSelectMultiple(</span>
            <span class="s1">(</span><span class="s4">'p[lang|=&quot;en&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'lang-en'</span><span class="s3">, </span><span class="s4">'lang-en-gb'</span><span class="s3">, </span><span class="s4">'lang-en-us'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[lang|=&quot;en&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'lang-en'</span><span class="s3">, </span><span class="s4">'lang-en-gb'</span><span class="s3">, </span><span class="s4">'lang-en-us'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'p[lang|=&quot;fr&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'lang-fr'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'p[lang|=&quot;gb&quot;]'</span><span class="s3">, </span><span class="s1">[])</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_attribute_exists(self):</span>
        <span class="s1">self.assertSelectMultiple(</span>
            <span class="s1">(</span><span class="s4">'[rel]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'l1'</span><span class="s3">, </span><span class="s4">'bob'</span><span class="s3">, </span><span class="s4">'me'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'link[rel]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'l1'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'a[rel]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'bob'</span><span class="s3">, </span><span class="s4">'me'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[lang]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'lang-en'</span><span class="s3">, </span><span class="s4">'lang-en-gb'</span><span class="s3">, </span><span class="s4">'lang-en-us'</span><span class="s3">, </span><span class="s4">'lang-fr'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'p[class]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'p1'</span><span class="s3">, </span><span class="s4">'pmulti'</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'[blah]'</span><span class="s3">, </span><span class="s1">[])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'p[blah]'</span><span class="s3">, </span><span class="s1">[])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s4">'div[data-tag]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'data1'</span><span class="s1">])</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_quoted_space_in_selector_name(self):</span>
        <span class="s1">html = </span><span class="s4">&quot;&quot;&quot;&lt;div style=&quot;display: wrong&quot;&gt;nope&lt;/div&gt; 
        &lt;div style=&quot;display: right&quot;&gt;yes&lt;/div&gt; 
        &quot;&quot;&quot;</span>
        <span class="s1">soup = BeautifulSoup(html</span><span class="s3">, </span><span class="s4">'html.parser'</span><span class="s1">)</span>
        <span class="s1">[chosen] = soup.select(</span><span class="s4">'div[style=&quot;display: right&quot;]'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span><span class="s4">&quot;yes&quot;</span><span class="s3">, </span><span class="s1">chosen.string)</span>

    <span class="s3">def </span><span class="s1">test_unsupported_pseudoclass(self):</span>
        <span class="s1">self.assertRaises(</span>
            <span class="s1">NotImplementedError</span><span class="s3">, </span><span class="s1">self.soup.select</span><span class="s3">, </span><span class="s4">&quot;a:no-such-pseudoclass&quot;</span><span class="s1">)</span>

        <span class="s1">self.assertRaises(</span>
            <span class="s1">SelectorSyntaxError</span><span class="s3">, </span><span class="s1">self.soup.select</span><span class="s3">, </span><span class="s4">&quot;a:nth-of-type(a)&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_nth_of_type(self):</span>
        <span class="s0"># Try to select first paragraph</span>
        <span class="s1">els = self.soup.select(</span><span class="s4">'div#inner p:nth-of-type(1)'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(els)</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(els[</span><span class="s5">0</span><span class="s1">].string</span><span class="s3">, </span><span class="s4">'Some text'</span><span class="s1">)</span>

        <span class="s0"># Try to select third paragraph</span>
        <span class="s1">els = self.soup.select(</span><span class="s4">'div#inner p:nth-of-type(3)'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(els)</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(els[</span><span class="s5">0</span><span class="s1">].string</span><span class="s3">, </span><span class="s4">'Another'</span><span class="s1">)</span>

        <span class="s0"># Try to select (non-existent!) fourth paragraph</span>
        <span class="s1">els = self.soup.select(</span><span class="s4">'div#inner p:nth-of-type(4)'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(els)</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s0"># Zero will select no tags.</span>
        <span class="s1">els = self.soup.select(</span><span class="s4">'div p:nth-of-type(0)'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(els)</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_nth_of_type_direct_descendant(self):</span>
        <span class="s1">els = self.soup.select(</span><span class="s4">'div#inner &gt; p:nth-of-type(1)'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(els)</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(els[</span><span class="s5">0</span><span class="s1">].string</span><span class="s3">, </span><span class="s4">'Some text'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_id_child_selector_nth_of_type(self):</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'#inner &gt; p:nth-of-type(2)'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'p1'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_select_on_element(self):</span>
        <span class="s0"># Other tests operate on the tree; this operates on an element</span>
        <span class="s0"># within the tree.</span>
        <span class="s1">inner = self.soup.find(</span><span class="s4">&quot;div&quot;</span><span class="s3">, </span><span class="s1">id=</span><span class="s4">&quot;main&quot;</span><span class="s1">)</span>
        <span class="s1">selected = inner.select(</span><span class="s4">&quot;div&quot;</span><span class="s1">)</span>
        <span class="s0"># The &lt;div id=&quot;inner&quot;&gt; tag was selected. The &lt;div id=&quot;footer&quot;&gt;</span>
        <span class="s0"># tag was not.</span>
        <span class="s1">self.assertSelectsIDs(selected</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'inner'</span><span class="s3">, </span><span class="s4">'data1'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_overspecified_child_id(self):</span>
        <span class="s1">self.assertSelects(</span><span class="s4">&quot;.fancy #inner&quot;</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'inner'</span><span class="s1">])</span>
        <span class="s1">self.assertSelects(</span><span class="s4">&quot;.normal #inner&quot;</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test_adjacent_sibling_selector(self):</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'#p1 + h2'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'header2'</span><span class="s1">])</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'#p1 + h2 + p'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'pmulti'</span><span class="s1">])</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'#p1 + #header2 + .class1'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'pmulti'</span><span class="s1">])</span>
        <span class="s1">self.assertEqual([]</span><span class="s3">, </span><span class="s1">self.soup.select(</span><span class="s4">'#p1 + p'</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_general_sibling_selector(self):</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'#p1 ~ h2'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'header2'</span><span class="s3">, </span><span class="s4">'header3'</span><span class="s1">])</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'#p1 ~ #header2'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'header2'</span><span class="s1">])</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'#p1 ~ h2 + a'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'me'</span><span class="s1">])</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'#p1 ~ h2 + [rel=&quot;me&quot;]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'me'</span><span class="s1">])</span>
        <span class="s1">self.assertEqual([]</span><span class="s3">, </span><span class="s1">self.soup.select(</span><span class="s4">'#inner ~ h2'</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_dangling_combinator(self):</span>
        <span class="s1">self.assertRaises(SelectorSyntaxError</span><span class="s3">, </span><span class="s1">self.soup.select</span><span class="s3">, </span><span class="s4">'h1 &gt;'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_sibling_combinator_wont_select_same_tag_twice(self):</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'p[lang] ~ p'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'lang-en-gb'</span><span class="s3">, </span><span class="s4">'lang-en-us'</span><span class="s3">, </span><span class="s4">'lang-fr'</span><span class="s1">])</span>

    <span class="s0"># Test the selector grouping operator (the comma)</span>
    <span class="s3">def </span><span class="s1">test_multiple_select(self):</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'x, y'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'xid'</span><span class="s3">, </span><span class="s4">'yid'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_multiple_select_with_no_space(self):</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'x,y'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'xid'</span><span class="s3">, </span><span class="s4">'yid'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_multiple_select_with_more_space(self):</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'x,    y'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'xid'</span><span class="s3">, </span><span class="s4">'yid'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_multiple_select_duplicated(self):</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'x, x'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'xid'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_multiple_select_sibling(self):</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'x, y ~ p[lang=fr]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'xid'</span><span class="s3">, </span><span class="s4">'lang-fr'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_multiple_select_tag_and_direct_descendant(self):</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'x, y &gt; z'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'xid'</span><span class="s3">, </span><span class="s4">'zidb'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_multiple_select_direct_descendant_and_tags(self):</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'div &gt; x, y, z'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'xid'</span><span class="s3">, </span><span class="s4">'yid'</span><span class="s3">, </span><span class="s4">'zida'</span><span class="s3">, </span><span class="s4">'zidb'</span><span class="s3">, </span><span class="s4">'zidab'</span><span class="s3">, </span><span class="s4">'zidac'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_multiple_select_indirect_descendant(self):</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'div x,y,  z'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'xid'</span><span class="s3">, </span><span class="s4">'yid'</span><span class="s3">, </span><span class="s4">'zida'</span><span class="s3">, </span><span class="s4">'zidb'</span><span class="s3">, </span><span class="s4">'zidab'</span><span class="s3">, </span><span class="s4">'zidac'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_invalid_multiple_select(self):</span>
        <span class="s1">self.assertRaises(SelectorSyntaxError</span><span class="s3">, </span><span class="s1">self.soup.select</span><span class="s3">, </span><span class="s4">',x, y'</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(SelectorSyntaxError</span><span class="s3">, </span><span class="s1">self.soup.select</span><span class="s3">, </span><span class="s4">'x,,y'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_multiple_select_attrs(self):</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'p[lang=en], p[lang=en-gb]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'lang-en'</span><span class="s3">, </span><span class="s4">'lang-en-gb'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_multiple_select_ids(self):</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'x, y &gt; z[id=zida], z[id=zidab], z[id=zidb]'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'xid'</span><span class="s3">, </span><span class="s4">'zidb'</span><span class="s3">, </span><span class="s4">'zidab'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_multiple_select_nested(self):</span>
        <span class="s1">self.assertSelects(</span><span class="s4">'body &gt; div &gt; x, y &gt; z'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'xid'</span><span class="s3">, </span><span class="s4">'zidb'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_select_duplicate_elements(self):</span>
        <span class="s0"># When markup contains duplicate elements, a multiple select</span>
        <span class="s0"># will find all of them.</span>
        <span class="s1">markup = </span><span class="s4">'&lt;div class=&quot;c1&quot;/&gt;&lt;div class=&quot;c2&quot;/&gt;&lt;div class=&quot;c1&quot;/&gt;'</span>
        <span class="s1">soup = BeautifulSoup(markup</span><span class="s3">, </span><span class="s4">'html.parser'</span><span class="s1">)</span>
        <span class="s1">selected = soup.select(</span><span class="s4">&quot;.c1, .c2&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span><span class="s5">3</span><span class="s3">, </span><span class="s1">len(selected))</span>

        <span class="s0"># Verify that find_all finds the same elements, though because</span>
        <span class="s0"># of an implementation detail it finds them in a different</span>
        <span class="s0"># order.</span>
        <span class="s3">for </span><span class="s1">element </span><span class="s3">in </span><span class="s1">soup.find_all(class_=[</span><span class="s4">'c1'</span><span class="s3">, </span><span class="s4">'c2'</span><span class="s1">]):</span>
            <span class="s3">assert </span><span class="s1">element </span><span class="s3">in </span><span class="s1">selected</span>
</pre>
</body>
</html>